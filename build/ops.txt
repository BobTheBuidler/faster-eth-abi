def ABIType.__init__(self, arrlist, node):
    self :: faster_eth_abi._grammar.ABIType
    arrlist, node :: union[object, None]
    r0, r1 :: object
    r2, r3 :: bool
    r4 :: None
L0:
    if is_error(arrlist) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    arrlist = r0
L2:
    if is_error(node) goto L3 else goto L9
L3:
    r1 = box(None, 1)
    inc_ref r1
    node = r1
L4:
    self.arrlist = arrlist; r2 = is_error
    if not r2 goto L10 (error at __init__:63) else goto L5 :: bool
L5:
    self.node = node; r3 = is_error
    if not r3 goto L7 (error at __init__:69) else goto L6 :: bool
L6:
    return 1
L7:
    r4 = <error> :: None
    return r4
L8:
    inc_ref arrlist
    goto L2
L9:
    inc_ref node
    goto L4
L10:
    dec_ref node
    goto L7

def ABIType.__init____ABIType_glue(self, arrlist, node):
    self :: faster_eth_abi._grammar.ABIType
    arrlist, node :: union[object, None]
    r0 :: str
    r1 :: object
    r2 :: list
    r3 :: dict
    r4 :: bool
    r5 :: i32
    r6 :: bit
    r7 :: i32
    r8 :: bit
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: tuple
    r13 :: object
    r14, r15 :: None
L0:
    r0 = '__init__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L15 else goto L1
L1:
    r2 = PyList_New(0)
    if is_error(r2) goto L16 else goto L2
L2:
    r3 = PyDict_New()
    if is_error(r3) goto L17 else goto L3
L3:
    r4 = 0
    if is_error(arrlist) goto L5 else goto L4
L4:
    r5 = PyList_Append(r2, arrlist)
    r6 = r5 >= 0 :: signed
    if not r6 goto L18 else goto L6 :: bool
L5:
    r4 = 1
L6:
    if is_error(node) goto L10 else goto L7
L7:
    if r4 goto L9 else goto L8 :: bool
L8:
    r7 = PyList_Append(r2, node)
    r8 = r7 >= 0 :: signed
    if not r8 goto L18 else goto L11 :: bool
L9:
    r9 = 'node'
    r10 = CPyDict_SetItem(r3, r9, node)
    r11 = r10 >= 0 :: signed
    if not r11 goto L18 else goto L11 :: bool
L10:
    r4 = 1
L11:
    r12 = PyList_AsTuple(r2)
    dec_ref r2
    if is_error(r12) goto L19 else goto L12
L12:
    r13 = PyObject_Call(r1, r12, r3)
    dec_ref r1
    dec_ref r12
    dec_ref r3
    if is_error(r13) goto L15 else goto L13
L13:
    r14 = unbox(None, r13)
    dec_ref r13
    if is_error(r14) goto L15 else goto L14
L14:
    return r14
L15:
    r15 = <error> :: None
    return r15
L16:
    dec_ref r1
    goto L15
L17:
    dec_ref r1
    dec_ref r2
    goto L15
L18:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L15
L19:
    dec_ref r1
    dec_ref r3
    goto L15

def ABIType.__repr__(self):
    self :: faster_eth_abi._grammar.ABIType
    r0, r1, r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12, r13, r14, r15, r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21, r22 :: str
    r23 :: list
    r24, r25, r26, r27, r28, r29 :: ptr
    r30, r31 :: str
L0:
    r0 = ''
    r1 = '<'
    r2 = '{:{}}'
    r3 = CPy_TYPE(self)
    r4 = '__qualname__'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L10 (error at __repr__:76) else goto L1
L1:
    r6 = cast(str, r5)
    if is_error(r6) goto L10 (error at __repr__:76) else goto L2
L2:
    r7 = ''
    r8 = 'format'
    r9 = [r2, r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L11 (error at __repr__:76) else goto L3
L3:
    dec_ref r6
    r12 = cast(str, r11)
    if is_error(r12) goto L10 (error at __repr__:76) else goto L4
L4:
    r13 = ' '
    r14 = '{!r:{}}'
    r15 = self.to_type_str()
    if is_error(r15) goto L12 (error at __repr__:76) else goto L5
L5:
    r16 = ''
    r17 = 'format'
    r18 = [r14, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L13 (error at __repr__:76) else goto L6
L6:
    dec_ref r15
    r21 = cast(str, r20)
    if is_error(r21) goto L12 (error at __repr__:76) else goto L7
L7:
    r22 = '>'
    r23 = PyList_New(5)
    if is_error(r23) goto L14 (error at __repr__:76) else goto L8
L8:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r1
    set_mem r25, r1 :: builtins.object*
    r26 = r25 + 8
    set_mem r26, r12 :: builtins.object*
    inc_ref r13
    r27 = r25 + 16
    set_mem r27, r13 :: builtins.object*
    r28 = r25 + 24
    set_mem r28, r21 :: builtins.object*
    inc_ref r22
    r29 = r25 + 32
    set_mem r29, r22 :: builtins.object*
    r30 = PyUnicode_Join(r0, r23)
    dec_ref r23
    if is_error(r30) goto L10 (error at __repr__:76) else goto L9
L9:
    return r30
L10:
    r31 = <error> :: str
    return r31
L11:
    dec_ref r6
    goto L10
L12:
    dec_ref r12
    goto L10
L13:
    dec_ref r12
    dec_ref r15
    goto L10
L14:
    dec_ref r12
    dec_ref r21
    goto L10

def ABIType.__repr____ABIType_glue(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: str
L0:
    r0 = '__repr__'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(str, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: str
    return r5

def ABIType.__eq__(self, other):
    self :: faster_eth_abi._grammar.ABIType
    other, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: union[bool, object]
    r5, r6 :: str
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10, r11 :: object
L0:
    r0 = CPy_TYPE(self)
    r1 = CPy_TYPE(other)
    r2 = r0 == r1
    dec_ref r0
    dec_ref r1
    if r2 goto L2 else goto L1 :: bool
L1:
    r3 = box(bit, r2)
    inc_ref r3
    r4 = r3
    goto L6
L2:
    r5 = self.to_type_str()
    if is_error(r5) goto L7 (error at __eq__:80) else goto L3
L3:
    r6 = 'to_type_str'
    r7 = [other]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775809, 0)
    if is_error(r9) goto L8 (error at __eq__:80) else goto L4
L4:
    r10 = PyObject_RichCompare(r5, r9, 2)
    dec_ref r5
    dec_ref r9
    if is_error(r10) goto L7 (error at __eq__:80) else goto L5
L5:
    r4 = r10
L6:
    return r4
L7:
    r11 = <error> :: object
    return r11
L8:
    dec_ref r5
    goto L7

def ABIType.__eq____ABIType_glue(self, other):
    self :: faster_eth_abi._grammar.ABIType
    other :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
L0:
    r0 = '__eq__'
    r1 = [self, other]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L2 else goto L1
L1:
    return r3
L2:
    r4 = <error> :: object
    return r4

def ABIType.to_type_str(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
L0:
    r0 = 'Must implement `to_type_str`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at to_type_str:87) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at to_type_str:87) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at to_type_str:87) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: str
    return r7

def ABIType.to_type_str__ABIType_glue(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: str
L0:
    r0 = 'to_type_str'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(str, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: str
    return r5

def ABIType.item_type(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: faster_eth_abi._grammar.ABIType
L0:
    r0 = 'Must implement `item_type`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at item_type:95) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at item_type:95) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at item_type:95) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: faster_eth_abi._grammar.ABIType
    return r7

def ABIType.item_type__ABIType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2, r3 :: faster_eth_abi._grammar.ABIType
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = cast(faster_eth_abi._grammar.ABIType, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: faster_eth_abi._grammar.ABIType
    return r3

def ABIType.validate(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: None
L0:
    r0 = 'Must implement `validate`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at validate:105) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at validate:105) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at validate:105) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: None
    return r7

def ABIType.validate__ABIType_glue(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: None
L0:
    r0 = 'validate'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = unbox(None, r3)
    dec_ref r3
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: None
    return r5

def ABIType.invalidate(self, error_msg):
    self :: faster_eth_abi._grammar.ABIType
    error_msg :: str
    r0 :: union[object, None]
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5, r6 :: str
    r7 :: object
    r8 :: str
    r9, r10, r11 :: object
    r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17, r18, r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = self.node
    if is_error(r0) goto L16 (error at invalidate:112) else goto L1
L1:
    r1 = "For '"
    inc_ref r0
    r2 = r0
    r3 = 'text'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L17 (error at invalidate:115) else goto L2
L2:
L3:
    r5 = PyObject_Str(r4)
    dec_ref r4
    if is_error(r5) goto L17 (error at invalidate:115) else goto L4
L4:
    r6 = "' type at column "
    inc_ref r0
    r7 = r0
    r8 = 'start'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L18 (error at invalidate:115) else goto L5
L5:
L6:
    r10 = object 1
    r11 = PyNumber_Add(r9, r10)
    dec_ref r9
    if is_error(r11) goto L18 (error at invalidate:115) else goto L7
L7:
    r12 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r12) goto L18 (error at invalidate:115) else goto L8
L8:
    r13 = " in '"
    r14 = r0
    r15 = 'full_text'
    r16 = CPyObject_GetAttr(r14, r15)
    dec_ref r14
    if is_error(r16) goto L19 (error at invalidate:116) else goto L9
L9:
L10:
    r17 = PyObject_Str(r16)
    dec_ref r16
    if is_error(r17) goto L19 (error at invalidate:115) else goto L11
L11:
    r18 = "': "
    r19 = CPyStr_Build(8, r1, r5, r6, r12, r13, r17, r18, error_msg)
    dec_ref r5
    dec_ref r12
    dec_ref r17
    if is_error(r19) goto L16 (error at invalidate:115) else goto L12
L12:
    r20 = faster_eth_abi._grammar.globals :: static
    r21 = 'ABITypeError'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L20 (error at invalidate:114) else goto L13
L13:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L20 (error at invalidate:114) else goto L14
L14:
    dec_ref r19
    CPy_Raise(r25)
    dec_ref r25
    if not 0 goto L16 (error at invalidate:114) else goto L15 :: bool
L15:
    unreachable
L16:
    r26 = <error> :: object
    return r26
L17:
    dec_ref r0
    goto L16
L18:
    dec_ref r0
    dec_ref r5
    goto L16
L19:
    dec_ref r5
    dec_ref r12
    goto L16
L20:
    dec_ref r19
    goto L16

def ABIType.invalidate__ABIType_glue(self, error_msg):
    self :: faster_eth_abi._grammar.ABIType
    error_msg, r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3, r4 :: object
L0:
    r0 = 'invalidate'
    r1 = [self, error_msg]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L2 else goto L1
L1:
    return r3
L2:
    r4 = <error> :: object
    return r4

def ABIType.is_array(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: union[object, None]
    r1 :: object
    r2 :: bit
    r3 :: bool
L0:
    r0 = borrow self.arrlist
    if is_error(r0) goto L2 (error at is_array:126) else goto L1
L1:
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    return r2
L2:
    r3 = <error> :: bool
    return r3

def ABIType.is_array__ABIType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2, r3 :: bool
L0:
    r0 = 'is_array'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: bool
    return r3

def ABIType.is_dynamic(self):
    self :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
L0:
    r0 = 'Must implement `is_dynamic`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at is_dynamic:134) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at is_dynamic:134) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at is_dynamic:134) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: bool
    return r7

def ABIType.is_dynamic__ABIType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2, r3 :: bool
L0:
    r0 = 'is_dynamic'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: bool
    return r3

def ABIType._has_dynamic_arrlist(self):
    self :: faster_eth_abi._grammar.ABIType
    r0, r1, r2 :: bool
    r3 :: union[object, None]
    r4, r5 :: object
    dim :: union[str, object]
    r6 :: int
    r7, r8 :: bit
    r9 :: bool
L0:
    r0 = self.is_array
    if is_error(r0) goto L12 (error at _has_dynamic_arrlist:139) else goto L1
L1:
    if r0 goto L3 else goto L2 :: bool
L2:
    r1 = r0
    goto L11
L3:
    r2 = 0
    r3 = self.arrlist
    if is_error(r3) goto L12 (error at _has_dynamic_arrlist:139) else goto L4
L4:
    r4 = PyObject_GetIter(r3)
    dec_ref r3
    if is_error(r4) goto L12 (error at _has_dynamic_arrlist:139) else goto L5
L5:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L13 else goto L6
L6:
    dim = r5
    r6 = CPyObject_Size(dim)
    dec_ref dim
    if is_error(r6) goto L14 (error at _has_dynamic_arrlist:139) else goto L7
L7:
    r7 = r6 == 0
    dec_ref r6 :: int
    if r7 goto L15 else goto L5 :: bool
L8:
    r2 = 1
    goto L10
L9:
    r8 = CPy_NoErrOccurred()
    if not r8 goto L12 (error at _has_dynamic_arrlist:139) else goto L10 :: bool
L10:
    r1 = r2
L11:
    return r1
L12:
    r9 = <error> :: bool
    return r9
L13:
    dec_ref r4
    goto L9
L14:
    dec_ref r4
    goto L12
L15:
    dec_ref r4
    goto L8

def ABIType._has_dynamic_arrlist__ABIType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.ABIType
    r0 :: str
    r1 :: object
    r2, r3 :: bool
L0:
    r0 = '_has_dynamic_arrlist'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: bool
    return r3

def ABIType.__ne__(__mypyc_self__, rhs):
    __mypyc_self__ :: faster_eth_abi._grammar.ABIType
    rhs, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4, r5 :: bit
    r6 :: object
    r7 :: bit
    r8 :: i32
    r9 :: bit
    r10 :: bool
    r11, r12 :: object
L0:
    r0 = __mypyc_self__.__eq__(rhs)
    if is_error(r0) goto L10 else goto L1
L1:
    r1 = load_address _Py_NotImplementedStruct
    r2 = r0 == r1
    if r2 goto L11 else goto L2 :: bool
L2:
    r3 = load_global Py_True :: static
    r4 = r0 == r3
    if r4 goto L12 else goto L4 :: bool
L3:
    r5 = 0
    goto L8
L4:
    r6 = load_global Py_False :: static
    r7 = r0 == r6
    if r7 goto L13 else goto L6 :: bool
L5:
    r5 = 1
    goto L8
L6:
    r8 = PyObject_Not(r0)
    dec_ref r0
    r9 = r8 >= 0 :: signed
    if not r9 goto L10 else goto L7 :: bool
L7:
    r10 = truncate r8: i32 to builtins.bool
    r5 = r10
L8:
    r11 = box(bit, r5)
    inc_ref r11
    return r11
L9:
    inc_ref r1
    return r1
L10:
    r12 = <error> :: object
    return r12
L11:
    dec_ref r0
    goto L9
L12:
    dec_ref r0
    goto L3
L13:
    dec_ref r0
    goto L5

def TupleType.__init__(self, components, arrlist, node):
    self :: faster_eth_abi._grammar.TupleType
    components :: tuple
    arrlist, node :: union[object, None]
    r0, r1 :: object
    r2 :: None
    r3 :: bool
    r4 :: None
L0:
    if is_error(arrlist) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    arrlist = r0
L2:
    if is_error(node) goto L3 else goto L9
L3:
    r1 = box(None, 1)
    inc_ref r1
    node = r1
L4:
    r2 = ABIType.__init__(self, arrlist, node)
    dec_ref arrlist
    dec_ref node
    if is_error(r2) goto L7 (error at __init__:160) else goto L5
L5:
    inc_ref components
    self.components = components; r3 = is_error
    if not r3 goto L7 (error at __init__:162) else goto L6 :: bool
L6:
    return 1
L7:
    r4 = <error> :: None
    return r4
L8:
    inc_ref arrlist
    goto L2
L9:
    inc_ref node
    goto L4

def TupleType.__init____TupleType_glue(self, components, arrlist, node):
    self :: faster_eth_abi._grammar.TupleType
    components :: tuple
    arrlist, node :: union[object, None]
    r0 :: str
    r1 :: object
    r2 :: list
    r3, r4 :: ptr
    r5 :: dict
    r6 :: bool
    r7 :: i32
    r8 :: bit
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: tuple
    r13 :: object
    r14, r15 :: None
L0:
    r0 = '__init__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L12 else goto L1
L1:
    r2 = PyList_New(1)
    if is_error(r2) goto L13 else goto L2
L2:
    r3 = get_element_ptr r2 ob_item :: PyListObject
    r4 = load_mem r3 :: ptr*
    inc_ref components
    set_mem r4, components :: builtins.object*
    r5 = PyDict_New()
    if is_error(r5) goto L14 else goto L3
L3:
    r6 = 0
    if is_error(arrlist) goto L5 else goto L4
L4:
    r7 = PyList_Append(r2, arrlist)
    r8 = r7 >= 0 :: signed
    if not r8 goto L15 else goto L6 :: bool
L5:
    r6 = 1
L6:
    if is_error(node) goto L8 else goto L7
L7:
    r9 = 'node'
    r10 = CPyDict_SetItem(r5, r9, node)
    r11 = r10 >= 0 :: signed
    if not r11 goto L15 else goto L8 :: bool
L8:
    r12 = PyList_AsTuple(r2)
    dec_ref r2
    if is_error(r12) goto L16 else goto L9
L9:
    r13 = PyObject_Call(r1, r12, r5)
    dec_ref r1
    dec_ref r12
    dec_ref r5
    if is_error(r13) goto L12 else goto L10
L10:
    r14 = unbox(None, r13)
    dec_ref r13
    if is_error(r14) goto L12 else goto L11
L11:
    return r14
L12:
    r15 = <error> :: None
    return r15
L13:
    dec_ref r1
    goto L12
L14:
    dec_ref r1
    dec_ref r2
    goto L12
L15:
    dec_ref r1
    dec_ref r2
    dec_ref r5
    goto L12
L16:
    dec_ref r1
    dec_ref r5
    goto L12

def TupleType.to_type_str(self):
    self :: faster_eth_abi._grammar.TupleType
    r0, arrlist :: union[object, None]
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: str
    r5, r6 :: object
    r7 :: tuple
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[2]
    r12 :: object_ptr
    r13, r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[2]
    r18 :: object_ptr
    r19 :: object
    r20, r21, r22, r23 :: str
    r24 :: tuple
    r25 :: ptr
    r26 :: native_int
    r27 :: list
    r28 :: ptr
    r29, r30 :: native_int
    r31 :: bit
    r32 :: object
    r33 :: faster_eth_abi._grammar.ABIType
    r34 :: str
    r35 :: native_int
    r36, r37, r38, r39, r40 :: str
L0:
    r0 = self.arrlist
    if is_error(r0) goto L23 (error at to_type_str:169) else goto L1
L1:
    arrlist = r0
    r1 = PyTuple_Check(arrlist)
    if r1 goto L2 else goto L24 :: bool
L2:
    r2 = ''
    r3 = builtins :: module
    r4 = 'repr'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L25 (error at to_type_str:172) else goto L3
L3:
    r6 = load_address PyList_Type
    r7 = cast(tuple, arrlist)
    if is_error(r7) goto L26 (error at to_type_str:172) else goto L4
L4:
    r8 = builtins :: module
    r9 = 'map'
    r10 = CPyObject_GetAttr(r8, r9)
    if is_error(r10) goto L27 (error at to_type_str:172) else goto L5
L5:
    r11 = [r6, r7]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 2, 0)
    dec_ref r10
    if is_error(r13) goto L27 (error at to_type_str:172) else goto L6
L6:
    dec_ref r7
    r14 = builtins :: module
    r15 = 'map'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L28 (error at to_type_str:172) else goto L7
L7:
    r17 = [r5, r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 2, 0)
    dec_ref r16
    if is_error(r19) goto L28 (error at to_type_str:172) else goto L8
L8:
    dec_ref r5
    dec_ref r13
    r20 = PyUnicode_Join(r2, r19)
    dec_ref r19
    if is_error(r20) goto L23 (error at to_type_str:172) else goto L9
L9:
    arrlist = r20
    goto L11
L10:
    r21 = ''
    inc_ref r21
    arrlist = r21
L11:
    r22 = '('
    r23 = ','
    r24 = self.components
    if is_error(r24) goto L25 (error at to_type_str:176) else goto L12
L12:
    r25 = get_element_ptr r24 ob_size :: PyVarObject
    r26 = load_mem r25 :: native_int*
    r27 = PyList_New(r26)
    if is_error(r27) goto L29 (error at to_type_str:176) else goto L13
L13:
    r28 = get_element_ptr r24 ob_size :: PyVarObject
    r29 = load_mem r28 :: native_int*
    r30 = 0
L14:
    r31 = r30 < r29 :: signed
    if r31 goto L15 else goto L30 :: bool
L15:
    r32 = CPySequenceTuple_GetItemUnsafe(r24, r30)
    r33 = cast(faster_eth_abi._grammar.ABIType, r32)
    if is_error(r33) goto L31 (error at to_type_str:176) else goto L16
L16:
    r34 = r33.to_type_str()
    dec_ref r33
    if is_error(r34) goto L31 (error at to_type_str:176) else goto L17
L17:
    CPyList_SetItemUnsafe(r27, r30, r34)
L18:
    r35 = r30 + 1
    r30 = r35
    goto L14
L19:
    r36 = PyUnicode_Join(r23, r27)
    dec_ref r27
    if is_error(r36) goto L25 (error at to_type_str:176) else goto L20
L20:
    r37 = ')'
    r38 = cast(str, arrlist)
    if is_error(r38) goto L32 (error at to_type_str:176) else goto L21
L21:
    r39 = CPyStr_Build(4, r22, r36, r37, r38)
    dec_ref r36
    dec_ref r38
    if is_error(r39) goto L23 (error at to_type_str:176) else goto L22
L22:
    return r39
L23:
    r40 = <error> :: str
    return r40
L24:
    dec_ref arrlist
    goto L10
L25:
    dec_ref arrlist
    goto L23
L26:
    dec_ref r5
    goto L23
L27:
    dec_ref r5
    dec_ref r7
    goto L23
L28:
    dec_ref r5
    dec_ref r13
    goto L23
L29:
    dec_ref arrlist
    dec_ref r24
    goto L23
L30:
    dec_ref r24
    goto L19
L31:
    dec_ref arrlist
    dec_ref r24
    dec_ref r27
    goto L23
L32:
    dec_ref r36
    goto L23

def TupleType.to_type_str__TupleType_glue(self):
    self :: faster_eth_abi._grammar.TupleType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: str
L0:
    r0 = 'to_type_str'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(str, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: str
    return r5

def TupleType.item_type(self):
    self :: faster_eth_abi._grammar.TupleType
    r0 :: bool
    r1, r2, r3, r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: union[object, None]
    r12, r13, r14, r15, r16, r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: union[object, None]
    r22 :: object
    arrlist :: union[object, None]
    r23, r24 :: object
    r25 :: bit
    r26 :: tuple
    r27 :: union[object, None]
    r28 :: faster_eth_abi._grammar.TupleType
    r29 :: tuple
    r30 :: union[object, None]
    r31 :: object[3]
    r32 :: object_ptr
    r33, r34 :: object
    r35, r36 :: faster_eth_abi._grammar.TupleType
L0:
    r0 = self.is_array
    if is_error(r0) goto L26 (error at item_type:180) else goto L1
L1:
    if r0 goto L8 else goto L2 :: bool
L2:
    r1 = "Cannot determine item type for non-array type '"
    r2 = self.to_type_str()
    if is_error(r2) goto L26 (error at item_type:182) else goto L3
L3:
    r3 = "'"
    r4 = CPyStr_Build(3, r1, r2, r3)
    dec_ref r2
    if is_error(r4) goto L26 (error at item_type:182) else goto L4
L4:
    r5 = builtins :: module
    r6 = 'ValueError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L27 (error at item_type:181) else goto L5
L5:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L27 (error at item_type:181) else goto L6
L6:
    dec_ref r4
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L26 (error at item_type:181) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = self.arrlist
    if is_error(r11) goto L26 (error at item_type:185) else goto L9
L9:
    r12 = load_address _Py_NoneStruct
    r13 = load_address _Py_NoneStruct
    r14 = object -1
    r15 = PySlice_New(r12, r14, r13)
    if is_error(r15) goto L28 (error at item_type:185) else goto L10
L10:
    r16 = r11
    r17 = PyObject_GetItem(r16, r15)
    dec_ref r16
    dec_ref r15
    if is_error(r17) goto L26 (error at item_type:185) else goto L11
L11:
L12:
    r18 = PyObject_IsTrue(r17)
    r19 = r18 >= 0 :: signed
    if not r19 goto L29 (error at item_type:-1) else goto L13 :: bool
L13:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L14 else goto L30 :: bool
L14:
    r21 = r17
    goto L16
L15:
    r22 = box(None, 1)
    inc_ref r22
    r21 = r22
L16:
    arrlist = r21
    r23 = CPy_TYPE(self)
    r24 = faster_eth_abi._grammar.TupleType :: type
    r25 = r23 == r24
    if r25 goto L31 else goto L21 :: bool
L17:
    r26 = self.components
    if is_error(r26) goto L32 (error at item_type:188) else goto L18
L18:
    r27 = self.node
    if is_error(r27) goto L33 (error at item_type:188) else goto L19
L19:
    r28 = TupleType(r26, arrlist, r27)
    dec_ref r26
    dec_ref arrlist
    dec_ref r27
    if is_error(r28) goto L26 (error at item_type:188) else goto L20
L20:
    return r28
L21:
    r29 = self.components
    if is_error(r29) goto L34 (error at item_type:190) else goto L22
L22:
    r30 = self.node
    if is_error(r30) goto L35 (error at item_type:190) else goto L23
L23:
    r31 = [r29, arrlist, r30]
    r32 = load_address r31
    r33 = ('node',)
    r34 = PyObject_Vectorcall(r23, r32, 2, r33)
    dec_ref r23
    if is_error(r34) goto L36 (error at item_type:190) else goto L24
L24:
    dec_ref r29
    dec_ref arrlist
    dec_ref r30
    r35 = cast(faster_eth_abi._grammar.TupleType, r34)
    if is_error(r35) goto L26 (error at item_type:190) else goto L25
L25:
    return r35
L26:
    r36 = <error> :: faster_eth_abi._grammar.TupleType
    return r36
L27:
    dec_ref r4
    goto L26
L28:
    dec_ref r11
    goto L26
L29:
    dec_ref r17
    goto L26
L30:
    dec_ref r17
    goto L15
L31:
    dec_ref r23
    goto L17
L32:
    dec_ref arrlist
    goto L26
L33:
    dec_ref arrlist
    dec_ref r26
    goto L26
L34:
    dec_ref arrlist
    dec_ref r23
    goto L26
L35:
    dec_ref arrlist
    dec_ref r23
    dec_ref r29
    goto L26
L36:
    dec_ref arrlist
    dec_ref r29
    dec_ref r30
    goto L26

def TupleType.item_type__ABIType_glue(__mypyc_self__):
    __mypyc_self__, r0 :: faster_eth_abi._grammar.TupleType
    r1 :: faster_eth_abi._grammar.ABIType
L0:
    r0 = __mypyc_self__.item_type
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._grammar.ABIType
    return r1

def TupleType.item_type__TupleType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.TupleType
    r0 :: str
    r1 :: object
    r2, r3 :: faster_eth_abi._grammar.TupleType
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = cast(faster_eth_abi._grammar.TupleType, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: faster_eth_abi._grammar.TupleType
    return r3

def TupleType.validate(self):
    self :: faster_eth_abi._grammar.TupleType
    r0 :: tuple
    r1 :: ptr
    r2, r3 :: native_int
    r4 :: bit
    r5 :: object
    r6 :: faster_eth_abi._grammar.ABIType
    r7 :: None
    r8 :: native_int
    r9 :: None
L0:
    r0 = self.components
    if is_error(r0) goto L7 (error at validate:193) else goto L1
L1:
    r1 = get_element_ptr r0 ob_size :: PyVarObject
    r2 = load_mem r1 :: native_int*
    r3 = 0
L2:
    r4 = r3 < r2 :: signed
    if r4 goto L3 else goto L8 :: bool
L3:
    r5 = CPySequenceTuple_GetItemUnsafe(r0, r3)
    r6 = cast(faster_eth_abi._grammar.ABIType, r5)
    if is_error(r6) goto L9 (error at validate:193) else goto L4
L4:
    r7 = r6.validate()
    dec_ref r6
    if is_error(r7) goto L9 (error at validate:194) else goto L5
L5:
    r8 = r3 + 1
    r3 = r8
    goto L2
L6:
    return 1
L7:
    r9 = <error> :: None
    return r9
L8:
    dec_ref r0
    goto L6
L9:
    dec_ref r0
    goto L7

def TupleType.validate__TupleType_glue(self):
    self :: faster_eth_abi._grammar.TupleType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: None
L0:
    r0 = 'validate'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = unbox(None, r3)
    dec_ref r3
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: None
    return r5

def TupleType.is_dynamic(self):
    self :: faster_eth_abi._grammar.TupleType
    r0, r1 :: bool
    r2 :: tuple
    r3 :: ptr
    r4, r5 :: native_int
    r6 :: bit
    r7 :: object
    r8 :: faster_eth_abi._grammar.ABIType
    r9 :: bool
    r10 :: native_int
    r11 :: bool
L0:
    r0 = self._has_dynamic_arrlist
    if is_error(r0) goto L12 (error at is_dynamic:198) else goto L1
L1:
    if r0 goto L2 else goto L3 :: bool
L2:
    return 1
L3:
    r1 = 0
    r2 = self.components
    if is_error(r2) goto L12 (error at is_dynamic:201) else goto L4
L4:
    r3 = get_element_ptr r2 ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = 0
L5:
    r6 = r5 < r4 :: signed
    if r6 goto L6 else goto L13 :: bool
L6:
    r7 = CPySequenceTuple_GetItemUnsafe(r2, r5)
    r8 = cast(faster_eth_abi._grammar.ABIType, r7)
    if is_error(r8) goto L14 (error at is_dynamic:201) else goto L7
L7:
    r9 = r8.is_dynamic
    dec_ref r8
    if is_error(r9) goto L14 (error at is_dynamic:201) else goto L8
L8:
    if r9 goto L15 else goto L10 :: bool
L9:
    r1 = 1
    goto L11
L10:
    r10 = r5 + 1
    r5 = r10
    goto L5
L11:
    return r1
L12:
    r11 = <error> :: bool
    return r11
L13:
    dec_ref r2
    goto L11
L14:
    dec_ref r2
    goto L12
L15:
    dec_ref r2
    goto L9

def TupleType.is_dynamic__TupleType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.TupleType
    r0 :: str
    r1 :: object
    r2, r3 :: bool
L0:
    r0 = 'is_dynamic'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: bool
    return r3

def BasicType.__init__(self, base, sub, arrlist, node):
    self :: faster_eth_abi._grammar.BasicType
    base :: str
    sub :: union[int, tuple, None]
    arrlist, node :: union[object, None]
    r0, r1, r2 :: object
    r3 :: None
    r4, r5 :: bool
    r6 :: None
L0:
    if is_error(sub) goto L1 else goto L11
L1:
    r0 = box(None, 1)
    inc_ref r0
    sub = r0
L2:
    if is_error(arrlist) goto L3 else goto L12
L3:
    r1 = box(None, 1)
    inc_ref r1
    arrlist = r1
L4:
    if is_error(node) goto L5 else goto L13
L5:
    r2 = box(None, 1)
    inc_ref r2
    node = r2
L6:
    r3 = ABIType.__init__(self, arrlist, node)
    dec_ref arrlist
    dec_ref node
    if is_error(r3) goto L14 (error at __init__:221) else goto L7
L7:
    inc_ref base
    self.base = base; r4 = is_error
    if not r4 goto L14 (error at __init__:223) else goto L8 :: bool
L8:
    self.sub = sub; r5 = is_error
    if not r5 goto L10 (error at __init__:226) else goto L9 :: bool
L9:
    return 1
L10:
    r6 = <error> :: None
    return r6
L11:
    inc_ref sub
    goto L2
L12:
    inc_ref arrlist
    goto L4
L13:
    inc_ref node
    goto L6
L14:
    dec_ref sub
    goto L10

def BasicType.__init____BasicType_glue(self, base, sub, arrlist, node):
    self :: faster_eth_abi._grammar.BasicType
    base :: str
    sub :: union[int, tuple, None]
    arrlist, node :: union[object, None]
    r0 :: str
    r1 :: object
    r2 :: list
    r3, r4 :: ptr
    r5 :: dict
    r6 :: bool
    r7 :: i32
    r8 :: bit
    r9 :: i32
    r10 :: bit
    r11 :: str
    r12 :: i32
    r13 :: bit
    r14 :: str
    r15 :: i32
    r16 :: bit
    r17 :: tuple
    r18 :: object
    r19, r20 :: None
L0:
    r0 = '__init__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L17 else goto L1
L1:
    r2 = PyList_New(1)
    if is_error(r2) goto L18 else goto L2
L2:
    r3 = get_element_ptr r2 ob_item :: PyListObject
    r4 = load_mem r3 :: ptr*
    inc_ref base
    set_mem r4, base :: builtins.object*
    r5 = PyDict_New()
    if is_error(r5) goto L19 else goto L3
L3:
    r6 = 0
    if is_error(sub) goto L5 else goto L4
L4:
    r7 = PyList_Append(r2, sub)
    r8 = r7 >= 0 :: signed
    if not r8 goto L20 else goto L6 :: bool
L5:
    r6 = 1
L6:
    if is_error(arrlist) goto L10 else goto L7
L7:
    if r6 goto L9 else goto L8 :: bool
L8:
    r9 = PyList_Append(r2, arrlist)
    r10 = r9 >= 0 :: signed
    if not r10 goto L20 else goto L11 :: bool
L9:
    r11 = 'arrlist'
    r12 = CPyDict_SetItem(r5, r11, arrlist)
    r13 = r12 >= 0 :: signed
    if not r13 goto L20 else goto L11 :: bool
L10:
    r6 = 1
L11:
    if is_error(node) goto L13 else goto L12
L12:
    r14 = 'node'
    r15 = CPyDict_SetItem(r5, r14, node)
    r16 = r15 >= 0 :: signed
    if not r16 goto L20 else goto L13 :: bool
L13:
    r17 = PyList_AsTuple(r2)
    dec_ref r2
    if is_error(r17) goto L21 else goto L14
L14:
    r18 = PyObject_Call(r1, r17, r5)
    dec_ref r1
    dec_ref r17
    dec_ref r5
    if is_error(r18) goto L17 else goto L15
L15:
    r19 = unbox(None, r18)
    dec_ref r18
    if is_error(r19) goto L17 else goto L16
L16:
    return r19
L17:
    r20 = <error> :: None
    return r20
L18:
    dec_ref r1
    goto L17
L19:
    dec_ref r1
    dec_ref r2
    goto L17
L20:
    dec_ref r1
    dec_ref r2
    dec_ref r5
    goto L17
L21:
    dec_ref r1
    dec_ref r5
    goto L17

def BasicType.to_type_str(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: union[int, tuple, None]
    r1 :: union[object, None]
    r2 :: bit
    r3 :: int
    r4, substr :: str
    r5 :: bit
    r6 :: str
    r7 :: object
    r8 :: tuple
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[2]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: str
    r17 :: bit
    r18, r19, r20 :: str
    r21 :: object
    r22 :: str
    r23, r24 :: object
    r25 :: tuple
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: object[2]
    r30 :: object_ptr
    r31, r32 :: object
    r33 :: str
    r34 :: object
    r35 :: object[2]
    r36 :: object_ptr
    r37 :: object
    r38, r39, r40, r41, r42 :: str
L0:
    r0 = self.sub
    if is_error(r0) goto L28 (error at to_type_str:234) else goto L1
L1:
    r1 = self.arrlist
    if is_error(r1) goto L29 (error at to_type_str:234) else goto L2
L2:
    r2 = PyLong_Check(r0)
    if r2 goto L3 else goto L6 :: bool
L3:
    r3 = unbox(int, r0)
    dec_ref r0
    if is_error(r3) goto L30 (error at to_type_str:237) else goto L4
L4:
    r4 = CPyTagged_Str(r3)
    dec_ref r3 :: int
    if is_error(r4) goto L30 (error at to_type_str:237) else goto L5
L5:
    substr = r4
    goto L13
L6:
    r5 = PyTuple_Check(r0)
    if r5 goto L7 else goto L31 :: bool
L7:
    r6 = 'x'
    r7 = load_address PyUnicode_Type
    r8 = cast(tuple, r0)
    if is_error(r8) goto L30 (error at to_type_str:239) else goto L8
L8:
    r9 = builtins :: module
    r10 = 'map'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L32 (error at to_type_str:239) else goto L9
L9:
    r12 = [r7, r8]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 2, 0)
    dec_ref r11
    if is_error(r14) goto L32 (error at to_type_str:239) else goto L10
L10:
    dec_ref r8
    r15 = PyUnicode_Join(r6, r14)
    dec_ref r14
    if is_error(r15) goto L30 (error at to_type_str:239) else goto L11
L11:
    substr = r15
    goto L13
L12:
    r16 = ''
    inc_ref r16
    substr = r16
L13:
    r17 = PyTuple_Check(r1)
    if r17 goto L14 else goto L33 :: bool
L14:
    r18 = self.base
    if is_error(r18) goto L34 (error at to_type_str:244) else goto L15
L15:
    r19 = PyUnicode_Concat(r18, substr)
    dec_ref r18
    dec_ref substr
    if is_error(r19) goto L30 (error at to_type_str:244) else goto L16
L16:
    r20 = ''
    r21 = builtins :: module
    r22 = 'repr'
    r23 = CPyObject_GetAttr(r21, r22)
    if is_error(r23) goto L35 (error at to_type_str:244) else goto L17
L17:
    r24 = load_address PyList_Type
    r25 = cast(tuple, r1)
    if is_error(r25) goto L36 (error at to_type_str:244) else goto L18
L18:
    r26 = builtins :: module
    r27 = 'map'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L37 (error at to_type_str:244) else goto L19
L19:
    r29 = [r24, r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 2, 0)
    dec_ref r28
    if is_error(r31) goto L37 (error at to_type_str:244) else goto L20
L20:
    dec_ref r25
    r32 = builtins :: module
    r33 = 'map'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L38 (error at to_type_str:244) else goto L21
L21:
    r35 = [r23, r31]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r34, r36, 2, 0)
    dec_ref r34
    if is_error(r37) goto L38 (error at to_type_str:244) else goto L22
L22:
    dec_ref r23
    dec_ref r31
    r38 = PyUnicode_Join(r20, r37)
    dec_ref r37
    if is_error(r38) goto L39 (error at to_type_str:244) else goto L23
L23:
    r39 = PyUnicode_Concat(r19, r38)
    dec_ref r19
    dec_ref r38
    if is_error(r39) goto L28 (error at to_type_str:244) else goto L24
L24:
    return r39
L25:
    r40 = self.base
    if is_error(r40) goto L40 (error at to_type_str:246) else goto L26
L26:
    r41 = PyUnicode_Concat(r40, substr)
    dec_ref r40
    dec_ref substr
    if is_error(r41) goto L28 (error at to_type_str:246) else goto L27
L27:
    return r41
L28:
    r42 = <error> :: str
    return r42
L29:
    dec_ref r0
    goto L28
L30:
    dec_ref r1
    goto L28
L31:
    dec_ref r0
    goto L12
L32:
    dec_ref r1
    dec_ref r8
    goto L28
L33:
    dec_ref r1
    goto L25
L34:
    dec_ref r1
    dec_ref substr
    goto L28
L35:
    dec_ref r1
    dec_ref r19
    goto L28
L36:
    dec_ref r19
    dec_ref r23
    goto L28
L37:
    dec_ref r19
    dec_ref r23
    dec_ref r25
    goto L28
L38:
    dec_ref r19
    dec_ref r23
    dec_ref r31
    goto L28
L39:
    dec_ref r19
    goto L28
L40:
    dec_ref substr
    goto L28

def BasicType.to_type_str__BasicType_glue(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: str
L0:
    r0 = 'to_type_str'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(str, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: str
    return r5

def BasicType.item_type(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: bool
    r1, r2, r3, r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12 :: union[object, None]
    r13, r14, r15, r16, r17, r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: bool
    r22 :: union[object, None]
    r23 :: object
    arrlist :: union[object, None]
    r24 :: object
    r25 :: bit
    r26 :: str
    r27 :: union[int, tuple, None]
    r28 :: union[object, None]
    r29 :: faster_eth_abi._grammar.BasicType
    r30 :: str
    r31 :: union[int, tuple, None]
    r32 :: union[object, None]
    r33 :: object[4]
    r34 :: object_ptr
    r35, r36 :: object
    r37, r38 :: faster_eth_abi._grammar.BasicType
L0:
    r0 = self.is_array
    if is_error(r0) goto L28 (error at item_type:250) else goto L1
L1:
    if r0 goto L8 else goto L2 :: bool
L2:
    r1 = "Cannot determine item type for non-array type '"
    r2 = self.to_type_str()
    if is_error(r2) goto L28 (error at item_type:252) else goto L3
L3:
    r3 = "'"
    r4 = CPyStr_Build(3, r1, r2, r3)
    dec_ref r2
    if is_error(r4) goto L28 (error at item_type:252) else goto L4
L4:
    r5 = builtins :: module
    r6 = 'ValueError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L29 (error at item_type:251) else goto L5
L5:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L29 (error at item_type:251) else goto L6
L6:
    dec_ref r4
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L28 (error at item_type:251) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = CPy_TYPE(self)
    r12 = self.arrlist
    if is_error(r12) goto L30 (error at item_type:256) else goto L9
L9:
    r13 = load_address _Py_NoneStruct
    r14 = load_address _Py_NoneStruct
    r15 = object -1
    r16 = PySlice_New(r13, r15, r14)
    if is_error(r16) goto L31 (error at item_type:256) else goto L10
L10:
    r17 = r12
    r18 = PyObject_GetItem(r17, r16)
    dec_ref r17
    dec_ref r16
    if is_error(r18) goto L30 (error at item_type:256) else goto L11
L11:
L12:
    r19 = PyObject_IsTrue(r18)
    r20 = r19 >= 0 :: signed
    if not r20 goto L32 (error at item_type:-1) else goto L13 :: bool
L13:
    r21 = truncate r19: i32 to builtins.bool
    if r21 goto L14 else goto L33 :: bool
L14:
    r22 = r18
    goto L16
L15:
    r23 = box(None, 1)
    inc_ref r23
    r22 = r23
L16:
    arrlist = r22
    r24 = faster_eth_abi._grammar.BasicType :: type
    r25 = r11 == r24
    if r25 goto L34 else goto L22 :: bool
L17:
    r26 = self.base
    if is_error(r26) goto L35 (error at item_type:258) else goto L18
L18:
    r27 = self.sub
    if is_error(r27) goto L36 (error at item_type:258) else goto L19
L19:
    r28 = self.node
    if is_error(r28) goto L37 (error at item_type:258) else goto L20
L20:
    r29 = BasicType(r26, r27, arrlist, r28)
    dec_ref r26
    dec_ref r27
    dec_ref arrlist
    dec_ref r28
    if is_error(r29) goto L28 (error at item_type:258) else goto L21
L21:
    return r29
L22:
    r30 = self.base
    if is_error(r30) goto L38 (error at item_type:260) else goto L23
L23:
    r31 = self.sub
    if is_error(r31) goto L39 (error at item_type:260) else goto L24
L24:
    r32 = self.node
    if is_error(r32) goto L40 (error at item_type:260) else goto L25
L25:
    r33 = [r30, r31, arrlist, r32]
    r34 = load_address r33
    r35 = ('node',)
    r36 = PyObject_Vectorcall(r11, r34, 3, r35)
    dec_ref r11
    if is_error(r36) goto L41 (error at item_type:260) else goto L26
L26:
    dec_ref r30
    dec_ref r31
    dec_ref arrlist
    dec_ref r32
    r37 = cast(faster_eth_abi._grammar.BasicType, r36)
    if is_error(r37) goto L28 (error at item_type:260) else goto L27
L27:
    return r37
L28:
    r38 = <error> :: faster_eth_abi._grammar.BasicType
    return r38
L29:
    dec_ref r4
    goto L28
L30:
    dec_ref r11
    goto L28
L31:
    dec_ref r11
    dec_ref r12
    goto L28
L32:
    dec_ref r11
    dec_ref r18
    goto L28
L33:
    dec_ref r18
    goto L15
L34:
    dec_ref r11
    goto L17
L35:
    dec_ref arrlist
    goto L28
L36:
    dec_ref arrlist
    dec_ref r26
    goto L28
L37:
    dec_ref arrlist
    dec_ref r26
    dec_ref r27
    goto L28
L38:
    dec_ref r11
    dec_ref arrlist
    goto L28
L39:
    dec_ref r11
    dec_ref arrlist
    dec_ref r30
    goto L28
L40:
    dec_ref r11
    dec_ref arrlist
    dec_ref r30
    dec_ref r31
    goto L28
L41:
    dec_ref arrlist
    dec_ref r30
    dec_ref r31
    dec_ref r32
    goto L28

def BasicType.item_type__ABIType_glue(__mypyc_self__):
    __mypyc_self__, r0 :: faster_eth_abi._grammar.BasicType
    r1 :: faster_eth_abi._grammar.ABIType
L0:
    r0 = __mypyc_self__.item_type
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._grammar.ABIType
    return r1

def BasicType.item_type__BasicType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.BasicType
    r0 :: str
    r1 :: object
    r2, r3 :: faster_eth_abi._grammar.BasicType
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = cast(faster_eth_abi._grammar.BasicType, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: faster_eth_abi._grammar.BasicType
    return r3

def BasicType.is_dynamic(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: bool
    r1, r2 :: str
    r3 :: bool
    r4 :: str
    r5 :: bool
    r6 :: union[int, tuple, None]
    r7 :: object
    r8 :: bit
    r9 :: bool
L0:
    r0 = self._has_dynamic_arrlist
    if is_error(r0) goto L11 (error at is_dynamic:264) else goto L1
L1:
    if r0 goto L2 else goto L3 :: bool
L2:
    return 1
L3:
    r1 = self.base
    if is_error(r1) goto L11 (error at is_dynamic:267) else goto L4
L4:
    r2 = 'string'
    r3 = CPyStr_Equal(r1, r2)
    if r3 goto L12 else goto L6 :: bool
L5:
    return 1
L6:
    r4 = 'bytes'
    r5 = CPyStr_Equal(r1, r4)
    dec_ref r1
    if r5 goto L7 else goto L10 :: bool
L7:
    r6 = borrow self.sub
    if is_error(r6) goto L11 (error at is_dynamic:271) else goto L8
L8:
    r7 = load_address _Py_NoneStruct
    r8 = r6 == r7
    if r8 goto L9 else goto L10 :: bool
L9:
    return 1
L10:
    return 0
L11:
    r9 = <error> :: bool
    return r9
L12:
    dec_ref r1
    goto L5

def BasicType.is_dynamic__BasicType_glue(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._grammar.BasicType
    r0 :: str
    r1 :: object
    r2, r3 :: bool
L0:
    r0 = 'is_dynamic'
    r1 = CPyObject_GetAttr(__mypyc_self__, r0)
    if is_error(r1) goto L3 else goto L1
L1:
    r2 = unbox(bool, r1)
    dec_ref r1
    if is_error(r2) goto L3 else goto L2
L2:
    return r2
L3:
    r3 = <error> :: bool
    return r3

def BasicType.validate(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: str
    r1 :: union[int, tuple, None]
    r2 :: str
    r3 :: bool
    r4 :: object
    r5 :: bit
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: bool
    r10 :: object
    r11, r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: bit
    r16 :: int
    r17 :: native_int
    r18 :: bit
    r19 :: native_int
    r20, r21 :: bit
    r22 :: bool
    r23 :: bit
    r24 :: str
    r25 :: object
    r26, r27 :: str
    r28, r29 :: bool
    r30 :: bit
    r31 :: str
    r32 :: object
    r33 :: int
    r34 :: native_int
    r35 :: bit
    r36 :: native_int
    r37, r38 :: bit
    r39 :: bool
    r40 :: bit
    r41 :: int
    r42 :: native_int
    r43 :: bit
    r44 :: native_int
    r45, r46 :: bit
    r47 :: bool
    r48 :: bit
    r49 :: str
    r50 :: object
    r51, r52 :: int
    r53 :: bit
    r54 :: str
    r55 :: object
    r56, r57 :: str
    r58, r59 :: bool
    r60 :: bit
    r61 :: str
    r62 :: object
    r63 :: tuple
    r64 :: i32
    r65 :: bit
    r66, r67 :: object
    r68, r69 :: int
    r70 :: native_int
    r71 :: bit
    r72 :: native_int
    r73, r74, r75 :: bit
    r76 :: native_int
    r77 :: bit
    r78 :: native_int
    r79, r80, r81 :: bit
    r82 :: str
    r83 :: object
    r84 :: int
    r85 :: bit
    r86 :: str
    r87 :: object
    r88 :: native_int
    r89 :: bit
    r90 :: native_int
    r91, r92, r93 :: bit
    r94 :: native_int
    r95 :: bit
    r96 :: native_int
    r97, r98, r99 :: bit
    r100, r101, r102, r103 :: str
    r104 :: object
    r105 :: str
    r106 :: bool
    r107 :: bit
    r108 :: str
    r109 :: object
    r110 :: str
    r111 :: bool
    r112 :: object
    r113 :: bit
    r114 :: str
    r115 :: object
    r116 :: None
L0:
    r0 = self.base
    if is_error(r0) goto L80 (error at validate:277) else goto L1
L1:
    r1 = self.sub
    if is_error(r1) goto L81 (error at validate:277) else goto L2
L2:
    r2 = 'string'
    r3 = CPyStr_Equal(r0, r2)
    if r3 goto L82 else goto L5 :: bool
L3:
    r4 = load_address _Py_NoneStruct
    r5 = r1 != r4
    dec_ref r1
    if r5 goto L4 else goto L79 :: bool
L4:
    r6 = 'string type cannot have suffix'
    r7 = self.invalidate(r6)
    if is_error(r7) goto L80 (error at validate:282) else goto L83
L5:
    r8 = 'bytes'
    r9 = CPyStr_Equal(r0, r8)
    if r9 goto L84 else goto L17 :: bool
L6:
    r10 = load_address _Py_NoneStruct
    r11 = r1 == r10
    if r11 goto L9 else goto L7 :: bool
L7:
    r12 = PyLong_Check(r1)
    if r12 goto L9 else goto L8 :: bool
L8:
    r13 = 'bytes type must have either no suffix or a numerical suffix'
    r14 = self.invalidate(r13)
    if is_error(r14) goto L85 (error at validate:287) else goto L86
L9:
    r15 = PyLong_Check(r1)
    if r15 goto L10 else goto L87 :: bool
L10:
    r16 = unbox(int, r1)
    dec_ref r1
    if is_error(r16) goto L80 (error at validate:291) else goto L11
L11:
    r17 = r16 & 1
    r18 = r17 != 0
    if r18 goto L13 else goto L12 :: bool
L12:
    r19 = 64 & 1
    r20 = r19 != 0
    if r20 goto L13 else goto L14 :: bool
L13:
    r21 = CPyTagged_IsLt_(64, r16)
    r22 = r21
    goto L15
L14:
    r23 = r16 > 64 :: signed
    r22 = r23
L15:
    dec_ref r16 :: int
    if r22 goto L16 else goto L79 :: bool
L16:
    r24 = 'maximum 32 bytes for fixed-length bytes'
    r25 = self.invalidate(r24)
    if is_error(r25) goto L80 (error at validate:292) else goto L88
L17:
    r26 = 'int'
    r27 = 'uint'
    r28 = CPyStr_Equal(r0, r26)
    if r28 goto L20 else goto L18 :: bool
L18:
    r29 = CPyStr_Equal(r0, r27)
    if r29 goto L20 else goto L19 :: bool
L19:
    if 0 goto L89 else goto L40 :: bool
L20:
    if 1 goto L89 else goto L40 :: bool
L21:
    r30 = PyLong_Check(r1)
    if r30 goto L23 else goto L22 :: bool
L22:
    r31 = 'integer type must have numerical suffix'
    r32 = self.invalidate(r31)
    if is_error(r32) goto L85 (error at validate:297) else goto L90
L23:
    r33 = unbox(int, r1)
    if is_error(r33) goto L85 (error at validate:299) else goto L24
L24:
    r34 = r33 & 1
    r35 = r34 != 0
    if r35 goto L26 else goto L25 :: bool
L25:
    r36 = 16 & 1
    r37 = r36 != 0
    if r37 goto L26 else goto L27 :: bool
L26:
    r38 = CPyTagged_IsLt_(r33, 16)
    r39 = r38
    goto L28
L27:
    r40 = r33 < 16 :: signed
    r39 = r40
L28:
    dec_ref r33 :: int
    if r39 goto L35 else goto L29 :: bool
L29:
    r41 = unbox(int, r1)
    if is_error(r41) goto L85 (error at validate:299) else goto L30
L30:
    r42 = r41 & 1
    r43 = r42 != 0
    if r43 goto L32 else goto L31 :: bool
L31:
    r44 = 512 & 1
    r45 = r44 != 0
    if r45 goto L32 else goto L33 :: bool
L32:
    r46 = CPyTagged_IsLt_(512, r41)
    r47 = r46
    goto L34
L33:
    r48 = r41 > 512 :: signed
    r47 = r48
L34:
    dec_ref r41 :: int
    if r47 goto L35 else goto L36 :: bool
L35:
    r49 = 'integer size out of bounds (max 256 bits)'
    r50 = self.invalidate(r49)
    if is_error(r50) goto L85 (error at validate:300) else goto L91
L36:
    r51 = unbox(int, r1)
    dec_ref r1
    if is_error(r51) goto L80 (error at validate:302) else goto L37
L37:
    r52 = CPyTagged_Remainder(r51, 16)
    dec_ref r51 :: int
    if is_error(r52) goto L80 (error at validate:302) else goto L38
L38:
    r53 = r52 != 0
    dec_ref r52 :: int
    if r53 goto L39 else goto L79 :: bool
L39:
    r54 = 'integer size must be multiple of 8'
    r55 = self.invalidate(r54)
    if is_error(r55) goto L80 (error at validate:303) else goto L92
L40:
    r56 = 'fixed'
    r57 = 'ufixed'
    r58 = CPyStr_Equal(r0, r56)
    if r58 goto L43 else goto L41 :: bool
L41:
    r59 = CPyStr_Equal(r0, r57)
    if r59 goto L43 else goto L42 :: bool
L42:
    if 0 goto L93 else goto L73 :: bool
L43:
    if 1 goto L93 else goto L73 :: bool
L44:
    r60 = PyTuple_Check(r1)
    if r60 goto L46 else goto L45 :: bool
L45:
    r61 = 'fixed type must have suffix of form <bits>x<exponent>, e.g. 128x19'
    r62 = self.invalidate(r61)
    if is_error(r62) goto L85 (error at validate:308) else goto L94
L46:
    r63 = cast(tuple, r1)
    if is_error(r63) goto L80 (error at validate:313) else goto L47
L47:
    r64 = CPySequence_CheckUnpackCount(r63, 2)
    r65 = r64 >= 0 :: signed
    if not r65 goto L95 (error at validate:313) else goto L48 :: bool
L48:
    r66 = CPySequenceTuple_GetItemUnsafe(r63, 0)
    r67 = CPySequenceTuple_GetItemUnsafe(r63, 1)
    dec_ref r63
    r68 = unbox(int, r66)
    dec_ref r66
    if is_error(r68) goto L96 (error at validate:313) else goto L49
L49:
    r69 = unbox(int, r67)
    dec_ref r67
    if is_error(r69) goto L97 (error at validate:313) else goto L50
L50:
    r70 = r68 & 1
    r71 = r70 != 0
    if r71 goto L52 else goto L51 :: bool
L51:
    r72 = 16 & 1
    r73 = r72 != 0
    if r73 goto L52 else goto L53 :: bool
L52:
    r74 = CPyTagged_IsLt_(r68, 16)
    if r74 goto L58 else goto L54 :: bool
L53:
    r75 = r68 < 16 :: signed
    if r75 goto L58 else goto L54 :: bool
L54:
    r76 = r68 & 1
    r77 = r76 != 0
    if r77 goto L56 else goto L55 :: bool
L55:
    r78 = 512 & 1
    r79 = r78 != 0
    if r79 goto L56 else goto L57 :: bool
L56:
    r80 = CPyTagged_IsLt_(512, r68)
    if r80 goto L58 else goto L59 :: bool
L57:
    r81 = r68 > 512 :: signed
    if r81 goto L58 else goto L59 :: bool
L58:
    r82 = 'fixed size out of bounds (max 256 bits)'
    r83 = self.invalidate(r82)
    if is_error(r83) goto L98 (error at validate:316) else goto L99
L59:
    r84 = CPyTagged_Remainder(r68, 16)
    dec_ref r68 :: int
    if is_error(r84) goto L100 (error at validate:318) else goto L60
L60:
    r85 = r84 != 0
    dec_ref r84 :: int
    if r85 goto L61 else goto L62 :: bool
L61:
    r86 = 'fixed size must be multiple of 8'
    r87 = self.invalidate(r86)
    if is_error(r87) goto L100 (error at validate:319) else goto L101
L62:
    r88 = r69 & 1
    r89 = r88 != 0
    if r89 goto L64 else goto L63 :: bool
L63:
    r90 = 2 & 1
    r91 = r90 != 0
    if r91 goto L64 else goto L65 :: bool
L64:
    r92 = CPyTagged_IsLt_(r69, 2)
    if r92 goto L70 else goto L66 :: bool
L65:
    r93 = r69 < 2 :: signed
    if r93 goto L70 else goto L66 :: bool
L66:
    r94 = r69 & 1
    r95 = r94 != 0
    if r95 goto L68 else goto L67 :: bool
L67:
    r96 = 160 & 1
    r97 = r96 != 0
    if r97 goto L68 else goto L69 :: bool
L68:
    r98 = CPyTagged_IsLt_(160, r69)
    if r98 goto L70 else goto L102 :: bool
L69:
    r99 = r69 > 160 :: signed
    if r99 goto L70 else goto L102 :: bool
L70:
    r100 = 'fixed exponent size out of bounds, '
    r101 = CPyTagged_Str(r69)
    dec_ref r69 :: int
    if is_error(r101) goto L80 (error at validate:323) else goto L71
L71:
    r102 = ' must be in 1-80'
    r103 = CPyStr_Build(3, r100, r101, r102)
    dec_ref r101
    if is_error(r103) goto L80 (error at validate:323) else goto L72
L72:
    r104 = self.invalidate(r103)
    dec_ref r103
    if is_error(r104) goto L80 (error at validate:322) else goto L103
L73:
    r105 = 'hash'
    r106 = CPyStr_Equal(r0, r105)
    if r106 goto L104 else goto L76 :: bool
L74:
    r107 = PyLong_Check(r1)
    dec_ref r1
    if r107 goto L79 else goto L75 :: bool
L75:
    r108 = 'hash type must have numerical suffix'
    r109 = self.invalidate(r108)
    if is_error(r109) goto L80 (error at validate:329) else goto L105
L76:
    r110 = 'address'
    r111 = CPyStr_Equal(r0, r110)
    dec_ref r0
    if r111 goto L77 else goto L87 :: bool
L77:
    r112 = load_address _Py_NoneStruct
    r113 = r1 != r112
    dec_ref r1
    if r113 goto L78 else goto L79 :: bool
L78:
    r114 = 'address cannot have suffix'
    r115 = self.invalidate(r114)
    if is_error(r115) goto L80 (error at validate:334) else goto L106
L79:
    return 1
L80:
    r116 = <error> :: None
    return r116
L81:
    dec_ref r0
    goto L80
L82:
    dec_ref r0
    goto L3
L83:
    dec_ref r7
    goto L79
L84:
    dec_ref r0
    goto L6
L85:
    dec_ref r1
    goto L80
L86:
    dec_ref r14
    goto L9
L87:
    dec_ref r1
    goto L79
L88:
    dec_ref r25
    goto L79
L89:
    dec_ref r0
    goto L21
L90:
    dec_ref r32
    goto L23
L91:
    dec_ref r50
    goto L36
L92:
    dec_ref r55
    goto L79
L93:
    dec_ref r0
    goto L44
L94:
    dec_ref r62
    goto L46
L95:
    dec_ref r63
    goto L80
L96:
    dec_ref r67
    goto L80
L97:
    dec_ref r68 :: int
    goto L80
L98:
    dec_ref r68 :: int
    dec_ref r69 :: int
    goto L80
L99:
    dec_ref r83
    goto L59
L100:
    dec_ref r69 :: int
    goto L80
L101:
    dec_ref r87
    goto L62
L102:
    dec_ref r69 :: int
    goto L79
L103:
    dec_ref r104
    goto L79
L104:
    dec_ref r0
    goto L74
L105:
    dec_ref r109
    goto L79
L106:
    dec_ref r115
    goto L79

def BasicType.validate__BasicType_glue(self):
    self :: faster_eth_abi._grammar.BasicType
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: None
L0:
    r0 = 'validate'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = unbox(None, r3)
    dec_ref r3
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: None
    return r5

def normalize(type_str):
    type_str :: str
    r0 :: object
    r1 :: bool
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: str
L0:
    r0 = faster_eth_abi._grammar.TYPE_ALIAS_RE :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "TYPE_ALIAS_RE" was not set')
    if not r1 goto L7 (error at normalize:345) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = faster_eth_abi._grammar.globals :: static
    r3 = '__normalize'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L7 (error at normalize:345) else goto L4
L4:
    r5 = 'sub'
    r6 = [r0, r4, type_str]
    r7 = load_address r6
    r8 = PyObject_VectorcallMethod(r5, r7, 9223372036854775811, 0)
    if is_error(r8) goto L8 (error at normalize:345) else goto L5
L5:
    dec_ref r4
    r9 = cast(str, r8)
    if is_error(r9) goto L7 (error at normalize:345) else goto L6
L6:
    return r9
L7:
    r10 = <error> :: str
    return r10
L8:
    dec_ref r4
    goto L7

def __normalize(match):
    match :: object
    r0 :: dict
    r1 :: bool
    r2 :: str
    r3 :: object
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10 :: str
L0:
    r0 = faster_eth_abi._grammar.TYPE_ALIASES :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "TYPE_ALIASES" was not set')
    if not r1 goto L8 (error at __normalize:349) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'group'
    r3 = object 0
    r4 = [match, r3]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775810, 0)
    if is_error(r6) goto L8 (error at __normalize:349) else goto L4
L4:
    r7 = cast(str, r6)
    if is_error(r7) goto L8 (error at __normalize:349) else goto L5
L5:
    r8 = CPyDict_GetItem(r0, r7)
    dec_ref r7
    if is_error(r8) goto L8 (error at __normalize:349) else goto L6
L6:
    r9 = cast(str, r8)
    if is_error(r9) goto L8 (error at __normalize:349) else goto L7
L7:
    return r9
L8:
    r10 = <error> :: str
    return r10

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34, r35 :: object
    r36 :: str
    r37 :: dict
    r38 :: object
    r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50 :: str
    r51, r52 :: dict
    r53 :: str
    r54 :: i32
    r55 :: bit
    r56, r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: bool
    r63, r64 :: object
    r65 :: str
    r66 :: object
    r67 :: object[2]
    r68 :: object_ptr
    r69 :: object
    r70, r71, r72 :: str
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78 :: object
    r79 :: dict
    r80 :: str
    r81 :: i32
    r82 :: bit
    r83 :: str
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: object
    r88 :: object[2]
    r89 :: object_ptr
    r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: str
    r96 :: dict
    r97 :: str
    r98, r99, r100 :: object
    r101 :: tuple[object, object]
    r102, r103 :: object
    r104 :: dict
    r105 :: str
    r106 :: object
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: dict
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: tuple[object, object]
    r124, r125 :: object
    r126 :: dict
    r127 :: str
    r128 :: i32
    r129 :: bit
    r130 :: object
    r131 :: str
    r132, r133 :: object
    r134 :: bool
    r135, r136, r137 :: str
    r138 :: tuple
    r139 :: i32
    r140 :: bit
    r141 :: dict
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: str
    r146 :: object
    r147 :: dict
    r148 :: str
    r149 :: object
    r150 :: object[2]
    r151 :: object_ptr
    r152, r153 :: object
    r154 :: dict
    r155 :: str
    r156 :: i32
    r157 :: bit
    r158 :: object
    r159 :: tuple
    r160 :: str
    r161, r162 :: object
    r163 :: bool
    r164, r165, r166, r167 :: str
    r168 :: tuple
    r169 :: i32
    r170 :: bit
    r171 :: dict
    r172 :: str
    r173 :: i32
    r174 :: bit
    r175 :: object
    r176 :: tuple
    r177 :: str
    r178, r179 :: object
    r180 :: bool
    r181, r182, r183, r184, r185 :: str
    r186 :: tuple
    r187 :: i32
    r188 :: bit
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L58 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address re :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('re', 're', 're'),)
    r11 = faster_eth_abi._grammar.globals :: static
    r12 = 'faster_eth_abi/_grammar.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L58 else goto L4 :: bool
L4:
    r15 = ('Any', 'Final', 'NewType', 'NoReturn', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union', 'final')
    r16 = 'typing'
    r17 = faster_eth_abi._grammar.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L58 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('TypeStr',)
    r20 = 'eth_typing.abi'
    r21 = faster_eth_abi._grammar.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L58 (error at <module>:15) else goto L6
L6:
    eth_typing.abi = r22 :: module
    dec_ref r22
    r23 = ('mypyc_attr',)
    r24 = 'mypy_extensions'
    r25 = faster_eth_abi._grammar.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L58 (error at <module>:18) else goto L7
L7:
    mypy_extensions = r26 :: module
    dec_ref r26
    r27 = ('Node',)
    r28 = 'parsimonious.nodes'
    r29 = faster_eth_abi._grammar.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L58 (error at <module>:21) else goto L8
L8:
    parsimonious.nodes = r30 :: module
    dec_ref r30
    r31 = ('Self',)
    r32 = 'typing_extensions'
    r33 = faster_eth_abi._grammar.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L58 (error at <module>:24) else goto L9
L9:
    typing_extensions = r34 :: module
    dec_ref r34
    r35 = ('ABITypeError',)
    r36 = 'faster_eth_abi.exceptions'
    r37 = faster_eth_abi._grammar.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L58 (error at <module>:28) else goto L10
L10:
    faster_eth_abi.exceptions = r38 :: module
    dec_ref r38
    r39 = 'int'
    r40 = 'int256'
    r41 = 'uint'
    r42 = 'uint256'
    r43 = 'fixed'
    r44 = 'fixed128x18'
    r45 = 'ufixed'
    r46 = 'ufixed128x18'
    r47 = 'function'
    r48 = 'bytes24'
    r49 = 'byte'
    r50 = 'bytes1'
    r51 = CPyDict_Build(6, r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50)
    if is_error(r51) goto L58 (error at <module>:33) else goto L11
L11:
    faster_eth_abi._grammar.TYPE_ALIASES = r51 :: static
    r52 = faster_eth_abi._grammar.globals :: static
    r53 = 'TYPE_ALIASES'
    r54 = CPyDict_SetItem(r52, r53, r51)
    dec_ref r51
    r55 = r54 >= 0 :: signed
    if not r55 goto L58 (error at <module>:33) else goto L12 :: bool
L12:
    r56 = '\\b('
    r57 = '|'
    r58 = re :: module
    r59 = 'escape'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L58 (error at <module>:43) else goto L13
L13:
    r61 = faster_eth_abi._grammar.TYPE_ALIASES :: static
    if is_error(r61) goto L59 else goto L16
L14:
    r62 = raise NameError('value for final name "TYPE_ALIASES" was not set')
    if not r62 goto L58 (error at <module>:43) else goto L15 :: bool
L15:
    unreachable
L16:
    r63 = CPyDict_KeysView(r61)
    if is_error(r63) goto L60 (error at <module>:43) else goto L17
L17:
    r64 = builtins :: module
    r65 = 'map'
    r66 = CPyObject_GetAttr(r64, r65)
    if is_error(r66) goto L61 (error at <module>:43) else goto L18
L18:
    r67 = [r60, r63]
    r68 = load_address r67
    r69 = PyObject_Vectorcall(r66, r68, 2, 0)
    dec_ref r66
    if is_error(r69) goto L61 (error at <module>:43) else goto L19
L19:
    dec_ref r60
    dec_ref r63
    r70 = PyUnicode_Join(r57, r69)
    dec_ref r69
    if is_error(r70) goto L58 (error at <module>:43) else goto L20
L20:
    r71 = ')\\b'
    r72 = CPyStr_Build(3, r56, r70, r71)
    dec_ref r70
    if is_error(r72) goto L58 (error at <module>:43) else goto L21
L21:
    r73 = re :: module
    r74 = 'compile'
    r75 = CPyObject_GetAttr(r73, r74)
    if is_error(r75) goto L62 (error at <module>:42) else goto L22
L22:
    r76 = [r72]
    r77 = load_address r76
    r78 = PyObject_Vectorcall(r75, r77, 1, 0)
    dec_ref r75
    if is_error(r78) goto L62 (error at <module>:42) else goto L23
L23:
    dec_ref r72
    faster_eth_abi._grammar.TYPE_ALIAS_RE = r78 :: static
    r79 = faster_eth_abi._grammar.globals :: static
    r80 = 'TYPE_ALIAS_RE'
    r81 = CPyDict_SetItem(r79, r80, r78)
    dec_ref r78
    r82 = r81 >= 0 :: signed
    if not r82 goto L58 (error at <module>:42) else goto L24 :: bool
L24:
    r83 = 'IntSubtype'
    r84 = load_address PyLong_Type
    r85 = faster_eth_abi._grammar.globals :: static
    r86 = 'NewType'
    r87 = CPyDict_GetItem(r85, r86)
    if is_error(r87) goto L58 (error at <module>:47) else goto L25
L25:
    r88 = [r83, r84]
    r89 = load_address r88
    r90 = PyObject_Vectorcall(r87, r89, 2, 0)
    dec_ref r87
    if is_error(r90) goto L58 (error at <module>:47) else goto L26
L26:
    r91 = faster_eth_abi._grammar.globals :: static
    r92 = 'IntSubtype'
    r93 = CPyDict_SetItem(r91, r92, r90)
    dec_ref r90
    r94 = r93 >= 0 :: signed
    if not r94 goto L58 (error at <module>:47) else goto L27 :: bool
L27:
    r95 = 'FixedSubtype'
    r96 = faster_eth_abi._grammar.globals :: static
    r97 = 'Tuple'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L58 (error at <module>:48) else goto L28
L28:
    r99 = load_address PyLong_Type
    r100 = load_address PyLong_Type
    inc_ref r99
    inc_ref r100
    r101 = (r99, r100)
    r102 = box(tuple[object, object], r101)
    r103 = PyObject_GetItem(r98, r102)
    dec_ref r98
    dec_ref r102
    if is_error(r103) goto L58 (error at <module>:48) else goto L29
L29:
    r104 = faster_eth_abi._grammar.globals :: static
    r105 = 'NewType'
    r106 = CPyDict_GetItem(r104, r105)
    if is_error(r106) goto L63 (error at <module>:48) else goto L30
L30:
    r107 = [r95, r103]
    r108 = load_address r107
    r109 = PyObject_Vectorcall(r106, r108, 2, 0)
    dec_ref r106
    if is_error(r109) goto L63 (error at <module>:48) else goto L31
L31:
    dec_ref r103
    r110 = faster_eth_abi._grammar.globals :: static
    r111 = 'FixedSubtype'
    r112 = CPyDict_SetItem(r110, r111, r109)
    dec_ref r109
    r113 = r112 >= 0 :: signed
    if not r113 goto L58 (error at <module>:48) else goto L32 :: bool
L32:
    r114 = faster_eth_abi._grammar.globals :: static
    r115 = 'Union'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L58 (error at <module>:49) else goto L33
L33:
    r117 = faster_eth_abi._grammar.globals :: static
    r118 = 'IntSubtype'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L64 (error at <module>:49) else goto L34
L34:
    r120 = faster_eth_abi._grammar.globals :: static
    r121 = 'FixedSubtype'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L65 (error at <module>:49) else goto L35
L35:
    r123 = (r119, r122)
    r124 = box(tuple[object, object], r123)
    r125 = PyObject_GetItem(r116, r124)
    dec_ref r116
    dec_ref r124
    if is_error(r125) goto L58 (error at <module>:49) else goto L36
L36:
    r126 = faster_eth_abi._grammar.globals :: static
    r127 = 'Subtype'
    r128 = CPyDict_SetItem(r126, r127, r125)
    dec_ref r125
    r129 = r128 >= 0 :: signed
    if not r129 goto L58 (error at <module>:49) else goto L37 :: bool
L37:
    r130 = <error> :: object
    r131 = 'faster_eth_abi._grammar'
    r132 = faster_eth_abi._grammar.ABIType_template :: type
    r133 = CPyType_FromTemplate(r132, r130, r131)
    if is_error(r133) goto L58 (error at <module>:53) else goto L38
L38:
    r134 = ABIType_trait_vtable_setup()
    if is_error(r134) goto L66 (error at <module>:-1) else goto L39
L39:
    r135 = '__mypyc_attrs__'
    r136 = 'arrlist'
    r137 = 'node'
    r138 = PyTuple_Pack(2, r136, r137)
    if is_error(r138) goto L66 (error at <module>:53) else goto L40
L40:
    r139 = PyObject_SetAttr(r133, r135, r138)
    dec_ref r138
    r140 = r139 >= 0 :: signed
    if not r140 goto L66 (error at <module>:53) else goto L41 :: bool
L41:
    faster_eth_abi._grammar.ABIType = r133 :: type
    r141 = faster_eth_abi._grammar.globals :: static
    r142 = 'ABIType'
    r143 = PyDict_SetItem(r141, r142, r133)
    dec_ref r133
    r144 = r143 >= 0 :: signed
    if not r144 goto L58 (error at <module>:53) else goto L42 :: bool
L42:
    r145 = 'TComp'
    r146 = faster_eth_abi._grammar.ABIType :: type
    r147 = faster_eth_abi._grammar.globals :: static
    r148 = 'TypeVar'
    r149 = CPyDict_GetItem(r147, r148)
    if is_error(r149) goto L58 (error at <module>:142) else goto L43
L43:
    r150 = [r145, r146]
    r151 = load_address r150
    r152 = ('bound',)
    r153 = PyObject_Vectorcall(r149, r151, 1, r152)
    dec_ref r149
    if is_error(r153) goto L58 (error at <module>:142) else goto L44
L44:
    r154 = faster_eth_abi._grammar.globals :: static
    r155 = 'TComp'
    r156 = CPyDict_SetItem(r154, r155, r153)
    dec_ref r153
    r157 = r156 >= 0 :: signed
    if not r157 goto L58 (error at <module>:142) else goto L45 :: bool
L45:
    r158 = faster_eth_abi._grammar.ABIType :: type
    r159 = PyTuple_Pack(1, r158)
    if is_error(r159) goto L58 (error at <module>:146) else goto L46
L46:
    r160 = 'faster_eth_abi._grammar'
    r161 = faster_eth_abi._grammar.TupleType_template :: type
    r162 = CPyType_FromTemplate(r161, r159, r160)
    dec_ref r159
    if is_error(r162) goto L58 (error at <module>:146) else goto L47
L47:
    r163 = TupleType_trait_vtable_setup()
    if is_error(r163) goto L67 (error at <module>:-1) else goto L48
L48:
    r164 = '__mypyc_attrs__'
    r165 = 'components'
    r166 = 'arrlist'
    r167 = 'node'
    r168 = PyTuple_Pack(3, r165, r166, r167)
    if is_error(r168) goto L67 (error at <module>:146) else goto L49
L49:
    r169 = PyObject_SetAttr(r162, r164, r168)
    dec_ref r168
    r170 = r169 >= 0 :: signed
    if not r170 goto L67 (error at <module>:146) else goto L50 :: bool
L50:
    faster_eth_abi._grammar.TupleType = r162 :: type
    r171 = faster_eth_abi._grammar.globals :: static
    r172 = 'TupleType'
    r173 = PyDict_SetItem(r171, r172, r162)
    dec_ref r162
    r174 = r173 >= 0 :: signed
    if not r174 goto L58 (error at <module>:146) else goto L51 :: bool
L51:
    r175 = faster_eth_abi._grammar.ABIType :: type
    r176 = PyTuple_Pack(1, r175)
    if is_error(r176) goto L58 (error at <module>:205) else goto L52
L52:
    r177 = 'faster_eth_abi._grammar'
    r178 = faster_eth_abi._grammar.BasicType_template :: type
    r179 = CPyType_FromTemplate(r178, r176, r177)
    dec_ref r176
    if is_error(r179) goto L58 (error at <module>:205) else goto L53
L53:
    r180 = BasicType_trait_vtable_setup()
    if is_error(r180) goto L68 (error at <module>:-1) else goto L54
L54:
    r181 = '__mypyc_attrs__'
    r182 = 'base'
    r183 = 'sub'
    r184 = 'arrlist'
    r185 = 'node'
    r186 = PyTuple_Pack(4, r182, r183, r184, r185)
    if is_error(r186) goto L68 (error at <module>:205) else goto L55
L55:
    r187 = PyObject_SetAttr(r179, r181, r186)
    dec_ref r186
    r188 = r187 >= 0 :: signed
    if not r188 goto L68 (error at <module>:205) else goto L56 :: bool
L56:
    faster_eth_abi._grammar.BasicType = r179 :: type
    r189 = faster_eth_abi._grammar.globals :: static
    r190 = 'BasicType'
    r191 = PyDict_SetItem(r189, r190, r179)
    dec_ref r179
    r192 = r191 >= 0 :: signed
    if not r192 goto L58 (error at <module>:205) else goto L57 :: bool
L57:
    return 1
L58:
    r193 = <error> :: None
    return r193
L59:
    dec_ref r60
    goto L14
L60:
    dec_ref r60
    goto L58
L61:
    dec_ref r60
    dec_ref r63
    goto L58
L62:
    dec_ref r72
    goto L58
L63:
    dec_ref r103
    goto L58
L64:
    dec_ref r116
    goto L58
L65:
    dec_ref r116
    dec_ref r119
    goto L58
L66:
    dec_ref r133
    goto L58
L67:
    dec_ref r162
    goto L58
L68:
    dec_ref r179
    goto L58

def decode_uint_256(stream):
    stream :: object
    r0 :: str
    r1 :: object
    r2 :: object[2]
    r3 :: object_ptr
    r4 :: object
    r5 :: bytes
    r6 :: ptr
    r7 :: native_int
    r8 :: short_int
    r9 :: bit
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: int
    r17 :: str
    r18 :: ptr
    r19 :: native_int
    r20 :: short_int
    r21, r22, r23 :: str
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: int
L0:
    r0 = 'read'
    r1 = object 32
    r2 = [stream, r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775810, 0)
    if is_error(r4) goto L13 (error at decode_uint_256:39) else goto L1
L1:
    r5 = cast(bytes, r4)
    if is_error(r5) goto L13 (error at decode_uint_256:39) else goto L2
L2:
    inc_ref r5
    r6 = get_element_ptr r5 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    dec_ref r5
    r8 = r7 << 1
    r9 = r8 == 64
    if r9 goto L3 else goto L7 :: bool
L3:
    r10 = faster_eth_abi._decoding.globals :: static
    r11 = 'big_endian_to_int'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L14 (error at decode_uint_256:40) else goto L4
L4:
    r13 = [r5]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L14 (error at decode_uint_256:40) else goto L5
L5:
    dec_ref r5
    r16 = unbox(int, r15)
    dec_ref r15
    if is_error(r16) goto L13 (error at decode_uint_256:40) else goto L6
L6:
    return r16
L7:
    r17 = 'Tried to read 32 bytes, only got '
    r18 = get_element_ptr r5 ob_size :: PyVarObject
    r19 = load_mem r18 :: native_int*
    dec_ref r5
    r20 = r19 << 1
    r21 = CPyTagged_Str(r20)
    if is_error(r21) goto L13 (error at decode_uint_256:41) else goto L8
L8:
    r22 = ' bytes.'
    r23 = CPyStr_Build(3, r17, r21, r22)
    dec_ref r21
    if is_error(r23) goto L13 (error at decode_uint_256:41) else goto L9
L9:
    r24 = faster_eth_abi._decoding.globals :: static
    r25 = 'InsufficientDataBytes'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L15 (error at decode_uint_256:41) else goto L10
L10:
    r27 = [r23]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L15 (error at decode_uint_256:41) else goto L11
L11:
    dec_ref r23
    CPy_Raise(r29)
    dec_ref r29
    if not 0 goto L13 (error at decode_uint_256:41) else goto L12 :: bool
L12:
    unreachable
L13:
    r30 = <error> :: int
    return r30
L14:
    dec_ref r5
    goto L13
L15:
    dec_ref r23
    goto L13

def get_value_byte_size(decoder):
    decoder :: object
    r0 :: str
    r1 :: object
    r2, r3, r4 :: int
L0:
    r0 = 'value_bit_size'
    r1 = CPyObject_GetAttr(decoder, r0)
    if is_error(r1) goto L4 (error at get_value_byte_size:45) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at get_value_byte_size:45) else goto L2
L2:
    r3 = CPyTagged_Rshift(r2, 6)
    dec_ref r2 :: int
    if is_error(r3) goto L4 (error at get_value_byte_size:-1) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: int
    return r4

def decode_head_tail(self, stream):
    self, stream :: object
    r0 :: int
    r1 :: str
    r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7 :: object
    tail_decoder :: union[object, None]
    r8 :: object
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    value :: union[object, tuple]
    r20 :: str
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = decode_uint_256(stream)
    if is_error(r0) goto L11 (error at decode_head_tail:51) else goto L1
L1:
    r1 = 'push_frame'
    r2 = box(int, r0)
    r3 = [stream, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775810, 0)
    if is_error(r5) goto L12 (error at decode_head_tail:53) else goto L13
L2:
    dec_ref r2
    r6 = 'tail_decoder'
    r7 = CPyObject_GetAttr(self, r6)
    if is_error(r7) goto L11 (error at decode_head_tail:56) else goto L3
L3:
    tail_decoder = r7
    r8 = load_address _Py_NoneStruct
    r9 = tail_decoder == r8
    if r9 goto L14 else goto L8 :: bool
L4:
    r10 = '`tail_decoder` is None'
    r11 = builtins :: module
    r12 = 'AssertionError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L11 (error at decode_head_tail:58) else goto L5
L5:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L11 (error at decode_head_tail:58) else goto L6
L6:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L11 (error at decode_head_tail:58) else goto L7 :: bool
L7:
    unreachable
L8:
    r17 = [stream]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(tail_decoder, r18, 1, 0)
    dec_ref tail_decoder
    if is_error(r19) goto L11 (error at decode_head_tail:60) else goto L9
L9:
    value = r19
    r20 = 'pop_frame'
    r21 = [stream]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775809, 0)
    if is_error(r23) goto L15 (error at decode_head_tail:62) else goto L16
L10:
    return value
L11:
    r24 = <error> :: object
    return r24
L12:
    dec_ref r2
    goto L11
L13:
    dec_ref r5
    goto L2
L14:
    dec_ref tail_decoder
    goto L4
L15:
    dec_ref value
    goto L11
L16:
    dec_ref r23
    goto L10

def decode_tuple(self, stream):
    self, stream :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: ptr
    r8 :: native_int
    r9 :: tuple
    r10 :: ptr
    r11, r12 :: native_int
    r13 :: bit
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: native_int
    r19 :: tuple
L0:
    r0 = 'validate_pointers'
    r1 = [self, stream]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L10 (error at decode_tuple:69) else goto L11
L1:
    r4 = 'decoders'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L10 (error at decode_tuple:70) else goto L2
L2:
    r6 = cast(tuple, r5)
    if is_error(r6) goto L10 (error at decode_tuple:70) else goto L3
L3:
    r7 = get_element_ptr r6 ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = PyTuple_New(r8)
    if is_error(r9) goto L12 (error at decode_tuple:70) else goto L4
L4:
    r10 = get_element_ptr r6 ob_size :: PyVarObject
    r11 = load_mem r10 :: native_int*
    r12 = 0
L5:
    r13 = r12 < r11 :: signed
    if r13 goto L6 else goto L13 :: bool
L6:
    r14 = CPySequenceTuple_GetItemUnsafe(r6, r12)
    r15 = [stream]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L14 (error at decode_tuple:70) else goto L7
L7:
    CPySequenceTuple_SetItemUnsafe(r9, r12, r17)
L8:
    r18 = r12 + 1
    r12 = r18
    goto L5
L9:
    return r9
L10:
    r19 = <error> :: tuple
    return r19
L11:
    dec_ref r3
    goto L1
L12:
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L9
L14:
    dec_ref r6
    dec_ref r9
    goto L10

def decode_sized_array(self, stream):
    self, stream :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: int
    r14 :: str
    r15 :: object
    r16 :: object[3]
    r17 :: object_ptr
    r18 :: object
    r19 :: list
    r20 :: int
    r21, _ :: object
    r22 :: native_int
    r23 :: bit
    r24 :: native_int
    r25, r26, r27 :: bit
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: i32
    r32 :: bit
    r33 :: int
    r34 :: object
    r35, r36 :: tuple
L0:
    r0 = 'item_decoder'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L20 (error at decode_sized_array:77) else goto L1
L1:
    r2 = load_address _Py_NoneStruct
    r3 = r1 == r2
    if r3 goto L21 else goto L6 :: bool
L2:
    r4 = '`item_decoder` is None'
    r5 = builtins :: module
    r6 = 'AssertionError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L20 (error at decode_sized_array:79) else goto L3
L3:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L20 (error at decode_sized_array:79) else goto L4
L4:
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L20 (error at decode_sized_array:79) else goto L5 :: bool
L5:
    unreachable
L6:
    r11 = 'array_size'
    r12 = CPyObject_GetAttr(self, r11)
    if is_error(r12) goto L22 (error at decode_sized_array:81) else goto L7
L7:
    r13 = unbox(int, r12)
    dec_ref r12
    if is_error(r13) goto L22 (error at decode_sized_array:81) else goto L8
L8:
    r14 = 'validate_pointers'
    inc_ref r13 :: int
    r15 = box(int, r13)
    r16 = [self, stream, r15]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r14, r17, 9223372036854775811, 0)
    if is_error(r18) goto L23 (error at decode_sized_array:82) else goto L24
L9:
    dec_ref r15
    r19 = PyList_New(0)
    if is_error(r19) goto L25 (error at decode_sized_array:83) else goto L10
L10:
    r20 = 0
    inc_ref r20 :: int
    r21 = box(int, r20)
    _ = r21
    dec_ref _
L11:
    r22 = r20 & 1
    r23 = r22 != 0
    if r23 goto L13 else goto L12 :: bool
L12:
    r24 = r13 & 1
    r25 = r24 != 0
    if r25 goto L13 else goto L14 :: bool
L13:
    r26 = CPyTagged_IsLt_(r20, r13)
    if r26 goto L15 else goto L26 :: bool
L14:
    r27 = r20 < r13 :: signed
    if r27 goto L15 else goto L26 :: bool
L15:
    r28 = [stream]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r1, r29, 1, 0)
    if is_error(r30) goto L27 (error at decode_sized_array:83) else goto L16
L16:
    r31 = PyList_Append(r19, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L27 (error at decode_sized_array:83) else goto L17 :: bool
L17:
    r33 = CPyTagged_Add(r20, 2)
    dec_ref r20 :: int
    inc_ref r33 :: int
    r20 = r33
    r34 = box(int, r33)
    _ = r34
    dec_ref _
    goto L11
L18:
    r35 = PyList_AsTuple(r19)
    dec_ref r19
    if is_error(r35) goto L20 (error at decode_sized_array:83) else goto L19
L19:
    return r35
L20:
    r36 = <error> :: tuple
    return r36
L21:
    dec_ref r1
    goto L2
L22:
    dec_ref r1
    goto L20
L23:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r15
    goto L20
L24:
    dec_ref r18
    goto L9
L25:
    dec_ref r1
    dec_ref r13 :: int
    goto L20
L26:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r20 :: int
    goto L18
L27:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r19
    dec_ref r20 :: int
    goto L20

def decode_dynamic_array(self, stream):
    self, stream :: object
    r0 :: int
    r1 :: str
    r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: list
    r25 :: int
    r26, _ :: object
    r27 :: native_int
    r28 :: bit
    r29 :: native_int
    r30, r31, r32 :: bit
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: i32
    r37 :: bit
    r38 :: int
    r39 :: object
    r40, r41 :: tuple
    r42, r43 :: tuple[object, object, object]
    r44 :: tuple
    r45 :: tuple[object, object, object]
    r46 :: str
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: bit
    r51 :: tuple
L0:
    r0 = decode_uint_256(stream)
    if is_error(r0) goto L35 (error at decode_dynamic_array:90) else goto L1
L1:
    r1 = 'push_frame'
    r2 = object 32
    r3 = [stream, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775810, 0)
    if is_error(r5) goto L36 (error at decode_dynamic_array:91) else goto L37
L2:
    r6 = 'item_decoder'
    r7 = CPyObject_GetAttr(self, r6)
    if is_error(r7) goto L36 (error at decode_dynamic_array:92) else goto L3
L3:
    r8 = load_address _Py_NoneStruct
    r9 = r7 == r8
    dec_ref r7
    if r9 goto L38 else goto L8 :: bool
L4:
    r10 = '`item_decoder` is None'
    r11 = builtins :: module
    r12 = 'AssertionError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L35 (error at decode_dynamic_array:93) else goto L5
L5:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L35 (error at decode_dynamic_array:93) else goto L6
L6:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L35 (error at decode_dynamic_array:93) else goto L7 :: bool
L7:
    unreachable
L8:
    r17 = 'validate_pointers'
    inc_ref r0 :: int
    r18 = box(int, r0)
    r19 = [self, stream, r18]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r17, r20, 9223372036854775811, 0)
    if is_error(r21) goto L39 (error at decode_dynamic_array:95) else goto L40
L9:
    dec_ref r18
    r22 = 'item_decoder'
    r23 = CPyObject_GetAttr(self, r22)
    if is_error(r23) goto L36 (error at decode_dynamic_array:96) else goto L10
L10:
L11:
    r24 = PyList_New(0)
    if is_error(r24) goto L41 (error at decode_dynamic_array:98) else goto L12
L12:
    r25 = 0
    inc_ref r25 :: int
    r26 = box(int, r25)
    _ = r26
    dec_ref _
L13:
    r27 = r25 & 1
    r28 = r27 != 0
    if r28 goto L15 else goto L14 :: bool
L14:
    r29 = r0 & 1
    r30 = r29 != 0
    if r30 goto L15 else goto L16 :: bool
L15:
    r31 = CPyTagged_IsLt_(r25, r0)
    if r31 goto L17 else goto L42 :: bool
L16:
    r32 = r25 < r0 :: signed
    if r32 goto L17 else goto L42 :: bool
L17:
    r33 = [stream]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r23, r34, 1, 0)
    if is_error(r35) goto L43 (error at decode_dynamic_array:98) else goto L18
L18:
    r36 = PyList_Append(r24, r35)
    dec_ref r35
    r37 = r36 >= 0 :: signed
    if not r37 goto L43 (error at decode_dynamic_array:98) else goto L19 :: bool
L19:
    r38 = CPyTagged_Add(r25, 2)
    dec_ref r25 :: int
    inc_ref r38 :: int
    r25 = r38
    r39 = box(int, r38)
    _ = r39
    dec_ref _
    goto L13
L20:
    r40 = PyList_AsTuple(r24)
    dec_ref r24
    if is_error(r40) goto L23 (error at decode_dynamic_array:98) else goto L21
L21:
    r41 = r40
L22:
    r42 = <error> :: tuple[object, object, object]
    r43 = r42
    goto L24
L23:
    r44 = <error> :: tuple
    r41 = r44
    r45 = CPy_CatchError()
    r43 = r45
L24:
    r46 = 'pop_frame'
    r47 = [stream]
    r48 = load_address r47
    r49 = PyObject_VectorcallMethod(r46, r48, 9223372036854775809, 0)
    if is_error(r49) goto L44 (error at decode_dynamic_array:100) else goto L45
L25:
    if is_error(r43) goto L28 else goto L46
L26:
    CPy_Reraise()
    if not 0 goto L30 else goto L47 :: bool
L27:
    unreachable
L28:
    if is_error(r41) goto L34 else goto L29
L29:
    return r41
L30:
    if is_error(r43) goto L32 else goto L31
L31:
    CPy_RestoreExcInfo(r43)
    xdec_ref r43
L32:
    r50 = CPy_KeepPropagating()
    if not r50 goto L35 else goto L33 :: bool
L33:
    unreachable
L34:
    unreachable
L35:
    r51 = <error> :: tuple
    return r51
L36:
    dec_ref r0 :: int
    goto L35
L37:
    dec_ref r5
    goto L2
L38:
    dec_ref r0 :: int
    goto L4
L39:
    dec_ref r0 :: int
    dec_ref r18
    goto L35
L40:
    dec_ref r21
    goto L9
L41:
    dec_ref r0 :: int
    dec_ref r23
    goto L23
L42:
    dec_ref r0 :: int
    dec_ref r23
    dec_ref r25 :: int
    goto L20
L43:
    dec_ref r0 :: int
    dec_ref r23
    dec_ref r24
    dec_ref r25 :: int
    goto L23
L44:
    xdec_ref r41
    goto L30
L45:
    dec_ref r49
    goto L25
L46:
    xdec_ref r41
    goto L26
L47:
    xdec_ref r43
    goto L27

def read_fixed_byte_size_data_from_stream(self, stream):
    self, stream :: object
    r0 :: str
    r1 :: object
    r2 :: int
    r3 :: str
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7 :: object
    r8 :: bytes
    r9 :: ptr
    r10 :: native_int
    r11 :: short_int
    r12 :: bit
    r13, r14, r15 :: str
    r16 :: ptr
    r17 :: native_int
    r18 :: short_int
    r19, r20, r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bytes
L0:
    r0 = 'data_byte_size'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at read_fixed_byte_size_data_from_stream:110) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L13 (error at read_fixed_byte_size_data_from_stream:110) else goto L2
L2:
    r3 = 'read'
    inc_ref r2 :: int
    r4 = box(int, r2)
    r5 = [stream, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r3, r6, 9223372036854775810, 0)
    if is_error(r7) goto L14 (error at read_fixed_byte_size_data_from_stream:111) else goto L3
L3:
    dec_ref r4
    r8 = cast(bytes, r7)
    if is_error(r8) goto L15 (error at read_fixed_byte_size_data_from_stream:111) else goto L4
L4:
    inc_ref r8
    r9 = get_element_ptr r8 ob_size :: PyVarObject
    r10 = load_mem r9 :: native_int*
    dec_ref r8
    r11 = r10 << 1
    r12 = r11 == r2
    if r12 goto L16 else goto L6 :: bool
L5:
    return r8
L6:
    r13 = 'Tried to read '
    r14 = CPyTagged_Str(r2)
    dec_ref r2 :: int
    if is_error(r14) goto L17 (error at read_fixed_byte_size_data_from_stream:114) else goto L7
L7:
    r15 = ' bytes, only got '
    r16 = get_element_ptr r8 ob_size :: PyVarObject
    r17 = load_mem r16 :: native_int*
    dec_ref r8
    r18 = r17 << 1
    r19 = CPyTagged_Str(r18)
    if is_error(r19) goto L18 (error at read_fixed_byte_size_data_from_stream:114) else goto L8
L8:
    r20 = ' bytes.'
    r21 = CPyStr_Build(5, r13, r14, r15, r19, r20)
    dec_ref r14
    dec_ref r19
    if is_error(r21) goto L13 (error at read_fixed_byte_size_data_from_stream:114) else goto L9
L9:
    r22 = faster_eth_abi._decoding.globals :: static
    r23 = 'InsufficientDataBytes'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L19 (error at read_fixed_byte_size_data_from_stream:113) else goto L10
L10:
    r25 = [r21]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L19 (error at read_fixed_byte_size_data_from_stream:113) else goto L11
L11:
    dec_ref r21
    CPy_Raise(r27)
    dec_ref r27
    if not 0 goto L13 (error at read_fixed_byte_size_data_from_stream:113) else goto L12 :: bool
L12:
    unreachable
L13:
    r28 = <error> :: bytes
    return r28
L14:
    dec_ref r2 :: int
    dec_ref r4
    goto L13
L15:
    dec_ref r2 :: int
    goto L13
L16:
    dec_ref r2 :: int
    goto L5
L17:
    dec_ref r8
    goto L13
L18:
    dec_ref r14
    goto L13
L19:
    dec_ref r21
    goto L13

def split_data_and_padding_fixed_byte_size(self, raw_data):
    self :: object
    raw_data :: bytes
    r0 :: int
    r1 :: str
    r2 :: object
    r3, r4 :: int
    r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: bit
    r9 :: bytes
    r10 :: tuple[bytes, bytes]
    r11, padding_bytes, r12, data, r13, r14 :: bytes
    r15, r16 :: tuple[bytes, bytes]
L0:
    r0 = get_value_byte_size(self)
    if is_error(r0) goto L15 (error at split_data_and_padding_fixed_byte_size:122) else goto L1
L1:
    r1 = 'data_byte_size'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L16 (error at split_data_and_padding_fixed_byte_size:123) else goto L2
L2:
    r3 = unbox(int, r2)
    dec_ref r2
    if is_error(r3) goto L16 (error at split_data_and_padding_fixed_byte_size:123) else goto L3
L3:
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    r5 = 'is_big_endian'
    r6 = CPyObject_GetAttr(self, r5)
    if is_error(r6) goto L17 (error at split_data_and_padding_fixed_byte_size:125) else goto L4
L4:
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L17 (error at split_data_and_padding_fixed_byte_size:125) else goto L5
L5:
    if r7 goto L18 else goto L19 :: bool
L6:
    r8 = r4 == 0
    if r8 goto L20 else goto L8 :: bool
L7:
    r9 = b''
    inc_ref raw_data
    inc_ref r9
    r10 = (raw_data, r9)
    return r10
L8:
    r11 = CPyBytes_GetSlice(raw_data, 0, r4)
    if is_error(r11) goto L21 (error at split_data_and_padding_fixed_byte_size:128) else goto L9
L9:
    padding_bytes = r11
    r12 = CPyBytes_GetSlice(raw_data, r4, 9223372036854775806)
    dec_ref r4 :: int
    if is_error(r12) goto L22 (error at split_data_and_padding_fixed_byte_size:129) else goto L10
L10:
    data = r12
    goto L14
L11:
    r13 = CPyBytes_GetSlice(raw_data, 0, r0)
    if is_error(r13) goto L16 (error at split_data_and_padding_fixed_byte_size:131) else goto L12
L12:
    data = r13
    r14 = CPyBytes_GetSlice(raw_data, r0, 9223372036854775806)
    dec_ref r0 :: int
    if is_error(r14) goto L23 (error at split_data_and_padding_fixed_byte_size:132) else goto L13
L13:
    padding_bytes = r14
L14:
    r15 = (data, padding_bytes)
    return r15
L15:
    r16 = <error> :: tuple[bytes, bytes]
    return r16
L16:
    dec_ref r0 :: int
    goto L15
L17:
    dec_ref r0 :: int
    dec_ref r4 :: int
    goto L15
L18:
    dec_ref r0 :: int
    goto L6
L19:
    dec_ref r4 :: int
    goto L11
L20:
    dec_ref r4 :: int
    goto L7
L21:
    dec_ref r4 :: int
    goto L15
L22:
    dec_ref padding_bytes
    goto L15
L23:
    dec_ref data
    goto L15

def validate_padding_bytes_fixed_byte_size(self, value, padding_bytes):
    self, value :: object
    padding_bytes :: bytes
    r0 :: int
    r1 :: str
    r2 :: object
    r3, r4 :: int
    r5 :: bytes
    r6, r7 :: object
    r8 :: bytes
    r9 :: i32
    r10, r11 :: bit
    r12, r13, r14, r15, r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20 :: str
    r21 :: list
    r22, r23, r24 :: ptr
    r25 :: str
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: None
L0:
    r0 = get_value_byte_size(self)
    if is_error(r0) goto L16 (error at validate_padding_bytes_fixed_byte_size:142) else goto L1
L1:
    r1 = 'data_byte_size'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L17 (error at validate_padding_bytes_fixed_byte_size:143) else goto L2
L2:
    r3 = unbox(int, r2)
    dec_ref r2
    if is_error(r3) goto L17 (error at validate_padding_bytes_fixed_byte_size:143) else goto L3
L3:
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    dec_ref r0 :: int
    r5 = b'\x00'
    r6 = box(int, r4)
    r7 = PyNumber_Multiply(r5, r6)
    dec_ref r6
    if is_error(r7) goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L4
L4:
    r8 = cast(bytes, r7)
    if is_error(r8) goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L5
L5:
    r9 = CPyBytes_Compare(padding_bytes, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L6 :: bool
L6:
    r11 = r9 != 1
    if r11 goto L7 else goto L15 :: bool
L7:
    r12 = ''
    r13 = 'Padding bytes were not empty: '
    r14 = '{!r:{}}'
    r15 = ''
    r16 = 'format'
    r17 = [r14, padding_bytes, r15]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r16, r18, 9223372036854775811, 0)
    if is_error(r19) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L8
L8:
    r20 = cast(str, r19)
    if is_error(r20) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L9
L9:
    r21 = PyList_New(2)
    if is_error(r21) goto L18 (error at validate_padding_bytes_fixed_byte_size:146) else goto L10
L10:
    r22 = get_element_ptr r21 ob_item :: PyListObject
    r23 = load_mem r22 :: ptr*
    inc_ref r13
    set_mem r23, r13 :: builtins.object*
    r24 = r23 + 8
    set_mem r24, r20 :: builtins.object*
    r25 = PyUnicode_Join(r12, r21)
    dec_ref r21
    if is_error(r25) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L11
L11:
    r26 = faster_eth_abi._decoding.globals :: static
    r27 = 'NonEmptyPaddingBytes'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L19 (error at validate_padding_bytes_fixed_byte_size:146) else goto L12
L12:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L19 (error at validate_padding_bytes_fixed_byte_size:146) else goto L13
L13:
    dec_ref r25
    CPy_Raise(r31)
    dec_ref r31
    if not 0 goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L14 :: bool
L14:
    unreachable
L15:
    return 1
L16:
    r32 = <error> :: None
    return r32
L17:
    dec_ref r0 :: int
    goto L16
L18:
    dec_ref r20
    goto L16
L19:
    dec_ref r25
    goto L16

def decoder_fn_boolean(data):
    data, r0 :: bytes
    r1 :: i32
    r2, r3 :: bit
    r4 :: bytes
    r5 :: i32
    r6, r7 :: bit
    r8, r9, r10, r11, r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16 :: str
    r17 :: list
    r18, r19, r20 :: ptr
    r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bool
L0:
    r0 = b'\x00'
    r1 = CPyBytes_Compare(data, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at decoder_fn_boolean:151) else goto L1 :: bool
L1:
    r3 = r1 == 1
    if r3 goto L2 else goto L3 :: bool
L2:
    return 0
L3:
    r4 = b'\x01'
    r5 = CPyBytes_Compare(data, r4)
    r6 = r5 >= 0 :: signed
    if not r6 goto L14 (error at decoder_fn_boolean:153) else goto L4 :: bool
L4:
    r7 = r5 == 1
    if r7 goto L5 else goto L6 :: bool
L5:
    return 1
L6:
    r8 = ''
    r9 = 'Boolean must be either 0x0 or 0x1.  Got: '
    r10 = '{!r:{}}'
    r11 = ''
    r12 = 'format'
    r13 = [r10, data, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L14 (error at decoder_fn_boolean:155) else goto L7
L7:
    r16 = cast(str, r15)
    if is_error(r16) goto L14 (error at decoder_fn_boolean:155) else goto L8
L8:
    r17 = PyList_New(2)
    if is_error(r17) goto L15 (error at decoder_fn_boolean:155) else goto L9
L9:
    r18 = get_element_ptr r17 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r9
    set_mem r19, r9 :: builtins.object*
    r20 = r19 + 8
    set_mem r20, r16 :: builtins.object*
    r21 = PyUnicode_Join(r8, r17)
    dec_ref r17
    if is_error(r21) goto L14 (error at decoder_fn_boolean:155) else goto L10
L10:
    r22 = faster_eth_abi._decoding.globals :: static
    r23 = 'NonEmptyPaddingBytes'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L16 (error at decoder_fn_boolean:155) else goto L11
L11:
    r25 = [r21]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L16 (error at decoder_fn_boolean:155) else goto L12
L12:
    dec_ref r21
    CPy_Raise(r27)
    dec_ref r27
    if not 0 goto L14 (error at decoder_fn_boolean:155) else goto L13 :: bool
L13:
    unreachable
L14:
    r28 = <error> :: bool
    return r28
L15:
    dec_ref r16
    goto L14
L16:
    dec_ref r21
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L9 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Tuple')
    r6 = 'typing'
    r7 = faster_eth_abi._decoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L9 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('big_endian_to_int',)
    r10 = 'faster_eth_utils'
    r11 = faster_eth_abi._decoding.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L9 (error at <module>:7) else goto L5
L5:
    faster_eth_utils = r12 :: module
    dec_ref r12
    r13 = ('InsufficientDataBytes', 'NonEmptyPaddingBytes')
    r14 = 'faster_eth_abi.exceptions'
    r15 = faster_eth_abi._decoding.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L9 (error at <module>:11) else goto L6
L6:
    faster_eth_abi.exceptions = r16 :: module
    dec_ref r16
    r17 = ('BytesIO', 'ContextFramesBytesIO')
    r18 = 'faster_eth_abi.io'
    r19 = faster_eth_abi._decoding.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L9 (error at <module>:15) else goto L7
L7:
    faster_eth_abi.io = r20 :: module
    dec_ref r20
    if 0 goto L8 else goto L8 :: bool
L8:
    return 1
L9:
    r21 = <error> :: None
    return r21

def abbr(value, limit):
    value :: object
    limit :: int
    r0, rep :: str
    r1 :: native_int
    r2 :: bit
    r3 :: short_int
    r4 :: native_int
    r5 :: bit
    r6 :: native_int
    r7, r8, r9 :: bit
    r10 :: native_int
    r11 :: bit
    r12 :: native_int
    r13, r14, r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: int
    r24 :: object
    r25, r26, r27, r28 :: str
L0:
    if is_error(limit) goto L1 else goto L22
L1:
    limit = 158
L2:
    r0 = PyObject_Repr(value)
    if is_error(r0) goto L23 (error at abbr:11) else goto L3
L3:
    rep = r0
    r1 = CPyStr_Size_size_t(rep)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at abbr:13) else goto L4 :: bool
L4:
    r3 = r1 << 1
    r4 = r3 & 1
    r5 = r4 != 0
    if r5 goto L6 else goto L5 :: bool
L5:
    r6 = limit & 1
    r7 = r6 != 0
    if r7 goto L6 else goto L7 :: bool
L6:
    r8 = CPyTagged_IsLt_(limit, r3)
    if r8 goto L8 else goto L25 :: bool
L7:
    r9 = r3 > limit :: signed
    if r9 goto L8 else goto L25 :: bool
L8:
    r10 = limit & 1
    r11 = r10 != 0
    if r11 goto L10 else goto L9 :: bool
L9:
    r12 = 6 & 1
    r13 = r12 != 0
    if r13 goto L10 else goto L11 :: bool
L10:
    r14 = CPyTagged_IsLt_(limit, 6)
    if r14 goto L26 else goto L16 :: bool
L11:
    r15 = limit < 6 :: signed
    if r15 goto L26 else goto L16 :: bool
L12:
    r16 = 'Abbreviation limit may not be less than 3'
    r17 = builtins :: module
    r18 = 'ValueError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L21 (error at abbr:15) else goto L13
L13:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L21 (error at abbr:15) else goto L14
L14:
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L21 (error at abbr:15) else goto L15 :: bool
L15:
    unreachable
L16:
    r23 = CPyTagged_Subtract(limit, 6)
    dec_ref limit :: int
    r24 = CPyStr_GetSlice(rep, 0, r23)
    dec_ref rep
    dec_ref r23 :: int
    if is_error(r24) goto L21 (error at abbr:17) else goto L17
L17:
    r25 = cast(str, r24)
    if is_error(r25) goto L21 (error at abbr:17) else goto L18
L18:
    r26 = '...'
    r27 = PyUnicode_Concat(r25, r26)
    dec_ref r25
    if is_error(r27) goto L21 (error at abbr:17) else goto L19
L19:
    rep = r27
L20:
    return rep
L21:
    r28 = <error> :: str
    return r28
L22:
    inc_ref limit :: int
    goto L2
L23:
    dec_ref limit :: int
    goto L21
L24:
    dec_ref limit :: int
    dec_ref rep
    goto L21
L25:
    dec_ref limit :: int
    goto L20
L26:
    dec_ref limit :: int
    dec_ref rep
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.string.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def StrategyRegistry.__init__(self):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: faster_eth_abi._registry.PredicateMapping
    r2 :: bool
    r3 :: None
L0:
    r0 = 'strategy registry'
    r1 = PredicateMapping(r0)
    if is_error(r1) goto L3 (error at __init__:47) else goto L1
L1:
    self._strategies = r1; r2 = is_error
    if not r2 goto L3 (error at __init__:47) else goto L2 :: bool
L2:
    return 1
L3:
    r3 = <error> :: None
    return r3

def StrategyRegistry.register_strategy(self, lookup, registration, label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup :: union[str, object]
    registration :: object
    label :: union[str, None]
    r0 :: object
    r1 :: faster_eth_abi._registry.PredicateMapping
    r2 :: str
    r3 :: object[5]
    r4 :: object_ptr
    r5, r6 :: object
    r7 :: None
L0:
    if is_error(label) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._strategies
    if is_error(r1) goto L7 (error at register_strategy:55) else goto L3
L3:
    r2 = '_register'
    r3 = [self, r1, lookup, registration, label]
    r4 = load_address r3
    r5 = ('label',)
    r6 = PyObject_VectorcallMethod(r2, r4, 9223372036854775812, r5)
    if is_error(r6) goto L8 (error at register_strategy:55) else goto L9
L4:
    dec_ref r1
    dec_ref label
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    inc_ref label
    goto L2
L7:
    dec_ref label
    goto L5
L8:
    dec_ref label
    dec_ref r1
    goto L5
L9:
    dec_ref r6
    goto L4

def StrategyRegistry.unregister_strategy(self, lookup_or_label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup_or_label :: union[str, object]
    r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: None
L0:
    r0 = self._strategies
    if is_error(r0) goto L3 (error at unregister_strategy:58) else goto L1
L1:
    r1 = '_unregister'
    r2 = [self, r0, lookup_or_label]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L4 (error at unregister_strategy:58) else goto L5
L2:
    dec_ref r0
    return 1
L3:
    r5 = <error> :: None
    return r5
L4:
    dec_ref r0
    goto L3
L5:
    dec_ref r4
    goto L2

def StrategyRegistry.get_strategy(self, type_str):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    type_str :: str
    r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: object[2]
    r21 :: object_ptr
    r22, r23 :: object
L0:
    r0 = self._strategies
    if is_error(r0) goto L12 (error at get_strategy:70) else goto L1
L1:
    r1 = '_get_registration'
    r2 = [self, r0, type_str]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L13 (error at get_strategy:70) else goto L2
L2:
    dec_ref r0
    r5 = faster_eth_abi.tools._strategies.globals :: static
    r6 = 'st'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L14 (error at get_strategy:72) else goto L3
L3:
    r8 = 'SearchStrategy'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L14 (error at get_strategy:72) else goto L4
L4:
    r10 = PyObject_IsInstance(r4, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L14 (error at get_strategy:72) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L7 :: bool
L6:
    return r4
L7:
    r13 = normalize(type_str)
    if is_error(r13) goto L14 (error at get_strategy:78) else goto L8
L8:
    r14 = faster_eth_abi.tools._strategies.globals :: static
    r15 = 'parse'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L15 (error at get_strategy:79) else goto L9
L9:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L15 (error at get_strategy:79) else goto L10
L10:
    dec_ref r13
    r20 = [r19, self]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r4, r21, 2, 0)
    dec_ref r4
    if is_error(r22) goto L16 (error at get_strategy:80) else goto L11
L11:
    dec_ref r19
    return r22
L12:
    r23 = <error> :: object
    return r23
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref r4
    goto L12
L15:
    dec_ref r4
    dec_ref r13
    goto L12
L16:
    dec_ref r19
    goto L12

def get_uint_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.BasicType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: union[int, tuple, None]
    r1 :: int
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[3]
    r13 :: object_ptr
    r14, r15, r16 :: object
L0:
    r0 = abi_type.sub
    if is_error(r0) goto L7 (error at get_uint_strategy:88) else goto L1
L1:
    r1 = unbox(int, r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at get_uint_strategy:88) else goto L2
L2:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L8 (error at get_uint_strategy:90) else goto L3
L3:
    r5 = object 2
    r6 = box(int, r1)
    r7 = CPyNumber_Power(r5, r6)
    dec_ref r6
    if is_error(r7) goto L9 (error at get_uint_strategy:92) else goto L4
L4:
    r8 = object 1
    r9 = PyNumber_Subtract(r7, r8)
    dec_ref r7
    if is_error(r9) goto L9 (error at get_uint_strategy:92) else goto L5
L5:
    r10 = 'integers'
    r11 = object 0
    r12 = [r4, r11, r9]
    r13 = load_address r12
    r14 = ('min_value', 'max_value')
    r15 = PyObject_VectorcallMethod(r10, r13, 9223372036854775809, r14)
    if is_error(r15) goto L10 (error at get_uint_strategy:90) else goto L6
L6:
    dec_ref r4
    dec_ref r9
    return r15
L7:
    r16 = <error> :: object
    return r16
L8:
    dec_ref r1 :: int
    goto L7
L9:
    dec_ref r4
    goto L7
L10:
    dec_ref r4
    dec_ref r9
    goto L7

def get_int_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.BasicType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: union[int, tuple, None]
    r1 :: int
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: int
    r6, r7, r8, r9 :: object
    r10 :: int
    r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    r0 = abi_type.sub
    if is_error(r0) goto L9 (error at get_int_strategy:99) else goto L1
L1:
    r1 = unbox(int, r0)
    dec_ref r0
    if is_error(r1) goto L9 (error at get_int_strategy:99) else goto L2
L2:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L10 (error at get_int_strategy:101) else goto L3
L3:
    r5 = CPyTagged_Subtract(r1, 2)
    r6 = object 2
    r7 = box(int, r5)
    r8 = CPyNumber_Power(r6, r7)
    dec_ref r7
    if is_error(r8) goto L11 (error at get_int_strategy:102) else goto L4
L4:
    r9 = PyNumber_Negative(r8)
    dec_ref r8
    if is_error(r9) goto L11 (error at get_int_strategy:102) else goto L5
L5:
    r10 = CPyTagged_Subtract(r1, 2)
    dec_ref r1 :: int
    r11 = object 2
    r12 = box(int, r10)
    r13 = CPyNumber_Power(r11, r12)
    dec_ref r12
    if is_error(r13) goto L12 (error at get_int_strategy:103) else goto L6
L6:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L12 (error at get_int_strategy:103) else goto L7
L7:
    r16 = 'integers'
    r17 = [r4, r9, r15]
    r18 = load_address r17
    r19 = ('min_value', 'max_value')
    r20 = PyObject_VectorcallMethod(r16, r18, 9223372036854775809, r19)
    if is_error(r20) goto L13 (error at get_int_strategy:101) else goto L8
L8:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    return r20
L9:
    r21 = <error> :: object
    return r21
L10:
    dec_ref r1 :: int
    goto L9
L11:
    dec_ref r1 :: int
    dec_ref r4
    goto L9
L12:
    dec_ref r4
    dec_ref r9
    goto L9
L13:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    goto L9

def get_ufixed_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.BasicType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: union[int, tuple, None]
    r1 :: tuple[int, int]
    r2, r3, r4, r5 :: int
    r6 :: dict
    r7 :: str
    r8, r9, r10, r11, r12, r13 :: object
    r14 :: str
    r15, r16 :: object
    r17 :: object[4]
    r18 :: object_ptr
    r19, r20, r21 :: object
    r22 :: str
    r23 :: object[2]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = abi_type.sub
    if is_error(r0) goto L9 (error at get_ufixed_strategy:114) else goto L1
L1:
    r1 = unbox(tuple[int, int], r0)
    dec_ref r0
    if is_error(r1) goto L9 (error at get_ufixed_strategy:114) else goto L2
L2:
    r2 = borrow r1[0]
    r3 = borrow r1[1]
    r4 = unborrow r2
    r5 = unborrow r3
    r6 = faster_eth_abi.tools._strategies.globals :: static
    r7 = 'st'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L10 (error at get_ufixed_strategy:116) else goto L3
L3:
    r9 = object 2
    r10 = box(int, r4)
    r11 = CPyNumber_Power(r9, r10)
    dec_ref r10
    if is_error(r11) goto L11 (error at get_ufixed_strategy:118) else goto L4
L4:
    r12 = object 1
    r13 = PyNumber_Subtract(r11, r12)
    dec_ref r11
    if is_error(r13) goto L11 (error at get_ufixed_strategy:118) else goto L5
L5:
    r14 = 'decimals'
    r15 = object 0
    r16 = object 0
    r17 = [r8, r15, r13, r16]
    r18 = load_address r17
    r19 = ('min_value', 'max_value', 'places')
    r20 = PyObject_VectorcallMethod(r14, r18, 9223372036854775809, r19)
    if is_error(r20) goto L12 (error at get_ufixed_strategy:116) else goto L6
L6:
    dec_ref r8
    dec_ref r13
    r21 = scale_places(r5)
    dec_ref r5 :: int
    if is_error(r21) goto L13 (error at get_ufixed_strategy:120) else goto L7
L7:
    r22 = 'map'
    r23 = [r20, r21]
    r24 = load_address r23
    r25 = PyObject_VectorcallMethod(r22, r24, 9223372036854775810, 0)
    if is_error(r25) goto L14 (error at get_ufixed_strategy:116) else goto L8
L8:
    dec_ref r20
    dec_ref r21
    return r25
L9:
    r26 = <error> :: object
    return r26
L10:
    dec_ref r4 :: int
    dec_ref r5 :: int
    goto L9
L11:
    dec_ref r5 :: int
    dec_ref r8
    goto L9
L12:
    dec_ref r5 :: int
    dec_ref r8
    dec_ref r13
    goto L9
L13:
    dec_ref r20
    goto L9
L14:
    dec_ref r20
    dec_ref r21
    goto L9

def get_fixed_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.BasicType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: union[int, tuple, None]
    r1 :: tuple[int, int]
    r2, r3, r4, r5 :: int
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: int
    r10, r11, r12, r13 :: object
    r14 :: int
    r15, r16, r17, r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: object[4]
    r23 :: object_ptr
    r24, r25, r26 :: object
    r27 :: str
    r28 :: object[2]
    r29 :: object_ptr
    r30, r31 :: object
L0:
    r0 = abi_type.sub
    if is_error(r0) goto L11 (error at get_fixed_strategy:126) else goto L1
L1:
    r1 = unbox(tuple[int, int], r0)
    dec_ref r0
    if is_error(r1) goto L11 (error at get_fixed_strategy:126) else goto L2
L2:
    r2 = borrow r1[0]
    r3 = borrow r1[1]
    r4 = unborrow r2
    r5 = unborrow r3
    r6 = faster_eth_abi.tools._strategies.globals :: static
    r7 = 'st'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L12 (error at get_fixed_strategy:128) else goto L3
L3:
    r9 = CPyTagged_Subtract(r4, 2)
    r10 = object 2
    r11 = box(int, r9)
    r12 = CPyNumber_Power(r10, r11)
    dec_ref r11
    if is_error(r12) goto L13 (error at get_fixed_strategy:129) else goto L4
L4:
    r13 = PyNumber_Negative(r12)
    dec_ref r12
    if is_error(r13) goto L13 (error at get_fixed_strategy:129) else goto L5
L5:
    r14 = CPyTagged_Subtract(r4, 2)
    dec_ref r4 :: int
    r15 = object 2
    r16 = box(int, r14)
    r17 = CPyNumber_Power(r15, r16)
    dec_ref r16
    if is_error(r17) goto L14 (error at get_fixed_strategy:130) else goto L6
L6:
    r18 = object 1
    r19 = PyNumber_Subtract(r17, r18)
    dec_ref r17
    if is_error(r19) goto L14 (error at get_fixed_strategy:130) else goto L7
L7:
    r20 = 'decimals'
    r21 = object 0
    r22 = [r8, r13, r19, r21]
    r23 = load_address r22
    r24 = ('min_value', 'max_value', 'places')
    r25 = PyObject_VectorcallMethod(r20, r23, 9223372036854775809, r24)
    if is_error(r25) goto L15 (error at get_fixed_strategy:128) else goto L8
L8:
    dec_ref r8
    dec_ref r13
    dec_ref r19
    r26 = scale_places(r5)
    dec_ref r5 :: int
    if is_error(r26) goto L16 (error at get_fixed_strategy:132) else goto L9
L9:
    r27 = 'map'
    r28 = [r25, r26]
    r29 = load_address r28
    r30 = PyObject_VectorcallMethod(r27, r29, 9223372036854775810, 0)
    if is_error(r30) goto L17 (error at get_fixed_strategy:128) else goto L10
L10:
    dec_ref r25
    dec_ref r26
    return r30
L11:
    r31 = <error> :: object
    return r31
L12:
    dec_ref r4 :: int
    dec_ref r5 :: int
    goto L11
L13:
    dec_ref r4 :: int
    dec_ref r5 :: int
    dec_ref r8
    goto L11
L14:
    dec_ref r5 :: int
    dec_ref r8
    dec_ref r13
    goto L11
L15:
    dec_ref r5 :: int
    dec_ref r8
    dec_ref r13
    dec_ref r19
    goto L11
L16:
    dec_ref r25
    goto L11
L17:
    dec_ref r25
    dec_ref r26
    goto L11

def get_bytes_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.BasicType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: union[int, tuple, None]
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object[3]
    r6 :: object_ptr
    r7, r8, r9 :: object
L0:
    r0 = abi_type.sub
    if is_error(r0) goto L4 (error at get_bytes_strategy:138) else goto L1
L1:
    r1 = faster_eth_abi.tools._strategies.globals :: static
    r2 = 'st'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L5 (error at get_bytes_strategy:140) else goto L2
L2:
    r4 = 'binary'
    r5 = [r3, r0, r0]
    r6 = load_address r5
    r7 = ('min_size', 'max_size')
    r8 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, r7)
    if is_error(r8) goto L6 (error at get_bytes_strategy:140) else goto L3
L3:
    dec_ref r3
    dec_ref r0
    return r8
L4:
    r9 = <error> :: object
    return r9
L5:
    dec_ref r0
    goto L4
L6:
    dec_ref r0
    dec_ref r3
    goto L4

def get_array_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.ABIType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: faster_eth_abi._grammar.ABIType
    r1 :: str
    r2 :: object
    r3 :: union[object, None]
    r4, r5, r6 :: object
    r7 :: union[str, object]
    r8 :: int
    r9 :: bit
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16, r17, r18, r19 :: object
    r20 :: union[str, object]
    r21 :: dict
    r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object[4]
    r26 :: object_ptr
    r27, r28, r29 :: object
L0:
    r0 = abi_type.item_type
    if is_error(r0) goto L16 (error at get_array_strategy:153) else goto L1
L1:
    r1 = r0.to_type_str()
    dec_ref r0
    if is_error(r1) goto L16 (error at get_array_strategy:154) else goto L2
L2:
    r2 = registry.get_strategy(r1)
    dec_ref r1
    if is_error(r2) goto L16 (error at get_array_strategy:155) else goto L3
L3:
    r3 = abi_type.arrlist
    if is_error(r3) goto L17 (error at get_array_strategy:157) else goto L4
L4:
    r4 = r3
    r5 = object -1
    r6 = PyObject_GetItem(r4, r5)
    dec_ref r4
    if is_error(r6) goto L17 (error at get_array_strategy:157) else goto L5
L5:
    r7 = r6
L6:
    r8 = CPyObject_Size(r7)
    if is_error(r8) goto L18 (error at get_array_strategy:158) else goto L7
L7:
    r9 = r8 == 0
    dec_ref r8 :: int
    if r9 goto L19 else goto L11 :: bool
L8:
    r10 = faster_eth_abi.tools._strategies.globals :: static
    r11 = 'st'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L17 (error at get_array_strategy:160) else goto L9
L9:
    r13 = 'lists'
    r14 = [r12, r2]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L20 (error at get_array_strategy:160) else goto L10
L10:
    dec_ref r12
    dec_ref r2
    return r16
L11:
    r17 = r7
    r18 = object 0
    r19 = PyObject_GetItem(r17, r18)
    dec_ref r17
    if is_error(r19) goto L17 (error at get_array_strategy:163) else goto L12
L12:
    r20 = r19
L13:
    r21 = faster_eth_abi.tools._strategies.globals :: static
    r22 = 'st'
    r23 = CPyDict_GetItem(r21, r22)
    if is_error(r23) goto L21 (error at get_array_strategy:164) else goto L14
L14:
    r24 = 'lists'
    r25 = [r23, r2, r20, r20]
    r26 = load_address r25
    r27 = ('min_size', 'max_size')
    r28 = PyObject_VectorcallMethod(r24, r26, 9223372036854775810, r27)
    if is_error(r28) goto L22 (error at get_array_strategy:164) else goto L15
L15:
    dec_ref r23
    dec_ref r2
    dec_ref r20
    return r28
L16:
    r29 = <error> :: object
    return r29
L17:
    dec_ref r2
    goto L16
L18:
    dec_ref r2
    dec_ref r7
    goto L16
L19:
    dec_ref r7
    goto L8
L20:
    dec_ref r2
    dec_ref r12
    goto L16
L21:
    dec_ref r2
    dec_ref r20
    goto L16
L22:
    dec_ref r2
    dec_ref r20
    dec_ref r23
    goto L16

def get_tuple_strategy(abi_type, registry):
    abi_type :: faster_eth_abi._grammar.TupleType
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: tuple
    r1 :: ptr
    r2 :: native_int
    r3 :: list
    r4 :: ptr
    r5, r6 :: native_int
    r7 :: bit
    r8 :: object
    r9 :: faster_eth_abi._grammar.ABIType
    r10 :: str
    r11 :: object
    r12 :: native_int
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: tuple
    r19, r20 :: object
L0:
    r0 = abi_type.components
    if is_error(r0) goto L14 (error at get_tuple_strategy:172) else goto L1
L1:
    r1 = get_element_ptr r0 ob_size :: PyVarObject
    r2 = load_mem r1 :: native_int*
    r3 = PyList_New(r2)
    if is_error(r3) goto L15 (error at get_tuple_strategy:170) else goto L2
L2:
    r4 = get_element_ptr r0 ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    r6 = 0
L3:
    r7 = r6 < r5 :: signed
    if r7 goto L4 else goto L16 :: bool
L4:
    r8 = CPySequenceTuple_GetItemUnsafe(r0, r6)
    r9 = cast(faster_eth_abi._grammar.ABIType, r8)
    if is_error(r9) goto L17 (error at get_tuple_strategy:170) else goto L5
L5:
    r10 = r9.to_type_str()
    dec_ref r9
    if is_error(r10) goto L17 (error at get_tuple_strategy:171) else goto L6
L6:
    r11 = registry.get_strategy(r10)
    dec_ref r10
    if is_error(r11) goto L17 (error at get_tuple_strategy:171) else goto L7
L7:
    CPyList_SetItemUnsafe(r3, r6, r11)
L8:
    r12 = r6 + 1
    r6 = r12
    goto L3
L9:
    r13 = faster_eth_abi.tools._strategies.globals :: static
    r14 = 'st'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L18 (error at get_tuple_strategy:175) else goto L10
L10:
    r16 = 'tuples'
    r17 = CPyObject_GetAttr(r15, r16)
    dec_ref r15
    if is_error(r17) goto L18 (error at get_tuple_strategy:175) else goto L11
L11:
    r18 = PyList_AsTuple(r3)
    dec_ref r3
    if is_error(r18) goto L19 (error at get_tuple_strategy:175) else goto L12
L12:
    r19 = PyObject_CallObject(r17, r18)
    dec_ref r17
    dec_ref r18
    if is_error(r19) goto L14 (error at get_tuple_strategy:175) else goto L13
L13:
    return r19
L14:
    r20 = <error> :: object
    return r20
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r0
    goto L9
L17:
    dec_ref r0
    dec_ref r3
    goto L14
L18:
    dec_ref r3
    goto L14
L19:
    dec_ref r17
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17, r18 :: object
    r19 :: str
    r20 :: dict
    r21, r22 :: object
    r23 :: str
    r24 :: dict
    r25, r26 :: object
    r27 :: str
    r28 :: dict
    r29, r30 :: object
    r31 :: str
    r32 :: dict
    r33, r34 :: object
    r35 :: str
    r36 :: dict
    r37 :: object
    r38 :: dict
    r39 :: str
    r40, r41 :: object
    r42 :: str
    r43 :: list
    r44, r45, r46 :: ptr
    r47 :: dict
    r48 :: str
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: tuple[list, object]
    r53, r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: i32
    r58 :: bit
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: dict
    r63 :: str
    r64 :: object
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: tuple[object, object]
    r71, r72 :: object
    r73 :: dict
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77 :: dict
    r78 :: str
    r79 :: object
    r80 :: tuple
    r81 :: str
    r82, r83 :: object
    r84 :: bool
    r85, r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: dict
    r96 :: str
    r97 :: object
    r98 :: str
    r99, r100 :: object
    r101 :: object[3]
    r102 :: object_ptr
    r103, r104 :: object
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: str
    r109 :: object[2]
    r110 :: object_ptr
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115 :: bit
    r116 :: dict
    r117 :: str
    r118 :: object
    r119 :: str
    r120 :: object[1]
    r121 :: object_ptr
    r122 :: object
    r123 :: dict
    r124 :: str
    r125 :: i32
    r126 :: bit
    r127 :: dict
    r128 :: str
    r129 :: object
    r130 :: str
    r131, r132 :: object
    r133 :: object[3]
    r134 :: object_ptr
    r135, r136 :: object
    r137 :: dict
    r138 :: str
    r139 :: i32
    r140 :: bit
    r141 :: dict
    r142 :: str
    r143 :: object
    r144 :: str
    r145 :: object[1]
    r146 :: object_ptr
    r147 :: object
    r148 :: dict
    r149 :: str
    r150 :: i32
    r151 :: bit
    r152 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r153 :: dict
    r154 :: str
    r155 :: i32
    r156 :: bit
    r157 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r158 :: bool
    r159 :: str
    r160 :: union[bool, None]
    r161 :: faster_eth_abi._registry.BaseEquals
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: None
    r167 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r168 :: bool
    r169 :: str
    r170 :: union[bool, None]
    r171 :: faster_eth_abi._registry.BaseEquals
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: str
    r176 :: None
    r177 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r178 :: bool
    r179 :: str
    r180 :: object
    r181 :: faster_eth_abi._registry.BaseEquals
    r182 :: object
    r183 :: bool
    r184 :: str
    r185 :: None
    r186 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r187 :: bool
    r188 :: str
    r189 :: object
    r190 :: faster_eth_abi._registry.BaseEquals
    r191 :: object
    r192 :: bool
    r193 :: str
    r194 :: None
    r195 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r196 :: bool
    r197 :: str
    r198 :: union[bool, None]
    r199 :: faster_eth_abi._registry.BaseEquals
    r200 :: dict
    r201 :: str
    r202 :: object
    r203 :: str
    r204 :: None
    r205 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r206 :: bool
    r207 :: str
    r208 :: union[bool, None]
    r209 :: faster_eth_abi._registry.BaseEquals
    r210 :: dict
    r211 :: str
    r212 :: object
    r213 :: str
    r214 :: None
    r215 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r216 :: bool
    r217 :: str
    r218 :: object
    r219 :: faster_eth_abi._registry.BaseEquals
    r220 :: dict
    r221 :: str
    r222 :: object
    r223 :: str
    r224 :: None
    r225 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r226 :: bool
    r227 :: str
    r228 :: object
    r229 :: faster_eth_abi._registry.BaseEquals
    r230 :: object
    r231 :: bool
    r232 :: str
    r233 :: None
    r234 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r235 :: bool
    r236 :: str
    r237 :: object
    r238 :: faster_eth_abi._registry.BaseEquals
    r239 :: dict
    r240 :: str
    r241 :: object
    r242 :: str
    r243 :: None
    r244 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r245 :: bool
    r246 :: str
    r247 :: object
    r248 :: faster_eth_abi._registry.BaseEquals
    r249 :: object
    r250 :: bool
    r251 :: str
    r252 :: None
    r253 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r254 :: bool
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: dict
    r259 :: str
    r260 :: object
    r261 :: str
    r262 :: None
    r263 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r264 :: bool
    r265 :: dict
    r266 :: str
    r267 :: object
    r268 :: dict
    r269 :: str
    r270 :: object
    r271 :: str
    r272 :: None
    r273 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r274 :: bool
    r275 :: str
    r276 :: object
    r277 :: dict
    r278 :: str
    r279 :: i32
    r280 :: bit
    r281 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L132 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Callable', 'Final', 'Optional', 'Tuple', 'Union', 'cast')
    r6 = 'typing'
    r7 = faster_eth_abi.tools._strategies.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L132 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('to_checksum_address',)
    r10 = 'cchecksum'
    r11 = faster_eth_abi.tools._strategies.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L132 (error at <module>:10) else goto L5
L5:
    cchecksum = r12 :: module
    dec_ref r12
    r13 = ('TypeStr',)
    r14 = 'eth_typing.abi'
    r15 = faster_eth_abi.tools._strategies.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L132 (error at <module>:13) else goto L6
L6:
    eth_typing.abi = r16 :: module
    dec_ref r16
    r17 = ('strategies',)
    r18 = ('st',)
    r19 = 'hypothesis'
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = CPyImport_ImportFromMany(r19, r17, r18, r20)
    if is_error(r21) goto L132 (error at <module>:16) else goto L7
L7:
    hypothesis = r21 :: module
    dec_ref r21
    r22 = ('ABIType', 'BasicType', 'TupleType', 'normalize')
    r23 = 'faster_eth_abi._grammar'
    r24 = faster_eth_abi.tools._strategies.globals :: static
    r25 = CPyImport_ImportFromMany(r23, r22, r22, r24)
    if is_error(r25) goto L132 (error at <module>:20) else goto L8
L8:
    faster_eth_abi._grammar = r25 :: module
    dec_ref r25
    r26 = ('parse',)
    r27 = 'faster_eth_abi.grammar'
    r28 = faster_eth_abi.tools._strategies.globals :: static
    r29 = CPyImport_ImportFromMany(r27, r26, r26, r28)
    if is_error(r29) goto L132 (error at <module>:26) else goto L9
L9:
    faster_eth_abi.grammar = r29 :: module
    dec_ref r29
    r30 = ('BaseEquals', 'BaseRegistry', 'Lookup', 'PredicateMapping', 'has_arrlist', 'is_base_tuple')
    r31 = 'faster_eth_abi.registry'
    r32 = faster_eth_abi.tools._strategies.globals :: static
    r33 = CPyImport_ImportFromMany(r31, r30, r30, r32)
    if is_error(r33) goto L132 (error at <module>:29) else goto L10
L10:
    faster_eth_abi.registry = r33 :: module
    dec_ref r33
    r34 = ('scale_places',)
    r35 = 'faster_eth_abi.utils.numeric'
    r36 = faster_eth_abi.tools._strategies.globals :: static
    r37 = CPyImport_ImportFromMany(r35, r34, r34, r36)
    if is_error(r37) goto L132 (error at <module>:37) else goto L11
L11:
    faster_eth_abi.utils.numeric = r37 :: module
    dec_ref r37
    r38 = faster_eth_abi.tools._strategies.globals :: static
    r39 = 'Callable'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L132 (error at <module>:41) else goto L12
L12:
    r41 = faster_eth_abi._grammar.ABIType :: type
    r42 = 'StrategyRegistry'
    r43 = PyList_New(2)
    if is_error(r43) goto L133 (error at <module>:41) else goto L13
L13:
    r44 = get_element_ptr r43 ob_item :: PyListObject
    r45 = load_mem r44 :: ptr*
    inc_ref r41
    set_mem r45, r41 :: builtins.object*
    inc_ref r42
    r46 = r45 + 8
    set_mem r46, r42 :: builtins.object*
    r47 = faster_eth_abi.tools._strategies.globals :: static
    r48 = 'st'
    r49 = CPyDict_GetItem(r47, r48)
    if is_error(r49) goto L134 (error at <module>:41) else goto L14
L14:
    r50 = 'SearchStrategy'
    r51 = CPyObject_GetAttr(r49, r50)
    dec_ref r49
    if is_error(r51) goto L134 (error at <module>:41) else goto L15
L15:
    r52 = (r43, r51)
    r53 = box(tuple[list, object], r52)
    r54 = PyObject_GetItem(r40, r53)
    dec_ref r40
    dec_ref r53
    if is_error(r54) goto L132 (error at <module>:41) else goto L16
L16:
    r55 = faster_eth_abi.tools._strategies.globals :: static
    r56 = 'StrategyFactory'
    r57 = CPyDict_SetItem(r55, r56, r54)
    dec_ref r54
    r58 = r57 >= 0 :: signed
    if not r58 goto L132 (error at <module>:41) else goto L17 :: bool
L17:
    r59 = faster_eth_abi.tools._strategies.globals :: static
    r60 = 'Union'
    r61 = CPyDict_GetItem(r59, r60)
    if is_error(r61) goto L132 (error at <module>:42) else goto L18
L18:
    r62 = faster_eth_abi.tools._strategies.globals :: static
    r63 = 'st'
    r64 = CPyDict_GetItem(r62, r63)
    if is_error(r64) goto L135 (error at <module>:42) else goto L19
L19:
    r65 = 'SearchStrategy'
    r66 = CPyObject_GetAttr(r64, r65)
    dec_ref r64
    if is_error(r66) goto L135 (error at <module>:42) else goto L20
L20:
    r67 = faster_eth_abi.tools._strategies.globals :: static
    r68 = 'StrategyFactory'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L136 (error at <module>:42) else goto L21
L21:
    r70 = (r66, r69)
    r71 = box(tuple[object, object], r70)
    r72 = PyObject_GetItem(r61, r71)
    dec_ref r61
    dec_ref r71
    if is_error(r72) goto L132 (error at <module>:42) else goto L22
L22:
    r73 = faster_eth_abi.tools._strategies.globals :: static
    r74 = 'StrategyRegistration'
    r75 = CPyDict_SetItem(r73, r74, r72)
    dec_ref r72
    r76 = r75 >= 0 :: signed
    if not r76 goto L132 (error at <module>:42) else goto L23 :: bool
L23:
    r77 = faster_eth_abi.tools._strategies.globals :: static
    r78 = 'BaseRegistry'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L132 (error at <module>:45) else goto L24
L24:
    r80 = PyTuple_Pack(1, r79)
    dec_ref r79
    if is_error(r80) goto L132 (error at <module>:45) else goto L25
L25:
    r81 = 'faster_eth_abi.tools._strategies'
    r82 = faster_eth_abi.tools._strategies.StrategyRegistry_template :: type
    r83 = CPyType_FromTemplate(r82, r80, r81)
    dec_ref r80
    if is_error(r83) goto L132 (error at <module>:45) else goto L26
L26:
    r84 = StrategyRegistry_trait_vtable_setup()
    if is_error(r84) goto L137 (error at <module>:-1) else goto L27
L27:
    r85 = '__mypyc_attrs__'
    r86 = '_strategies'
    r87 = '__dict__'
    r88 = PyTuple_Pack(2, r86, r87)
    if is_error(r88) goto L137 (error at <module>:45) else goto L28
L28:
    r89 = PyObject_SetAttr(r83, r85, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L137 (error at <module>:45) else goto L29 :: bool
L29:
    faster_eth_abi.tools._strategies.StrategyRegistry = r83 :: type
    r91 = faster_eth_abi.tools._strategies.globals :: static
    r92 = 'StrategyRegistry'
    r93 = PyDict_SetItem(r91, r92, r83)
    dec_ref r83
    r94 = r93 >= 0 :: signed
    if not r94 goto L132 (error at <module>:45) else goto L30 :: bool
L30:
    r95 = faster_eth_abi.tools._strategies.globals :: static
    r96 = 'st'
    r97 = CPyDict_GetItem(r95, r96)
    if is_error(r97) goto L132 (error at <module>:107) else goto L31
L31:
    r98 = 'binary'
    r99 = object 20
    r100 = object 20
    r101 = [r97, r99, r100]
    r102 = load_address r101
    r103 = ('min_size', 'max_size')
    r104 = PyObject_VectorcallMethod(r98, r102, 9223372036854775809, r103)
    if is_error(r104) goto L138 (error at <module>:107) else goto L32
L32:
    dec_ref r97
    r105 = faster_eth_abi.tools._strategies.globals :: static
    r106 = 'to_checksum_address'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L139 (error at <module>:107) else goto L33
L33:
    r108 = 'map'
    r109 = [r104, r107]
    r110 = load_address r109
    r111 = PyObject_VectorcallMethod(r108, r110, 9223372036854775810, 0)
    if is_error(r111) goto L140 (error at <module>:107) else goto L34
L34:
    dec_ref r104
    dec_ref r107
    faster_eth_abi.tools._strategies.address_strategy = r111 :: static
    r112 = faster_eth_abi.tools._strategies.globals :: static
    r113 = 'address_strategy'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L132 (error at <module>:107) else goto L35 :: bool
L35:
    r116 = faster_eth_abi.tools._strategies.globals :: static
    r117 = 'st'
    r118 = CPyDict_GetItem(r116, r117)
    if is_error(r118) goto L132 (error at <module>:108) else goto L36
L36:
    r119 = 'booleans'
    r120 = [r118]
    r121 = load_address r120
    r122 = PyObject_VectorcallMethod(r119, r121, 9223372036854775809, 0)
    if is_error(r122) goto L141 (error at <module>:108) else goto L37
L37:
    dec_ref r118
    faster_eth_abi.tools._strategies.bool_strategy = r122 :: static
    r123 = faster_eth_abi.tools._strategies.globals :: static
    r124 = 'bool_strategy'
    r125 = CPyDict_SetItem(r123, r124, r122)
    dec_ref r122
    r126 = r125 >= 0 :: signed
    if not r126 goto L132 (error at <module>:108) else goto L38 :: bool
L38:
    r127 = faster_eth_abi.tools._strategies.globals :: static
    r128 = 'st'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L132 (error at <module>:146) else goto L39
L39:
    r130 = 'binary'
    r131 = object 0
    r132 = object 4096
    r133 = [r129, r131, r132]
    r134 = load_address r133
    r135 = ('min_size', 'max_size')
    r136 = PyObject_VectorcallMethod(r130, r134, 9223372036854775809, r135)
    if is_error(r136) goto L142 (error at <module>:146) else goto L40
L40:
    dec_ref r129
    faster_eth_abi.tools._strategies.bytes_strategy = r136 :: static
    r137 = faster_eth_abi.tools._strategies.globals :: static
    r138 = 'bytes_strategy'
    r139 = CPyDict_SetItem(r137, r138, r136)
    dec_ref r136
    r140 = r139 >= 0 :: signed
    if not r140 goto L132 (error at <module>:146) else goto L41 :: bool
L41:
    r141 = faster_eth_abi.tools._strategies.globals :: static
    r142 = 'st'
    r143 = CPyDict_GetItem(r141, r142)
    if is_error(r143) goto L132 (error at <module>:147) else goto L42
L42:
    r144 = 'text'
    r145 = [r143]
    r146 = load_address r145
    r147 = PyObject_VectorcallMethod(r144, r146, 9223372036854775809, 0)
    if is_error(r147) goto L143 (error at <module>:147) else goto L43
L43:
    dec_ref r143
    faster_eth_abi.tools._strategies.string_strategy = r147 :: static
    r148 = faster_eth_abi.tools._strategies.globals :: static
    r149 = 'string_strategy'
    r150 = CPyDict_SetItem(r148, r149, r147)
    dec_ref r147
    r151 = r150 >= 0 :: signed
    if not r151 goto L132 (error at <module>:147) else goto L44 :: bool
L44:
    r152 = StrategyRegistry()
    if is_error(r152) goto L132 (error at <module>:178) else goto L45
L45:
    faster_eth_abi.tools._strategies.strategy_registry = r152 :: static
    r153 = faster_eth_abi.tools._strategies.globals :: static
    r154 = 'strategy_registry'
    r155 = CPyDict_SetItem(r153, r154, r152)
    dec_ref r152
    r156 = r155 >= 0 :: signed
    if not r156 goto L132 (error at <module>:178) else goto L46 :: bool
L46:
    r157 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r157) goto L47 else goto L49
L47:
    r158 = raise NameError('value for final name "strategy_registry" was not set')
    if not r158 goto L132 (error at <module>:180) else goto L48 :: bool
L48:
    unreachable
L49:
    r159 = 'uint'
    r160 = <error> :: union[bool, None]
    r161 = BaseEquals(r159, r160)
    if is_error(r161) goto L132 (error at <module>:181) else goto L50
L50:
    r162 = faster_eth_abi.tools._strategies.globals :: static
    r163 = 'get_uint_strategy'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L144 (error at <module>:182) else goto L51
L51:
    r165 = 'uint'
    r166 = r157.register_strategy(r161, r164, r165)
    dec_ref r161
    dec_ref r164
    if is_error(r166) goto L132 (error at <module>:180) else goto L52
L52:
    r167 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r167) goto L53 else goto L55
L53:
    r168 = raise NameError('value for final name "strategy_registry" was not set')
    if not r168 goto L132 (error at <module>:185) else goto L54 :: bool
L54:
    unreachable
L55:
    r169 = 'int'
    r170 = <error> :: union[bool, None]
    r171 = BaseEquals(r169, r170)
    if is_error(r171) goto L132 (error at <module>:186) else goto L56
L56:
    r172 = faster_eth_abi.tools._strategies.globals :: static
    r173 = 'get_int_strategy'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L145 (error at <module>:187) else goto L57
L57:
    r175 = 'int'
    r176 = r167.register_strategy(r171, r174, r175)
    dec_ref r171
    dec_ref r174
    if is_error(r176) goto L132 (error at <module>:185) else goto L58
L58:
    r177 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r177) goto L59 else goto L61
L59:
    r178 = raise NameError('value for final name "strategy_registry" was not set')
    if not r178 goto L132 (error at <module>:190) else goto L60 :: bool
L60:
    unreachable
L61:
    r179 = 'address'
    r180 = box(bool, 0)
    r181 = BaseEquals(r179, r180)
    if is_error(r181) goto L132 (error at <module>:191) else goto L62
L62:
    r182 = faster_eth_abi.tools._strategies.address_strategy :: static
    if is_error(r182) goto L146 else goto L65
L63:
    r183 = raise NameError('value for final name "address_strategy" was not set')
    if not r183 goto L132 (error at <module>:192) else goto L64 :: bool
L64:
    unreachable
L65:
    r184 = 'address'
    r185 = r177.register_strategy(r181, r182, r184)
    dec_ref r181
    if is_error(r185) goto L132 (error at <module>:190) else goto L66
L66:
    r186 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r186) goto L67 else goto L69
L67:
    r187 = raise NameError('value for final name "strategy_registry" was not set')
    if not r187 goto L132 (error at <module>:195) else goto L68 :: bool
L68:
    unreachable
L69:
    r188 = 'bool'
    r189 = box(bool, 0)
    r190 = BaseEquals(r188, r189)
    if is_error(r190) goto L132 (error at <module>:196) else goto L70
L70:
    r191 = faster_eth_abi.tools._strategies.bool_strategy :: static
    if is_error(r191) goto L147 else goto L73
L71:
    r192 = raise NameError('value for final name "bool_strategy" was not set')
    if not r192 goto L132 (error at <module>:197) else goto L72 :: bool
L72:
    unreachable
L73:
    r193 = 'bool'
    r194 = r186.register_strategy(r190, r191, r193)
    dec_ref r190
    if is_error(r194) goto L132 (error at <module>:195) else goto L74
L74:
    r195 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r195) goto L75 else goto L77
L75:
    r196 = raise NameError('value for final name "strategy_registry" was not set')
    if not r196 goto L132 (error at <module>:200) else goto L76 :: bool
L76:
    unreachable
L77:
    r197 = 'ufixed'
    r198 = <error> :: union[bool, None]
    r199 = BaseEquals(r197, r198)
    if is_error(r199) goto L132 (error at <module>:201) else goto L78
L78:
    r200 = faster_eth_abi.tools._strategies.globals :: static
    r201 = 'get_ufixed_strategy'
    r202 = CPyDict_GetItem(r200, r201)
    if is_error(r202) goto L148 (error at <module>:202) else goto L79
L79:
    r203 = 'ufixed'
    r204 = r195.register_strategy(r199, r202, r203)
    dec_ref r199
    dec_ref r202
    if is_error(r204) goto L132 (error at <module>:200) else goto L80
L80:
    r205 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r205) goto L81 else goto L83
L81:
    r206 = raise NameError('value for final name "strategy_registry" was not set')
    if not r206 goto L132 (error at <module>:205) else goto L82 :: bool
L82:
    unreachable
L83:
    r207 = 'fixed'
    r208 = <error> :: union[bool, None]
    r209 = BaseEquals(r207, r208)
    if is_error(r209) goto L132 (error at <module>:206) else goto L84
L84:
    r210 = faster_eth_abi.tools._strategies.globals :: static
    r211 = 'get_fixed_strategy'
    r212 = CPyDict_GetItem(r210, r211)
    if is_error(r212) goto L149 (error at <module>:207) else goto L85
L85:
    r213 = 'fixed'
    r214 = r205.register_strategy(r209, r212, r213)
    dec_ref r209
    dec_ref r212
    if is_error(r214) goto L132 (error at <module>:205) else goto L86
L86:
    r215 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r215) goto L87 else goto L89
L87:
    r216 = raise NameError('value for final name "strategy_registry" was not set')
    if not r216 goto L132 (error at <module>:210) else goto L88 :: bool
L88:
    unreachable
L89:
    r217 = 'bytes'
    r218 = box(bool, 1)
    r219 = BaseEquals(r217, r218)
    if is_error(r219) goto L132 (error at <module>:211) else goto L90
L90:
    r220 = faster_eth_abi.tools._strategies.globals :: static
    r221 = 'get_bytes_strategy'
    r222 = CPyDict_GetItem(r220, r221)
    if is_error(r222) goto L150 (error at <module>:212) else goto L91
L91:
    r223 = 'bytes<M>'
    r224 = r215.register_strategy(r219, r222, r223)
    dec_ref r219
    dec_ref r222
    if is_error(r224) goto L132 (error at <module>:210) else goto L92
L92:
    r225 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r225) goto L93 else goto L95
L93:
    r226 = raise NameError('value for final name "strategy_registry" was not set')
    if not r226 goto L132 (error at <module>:215) else goto L94 :: bool
L94:
    unreachable
L95:
    r227 = 'bytes'
    r228 = box(bool, 0)
    r229 = BaseEquals(r227, r228)
    if is_error(r229) goto L132 (error at <module>:216) else goto L96
L96:
    r230 = faster_eth_abi.tools._strategies.bytes_strategy :: static
    if is_error(r230) goto L151 else goto L99
L97:
    r231 = raise NameError('value for final name "bytes_strategy" was not set')
    if not r231 goto L132 (error at <module>:217) else goto L98 :: bool
L98:
    unreachable
L99:
    r232 = 'bytes'
    r233 = r225.register_strategy(r229, r230, r232)
    dec_ref r229
    if is_error(r233) goto L132 (error at <module>:215) else goto L100
L100:
    r234 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r234) goto L101 else goto L103
L101:
    r235 = raise NameError('value for final name "strategy_registry" was not set')
    if not r235 goto L132 (error at <module>:220) else goto L102 :: bool
L102:
    unreachable
L103:
    r236 = 'function'
    r237 = box(bool, 0)
    r238 = BaseEquals(r236, r237)
    if is_error(r238) goto L132 (error at <module>:221) else goto L104
L104:
    r239 = faster_eth_abi.tools._strategies.globals :: static
    r240 = 'get_bytes_strategy'
    r241 = CPyDict_GetItem(r239, r240)
    if is_error(r241) goto L152 (error at <module>:222) else goto L105
L105:
    r242 = 'function'
    r243 = r234.register_strategy(r238, r241, r242)
    dec_ref r238
    dec_ref r241
    if is_error(r243) goto L132 (error at <module>:220) else goto L106
L106:
    r244 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r244) goto L107 else goto L109
L107:
    r245 = raise NameError('value for final name "strategy_registry" was not set')
    if not r245 goto L132 (error at <module>:225) else goto L108 :: bool
L108:
    unreachable
L109:
    r246 = 'string'
    r247 = box(bool, 0)
    r248 = BaseEquals(r246, r247)
    if is_error(r248) goto L132 (error at <module>:226) else goto L110
L110:
    r249 = faster_eth_abi.tools._strategies.string_strategy :: static
    if is_error(r249) goto L153 else goto L113
L111:
    r250 = raise NameError('value for final name "string_strategy" was not set')
    if not r250 goto L132 (error at <module>:227) else goto L112 :: bool
L112:
    unreachable
L113:
    r251 = 'string'
    r252 = r244.register_strategy(r248, r249, r251)
    dec_ref r248
    if is_error(r252) goto L132 (error at <module>:225) else goto L114
L114:
    r253 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r253) goto L115 else goto L117
L115:
    r254 = raise NameError('value for final name "strategy_registry" was not set')
    if not r254 goto L132 (error at <module>:230) else goto L116 :: bool
L116:
    unreachable
L117:
    r255 = faster_eth_abi.tools._strategies.globals :: static
    r256 = 'has_arrlist'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L132 (error at <module>:231) else goto L118
L118:
    r258 = faster_eth_abi.tools._strategies.globals :: static
    r259 = 'get_array_strategy'
    r260 = CPyDict_GetItem(r258, r259)
    if is_error(r260) goto L154 (error at <module>:232) else goto L119
L119:
    r261 = 'has_arrlist'
    r262 = r253.register_strategy(r257, r260, r261)
    dec_ref r257
    dec_ref r260
    if is_error(r262) goto L132 (error at <module>:230) else goto L120
L120:
    r263 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r263) goto L121 else goto L123
L121:
    r264 = raise NameError('value for final name "strategy_registry" was not set')
    if not r264 goto L132 (error at <module>:235) else goto L122 :: bool
L122:
    unreachable
L123:
    r265 = faster_eth_abi.tools._strategies.globals :: static
    r266 = 'is_base_tuple'
    r267 = CPyDict_GetItem(r265, r266)
    if is_error(r267) goto L132 (error at <module>:236) else goto L124
L124:
    r268 = faster_eth_abi.tools._strategies.globals :: static
    r269 = 'get_tuple_strategy'
    r270 = CPyDict_GetItem(r268, r269)
    if is_error(r270) goto L155 (error at <module>:237) else goto L125
L125:
    r271 = 'is_base_tuple'
    r272 = r263.register_strategy(r267, r270, r271)
    dec_ref r267
    dec_ref r270
    if is_error(r272) goto L132 (error at <module>:235) else goto L126
L126:
    r273 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r273) goto L127 else goto L129
L127:
    r274 = raise NameError('value for final name "strategy_registry" was not set')
    if not r274 goto L132 (error at <module>:241) else goto L128 :: bool
L128:
    unreachable
L129:
    r275 = 'get_strategy'
    r276 = CPyObject_GetAttr(r273, r275)
    if is_error(r276) goto L132 (error at <module>:241) else goto L130
L130:
    faster_eth_abi.tools._strategies.get_abi_strategy = r276 :: static
    r277 = faster_eth_abi.tools._strategies.globals :: static
    r278 = 'get_abi_strategy'
    r279 = CPyDict_SetItem(r277, r278, r276)
    dec_ref r276
    r280 = r279 >= 0 :: signed
    if not r280 goto L132 (error at <module>:241) else goto L131 :: bool
L131:
    return 1
L132:
    r281 = <error> :: None
    return r281
L133:
    dec_ref r40
    goto L132
L134:
    dec_ref r40
    dec_ref r43
    goto L132
L135:
    dec_ref r61
    goto L132
L136:
    dec_ref r61
    dec_ref r66
    goto L132
L137:
    dec_ref r83
    goto L132
L138:
    dec_ref r97
    goto L132
L139:
    dec_ref r104
    goto L132
L140:
    dec_ref r104
    dec_ref r107
    goto L132
L141:
    dec_ref r118
    goto L132
L142:
    dec_ref r129
    goto L132
L143:
    dec_ref r143
    goto L132
L144:
    dec_ref r161
    goto L132
L145:
    dec_ref r171
    goto L132
L146:
    dec_ref r181
    goto L63
L147:
    dec_ref r190
    goto L71
L148:
    dec_ref r199
    goto L132
L149:
    dec_ref r209
    goto L132
L150:
    dec_ref r219
    goto L132
L151:
    dec_ref r229
    goto L97
L152:
    dec_ref r238
    goto L132
L153:
    dec_ref r248
    goto L111
L154:
    dec_ref r257
    goto L132
L155:
    dec_ref r267
    goto L132

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('get_abi_strategy',)
    r6 = 'faster_eth_abi.tools._strategies'
    r7 = faster_eth_abi.tools.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    faster_eth_abi.tools._strategies = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: int
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: int
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: int
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = object 115792089237316195423570985008687907853269984665640564039457584007913129639936
    r10 = faster_eth_abi.constants.globals :: static
    r11 = 'TT256'
    inc_ref r9 :: int
    r12 = box(int, r9)
    r13 = CPyDict_SetItem(r10, r11, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L8 (error at <module>:5) else goto L5 :: bool
L5:
    r15 = object 115792089237316195423570985008687907853269984665640564039457584007913129639935
    r16 = faster_eth_abi.constants.globals :: static
    r17 = 'TT256M1'
    inc_ref r15 :: int
    r18 = box(int, r15)
    r19 = CPyDict_SetItem(r16, r17, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L8 (error at <module>:6) else goto L6 :: bool
L6:
    r21 = object 57896044618658097711785492504343953926634992332820282019728792003956564819968
    r22 = faster_eth_abi.constants.globals :: static
    r23 = 'TT255'
    inc_ref r21 :: int
    r24 = box(int, r21)
    r25 = CPyDict_SetItem(r22, r23, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L8 (error at <module>:7) else goto L7 :: bool
L7:
    return 1
L8:
    r27 = <error> :: None
    return r27

def encode_tuple(values, encoders):
    values, encoders :: object
    r0, r1 :: list
    r2, r3, r4, r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bytes
    r19 :: i32
    r20 :: bit
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: bytes
    r25 :: i32
    r26 :: bit
    r27 :: bytes
    r28 :: i32
    r29, r30, r31 :: bit
    r32 :: int
    r33 :: native_int
    r34 :: ptr
    r35 :: native_int
    r36 :: bit
    r37, r38 :: ptr
    r39 :: native_int
    r40 :: ptr
    r41 :: object
    r42 :: union[bytes, None]
    r43 :: object
    r44 :: bit
    r45 :: int
    r46 :: bytes
    r47 :: ptr
    r48 :: native_int
    r49 :: short_int
    r50 :: int
    r51 :: native_int
    head_length :: int
    r52 :: list
    r53 :: object
    r54, r55 :: ptr
    total_offset :: int
    r56 :: object
    r57 :: list
    r58 :: native_int
    r59 :: ptr
    r60 :: native_int
    r61 :: bit
    r62, r63 :: ptr
    r64 :: native_int
    r65 :: ptr
    r66 :: object
    r67 :: bytes
    r68 :: ptr
    r69 :: native_int
    r70 :: short_int
    r71 :: int
    r72 :: object
    r73 :: i32
    r74 :: bit
    r75 :: native_int
    r76 :: list
    r77, r78 :: native_int
    r79 :: ptr
    r80 :: native_int
    r81 :: bit
    r82 :: ptr
    r83 :: native_int
    r84 :: bit
    r85, r86 :: ptr
    r87 :: native_int
    r88 :: ptr
    r89 :: object
    r90 :: union[bytes, None]
    r91, r92 :: ptr
    r93 :: native_int
    r94 :: ptr
    r95 :: object
    r96 :: int
    r97 :: object
    r98 :: bit
    r99 :: int
    r100, r101, r102 :: bytes
    r103 :: i32
    r104 :: bit
    r105, r106 :: native_int
    r107 :: tuple
    r108, r109, r110, r111, r112, r113 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L54 (error at encode_tuple:24) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L55 (error at encode_tuple:25) else goto L2
L2:
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L56 (error at encode_tuple:26) else goto L3
L3:
    r3 = PyObject_GetIter(encoders)
    if is_error(r3) goto L57 (error at encode_tuple:26) else goto L4
L4:
    r4 = PyIter_Next(r2)
    if is_error(r4) goto L58 else goto L5
L5:
    r5 = PyIter_Next(r3)
    if is_error(r5) goto L59 else goto L6
L6:
    r6 = 'is_dynamic'
    r7 = box(bool, 0)
    r8 = CPyObject_GetAttr3(r5, r6, r7)
    if is_error(r8) goto L60 (error at encode_tuple:27) else goto L7
L7:
    r9 = PyObject_IsTrue(r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L60 (error at encode_tuple:27) else goto L8 :: bool
L8:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L9 else goto L13 :: bool
L9:
    r12 = box(None, 1)
    r13 = PyList_Append(r0, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L60 (error at encode_tuple:28) else goto L10 :: bool
L10:
    r15 = [r4]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r5, r16, 1, 0)
    dec_ref r5
    if is_error(r17) goto L61 (error at encode_tuple:29) else goto L11
L11:
    dec_ref r4
    r18 = cast(bytes, r17)
    if is_error(r18) goto L62 (error at encode_tuple:29) else goto L12
L12:
    r19 = PyList_Append(r1, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L62 (error at encode_tuple:29) else goto L4 :: bool
L13:
    r21 = [r4]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r5, r22, 1, 0)
    dec_ref r5
    if is_error(r23) goto L61 (error at encode_tuple:31) else goto L14
L14:
    dec_ref r4
    r24 = cast(bytes, r23)
    if is_error(r24) goto L62 (error at encode_tuple:31) else goto L15
L15:
    r25 = PyList_Append(r0, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L62 (error at encode_tuple:31) else goto L16 :: bool
L16:
    r27 = b''
    r28 = PyList_Append(r1, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L62 (error at encode_tuple:32) else goto L4 :: bool
L17:
    r30 = CPy_NoErrOccurred()
    if not r30 goto L56 (error at encode_tuple:26) else goto L18 :: bool
L18:
    r31 = CPy_NoErrOccurred()
    if not r31 goto L56 (error at encode_tuple:26) else goto L19 :: bool
L19:
    r32 = 0
    r33 = 0
L20:
    r34 = get_element_ptr r0 ob_size :: PyVarObject
    r35 = load_mem r34 :: native_int*
    r36 = r33 < r35 :: signed
    if r36 goto L21 else goto L28 :: bool
L21:
    r37 = get_element_ptr r0 ob_item :: PyListObject
    r38 = load_mem r37 :: ptr*
    r39 = r33 * 8
    r40 = r38 + r39
    r41 = load_mem r40 :: builtins.object*
    r42 = cast(union[bytes, None], r41)
    if is_error(r42) goto L63 (error at encode_tuple:34) else goto L22
L22:
    r43 = load_address _Py_NoneStruct
    r44 = r42 == r43
    if r44 goto L64 else goto L24 :: bool
L23:
    r45 = 64
    goto L26
L24:
    r46 = cast(bytes, r42)
    if is_error(r46) goto L63 (error at encode_tuple:34) else goto L25
L25:
    r47 = get_element_ptr r46 ob_size :: PyVarObject
    r48 = load_mem r47 :: native_int*
    dec_ref r46
    r49 = r48 << 1
    r45 = r49
L26:
    r50 = CPyTagged_Add(r32, r45)
    dec_ref r32 :: int
    dec_ref r45 :: int
    r32 = r50
L27:
    r51 = r33 + 1
    r33 = r51
    goto L20
L28:
    head_length = r32
    r52 = PyList_New(1)
    if is_error(r52) goto L65 (error at encode_tuple:35) else goto L29
L29:
    r53 = object 0
    r54 = get_element_ptr r52 ob_item :: PyListObject
    r55 = load_mem r54 :: ptr*
    inc_ref r53
    set_mem r55, r53 :: builtins.object*
    total_offset = 0
    r56 = CPyList_GetSlice(r1, 0, -2)
    if is_error(r56) goto L66 (error at encode_tuple:37) else goto L30
L30:
    r57 = cast(list, r56)
    if is_error(r57) goto L66 (error at encode_tuple:37) else goto L31
L31:
    r58 = 0
L32:
    r59 = get_element_ptr r57 ob_size :: PyVarObject
    r60 = load_mem r59 :: native_int*
    r61 = r58 < r60 :: signed
    if r61 goto L33 else goto L67 :: bool
L33:
    r62 = get_element_ptr r57 ob_item :: PyListObject
    r63 = load_mem r62 :: ptr*
    r64 = r58 * 8
    r65 = r63 + r64
    r66 = load_mem r65 :: builtins.object*
    r67 = cast(bytes, r66)
    if is_error(r67) goto L68 (error at encode_tuple:37) else goto L34
L34:
    r68 = get_element_ptr r67 ob_size :: PyVarObject
    r69 = load_mem r68 :: native_int*
    dec_ref r67
    r70 = r69 << 1
    r71 = CPyTagged_Add(total_offset, r70)
    dec_ref total_offset :: int
    total_offset = r71
    inc_ref total_offset :: int
    r72 = box(int, total_offset)
    r73 = PyList_Append(r52, r72)
    dec_ref r72
    r74 = r73 >= 0 :: signed
    if not r74 goto L68 (error at encode_tuple:39) else goto L35 :: bool
L35:
    r75 = r58 + 1
    r58 = r75
    goto L32
L36:
    r76 = PyList_New(0)
    if is_error(r76) goto L69 (error at encode_tuple:41) else goto L37
L37:
    r77 = 0
    r78 = 0
L38:
    r79 = get_element_ptr r0 ob_size :: PyVarObject
    r80 = load_mem r79 :: native_int*
    r81 = r77 < r80 :: signed
    if r81 goto L39 else goto L70 :: bool
L39:
    r82 = get_element_ptr r52 ob_size :: PyVarObject
    r83 = load_mem r82 :: native_int*
    r84 = r78 < r83 :: signed
    if r84 goto L40 else goto L70 :: bool
L40:
    r85 = get_element_ptr r0 ob_item :: PyListObject
    r86 = load_mem r85 :: ptr*
    r87 = r77 * 8
    r88 = r86 + r87
    r89 = load_mem r88 :: builtins.object*
    r90 = cast(union[bytes, None], r89)
    if is_error(r90) goto L71 (error at encode_tuple:41) else goto L41
L41:
    r91 = get_element_ptr r52 ob_item :: PyListObject
    r92 = load_mem r91 :: ptr*
    r93 = r78 * 8
    r94 = r92 + r93
    r95 = load_mem r94 :: builtins.object*
    r96 = unbox(int, r95)
    dec_ref r95
    if is_error(r96) goto L72 (error at encode_tuple:41) else goto L42
L42:
    r97 = load_address _Py_NoneStruct
    r98 = r90 == r97
    if r98 goto L73 else goto L74 :: bool
L43:
    r99 = CPyTagged_Add(head_length, r96)
    dec_ref r96 :: int
    r100 = encode_uint_256(r99)
    dec_ref r99 :: int
    if is_error(r100) goto L71 (error at encode_tuple:42) else goto L44
L44:
    r101 = r100
    goto L47
L45:
    r102 = cast(bytes, r90)
    if is_error(r102) goto L71 (error at encode_tuple:42) else goto L46
L46:
    r101 = r102
L47:
    r103 = PyList_Append(r76, r101)
    dec_ref r101
    r104 = r103 >= 0 :: signed
    if not r104 goto L71 (error at encode_tuple:41) else goto L48 :: bool
L48:
    r105 = r77 + 1
    r77 = r105
    r106 = r78 + 1
    r78 = r106
    goto L38
L49:
    r107 = PyList_AsTuple(r76)
    dec_ref r76
    if is_error(r107) goto L75 (error at encode_tuple:41) else goto L50
L50:
    r108 = b''
    r109 = CPyBytes_Join(r108, r107)
    dec_ref r107
    if is_error(r109) goto L75 (error at encode_tuple:46) else goto L51
L51:
    r110 = b''
    r111 = CPyBytes_Join(r110, r1)
    dec_ref r1
    if is_error(r111) goto L76 (error at encode_tuple:46) else goto L52
L52:
    r112 = CPyBytes_Concat(r109, r111)
    dec_ref r111
    if is_error(r112) goto L54 (error at encode_tuple:46) else goto L53
L53:
    return r112
L54:
    r113 = <error> :: bytes
    return r113
L55:
    dec_ref r0
    goto L54
L56:
    dec_ref r0
    dec_ref r1
    goto L54
L57:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L54
L58:
    dec_ref r2
    dec_ref r3
    goto L17
L59:
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L17
L60:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    goto L54
L61:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L54
L62:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L54
L63:
    dec_ref r0
    dec_ref r1
    dec_ref r32 :: int
    goto L54
L64:
    dec_ref r42
    goto L23
L65:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    goto L54
L66:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref total_offset :: int
    goto L54
L67:
    dec_ref total_offset :: int
    dec_ref r57
    goto L36
L68:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref total_offset :: int
    dec_ref r57
    goto L54
L69:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    goto L54
L70:
    dec_ref r0
    dec_ref head_length :: int
    dec_ref r52
    goto L49
L71:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref r76
    goto L54
L72:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref r76
    dec_ref r90
    goto L54
L73:
    dec_ref r90
    goto L43
L74:
    dec_ref r96 :: int
    goto L45
L75:
    dec_ref r1
    goto L54
L76:
    dec_ref r109
    goto L54

def encode_fixed(value, encode_fn, is_big_endian, data_byte_size):
    value, encode_fn :: object
    is_big_endian :: bool
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3, r4 :: bytes
    r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bytes
    r12 :: str
    r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L9 (error at encode_fixed:55) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L9 (error at encode_fixed:55) else goto L2
L2:
    if is_big_endian goto L3 else goto L6 :: bool
L3:
    r4 = b'\x00'
    r5 = 'rjust'
    inc_ref data_byte_size :: int
    r6 = box(int, data_byte_size)
    r7 = [r3, r6, r4]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r5, r8, 9223372036854775811, 0)
    if is_error(r9) goto L10 (error at encode_fixed:57) else goto L4
L4:
    dec_ref r3
    dec_ref r6
    r10 = cast(bytes, r9)
    if is_error(r10) goto L9 (error at encode_fixed:57) else goto L5
L5:
    return r10
L6:
    r11 = b'\x00'
    r12 = 'ljust'
    inc_ref data_byte_size :: int
    r13 = box(int, data_byte_size)
    r14 = [r3, r13, r11]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r12, r15, 9223372036854775811, 0)
    if is_error(r16) goto L11 (error at encode_fixed:59) else goto L7
L7:
    dec_ref r3
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at encode_fixed:59) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r3
    dec_ref r6
    goto L9
L11:
    dec_ref r3
    dec_ref r13
    goto L9

def encode_signed(value, encode_fn, data_byte_size):
    value, encode_fn :: object
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3 :: bytes
    r4, r5 :: object
    r6 :: bool
    r7 :: bytes
    r8 :: str
    r9 :: object
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L11 (error at encode_signed:67) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L11 (error at encode_signed:67) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(value, r4, 5)
    if is_error(r5) goto L12 (error at encode_signed:68) else goto L3
L3:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L12 (error at encode_signed:68) else goto L4
L4:
    if r6 goto L5 else goto L8 :: bool
L5:
    r7 = b'\x00'
    r8 = 'rjust'
    inc_ref data_byte_size :: int
    r9 = box(int, data_byte_size)
    r10 = [r3, r9, r7]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r8, r11, 9223372036854775811, 0)
    if is_error(r12) goto L13 (error at encode_signed:69) else goto L6
L6:
    dec_ref r3
    dec_ref r9
    r13 = cast(bytes, r12)
    if is_error(r13) goto L11 (error at encode_signed:69) else goto L7
L7:
    return r13
L8:
    r14 = b'\xff'
    r15 = 'rjust'
    inc_ref data_byte_size :: int
    r16 = box(int, data_byte_size)
    r17 = [r3, r16, r14]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r15, r18, 9223372036854775811, 0)
    if is_error(r19) goto L14 (error at encode_signed:71) else goto L9
L9:
    dec_ref r3
    dec_ref r16
    r20 = cast(bytes, r19)
    if is_error(r20) goto L11 (error at encode_signed:71) else goto L10
L10:
    return r20
L11:
    r21 = <error> :: bytes
    return r21
L12:
    dec_ref r3
    goto L11
L13:
    dec_ref r3
    dec_ref r9
    goto L11
L14:
    dec_ref r3
    dec_ref r16
    goto L11

def encode_elements(item_encoder, value):
    item_encoder, value :: object
    r0 :: list
    r1, r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bytes
    r7 :: i32
    r8, r9 :: bit
    r10 :: tuple
    r11 :: str
    r12, r13 :: object
    r14 :: bool
    r15 :: int
    r16 :: bit
    r17, r18 :: bytes
    r19, r20 :: int
    r21 :: list
    r22 :: object
    r23, r24 :: ptr
    total_offset :: int
    r25 :: object
    r26 :: tuple
    r27 :: ptr
    r28, r29 :: native_int
    r30 :: bit
    r31 :: object
    r32 :: bytes
    r33 :: ptr
    r34 :: native_int
    r35 :: short_int
    r36 :: int
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: native_int
    r41 :: ptr
    r42 :: native_int
    r43 :: tuple
    r44 :: native_int
    r45 :: ptr
    r46 :: native_int
    r47 :: bit
    r48, r49 :: ptr
    r50 :: native_int
    r51 :: ptr
    r52 :: object
    r53, r54 :: int
    r55 :: bytes
    r56 :: native_int
    r57, r58, r59, r60, r61, r62 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L35 (error at encode_elements:75) else goto L1
L1:
    r1 = PyObject_GetIter(value)
    if is_error(r1) goto L36 (error at encode_elements:75) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L37 else goto L3
L3:
    r3 = [r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(item_encoder, r4, 1, 0)
    if is_error(r5) goto L38 (error at encode_elements:75) else goto L4
L4:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L39 (error at encode_elements:75) else goto L5
L5:
    r7 = PyList_Append(r0, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L39 (error at encode_elements:75) else goto L2 :: bool
L6:
    r9 = CPy_NoErrOccurred()
    if not r9 goto L36 (error at encode_elements:75) else goto L7 :: bool
L7:
    r10 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r10) goto L35 (error at encode_elements:75) else goto L8
L8:
    r11 = 'is_dynamic'
    r12 = box(bool, 0)
    r13 = CPyObject_GetAttr3(item_encoder, r11, r12)
    if is_error(r13) goto L40 (error at encode_elements:77) else goto L9
L9:
    r14 = unbox(bool, r13)
    dec_ref r13
    if is_error(r14) goto L40 (error at encode_elements:77) else goto L10
L10:
    if r14 goto L11 else goto L13 :: bool
L11:
    r15 = CPyObject_Size(value)
    if is_error(r15) goto L40 (error at encode_elements:78) else goto L12
L12:
    r16 = r15 == 0
    dec_ref r15 :: int
    if r16 goto L13 else goto L15 :: bool
L13:
    r17 = b''
    r18 = CPyBytes_Join(r17, r10)
    dec_ref r10
    if is_error(r18) goto L35 (error at encode_elements:79) else goto L14
L14:
    return r18
L15:
    r19 = CPyObject_Size(value)
    if is_error(r19) goto L40 (error at encode_elements:81) else goto L16
L16:
    r20 = CPyTagged_Multiply(64, r19)
    dec_ref r19 :: int
    r21 = PyList_New(1)
    if is_error(r21) goto L41 (error at encode_elements:82) else goto L17
L17:
    r22 = object 0
    r23 = get_element_ptr r21 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    inc_ref r22
    set_mem r24, r22 :: builtins.object*
    total_offset = 0
    r25 = CPySequenceTuple_GetSlice(r10, 0, -2)
    if is_error(r25) goto L42 (error at encode_elements:84) else goto L18
L18:
    r26 = cast(tuple, r25)
    if is_error(r26) goto L42 (error at encode_elements:84) else goto L19
L19:
    r27 = get_element_ptr r26 ob_size :: PyVarObject
    r28 = load_mem r27 :: native_int*
    r29 = 0
L20:
    r30 = r29 < r28 :: signed
    if r30 goto L21 else goto L43 :: bool
L21:
    r31 = CPySequenceTuple_GetItemUnsafe(r26, r29)
    r32 = cast(bytes, r31)
    if is_error(r32) goto L44 (error at encode_elements:84) else goto L22
L22:
    r33 = get_element_ptr r32 ob_size :: PyVarObject
    r34 = load_mem r33 :: native_int*
    dec_ref r32
    r35 = r34 << 1
    r36 = CPyTagged_Add(total_offset, r35)
    dec_ref total_offset :: int
    total_offset = r36
    inc_ref total_offset :: int
    r37 = box(int, total_offset)
    r38 = PyList_Append(r21, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L44 (error at encode_elements:86) else goto L23 :: bool
L23:
    r40 = r29 + 1
    r29 = r40
    goto L20
L24:
    r41 = get_element_ptr r21 ob_size :: PyVarObject
    r42 = load_mem r41 :: native_int*
    r43 = PyTuple_New(r42)
    if is_error(r43) goto L45 (error at encode_elements:88) else goto L25
L25:
    r44 = 0
L26:
    r45 = get_element_ptr r21 ob_size :: PyVarObject
    r46 = load_mem r45 :: native_int*
    r47 = r44 < r46 :: signed
    if r47 goto L27 else goto L46 :: bool
L27:
    r48 = get_element_ptr r21 ob_item :: PyListObject
    r49 = load_mem r48 :: ptr*
    r50 = r44 * 8
    r51 = r49 + r50
    r52 = load_mem r51 :: builtins.object*
    r53 = unbox(int, r52)
    dec_ref r52
    if is_error(r53) goto L47 (error at encode_elements:88) else goto L28
L28:
    r54 = CPyTagged_Add(r20, r53)
    dec_ref r53 :: int
    r55 = encode_uint_256(r54)
    dec_ref r54 :: int
    if is_error(r55) goto L47 (error at encode_elements:89) else goto L29
L29:
    CPySequenceTuple_SetItemUnsafe(r43, r44, r55)
L30:
    r56 = r44 + 1
    r44 = r56
    goto L26
L31:
    r57 = b''
    r58 = CPyBytes_Join(r57, r43)
    dec_ref r43
    if is_error(r58) goto L40 (error at encode_elements:91) else goto L32
L32:
    r59 = b''
    r60 = CPyBytes_Join(r59, r10)
    dec_ref r10
    if is_error(r60) goto L48 (error at encode_elements:91) else goto L33
L33:
    r61 = CPyBytes_Concat(r58, r60)
    dec_ref r60
    if is_error(r61) goto L35 (error at encode_elements:91) else goto L34
L34:
    return r61
L35:
    r62 = <error> :: bytes
    return r62
L36:
    dec_ref r0
    goto L35
L37:
    dec_ref r1
    goto L6
L38:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L35
L39:
    dec_ref r0
    dec_ref r1
    goto L35
L40:
    dec_ref r10
    goto L35
L41:
    dec_ref r10
    dec_ref r20 :: int
    goto L35
L42:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref total_offset :: int
    goto L35
L43:
    dec_ref total_offset :: int
    dec_ref r26
    goto L24
L44:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref total_offset :: int
    dec_ref r26
    goto L35
L45:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    goto L35
L46:
    dec_ref r20 :: int
    dec_ref r21
    goto L31
L47:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref r43
    goto L35
L48:
    dec_ref r58
    goto L35

def encode_elements_dynamic(item_encoder, value):
    item_encoder, value :: object
    r0 :: int
    r1, r2, r3, r4 :: bytes
L0:
    r0 = CPyObject_Size(value)
    if is_error(r0) goto L5 (error at encode_elements_dynamic:95) else goto L1
L1:
    r1 = encode_uint_256(r0)
    dec_ref r0 :: int
    if is_error(r1) goto L5 (error at encode_elements_dynamic:95) else goto L2
L2:
    r2 = encode_elements(item_encoder, value)
    if is_error(r2) goto L6 (error at encode_elements_dynamic:96) else goto L3
L3:
    r3 = CPyBytes_Concat(r1, r2)
    dec_ref r2
    if is_error(r3) goto L5 (error at encode_elements_dynamic:97) else goto L4
L4:
    return r3
L5:
    r4 = <error> :: bytes
    return r4
L6:
    dec_ref r1
    goto L5

def encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = int_to_big_endian(i)
    if is_error(r0) goto L4 (error at encode_uint_256:104) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at encode_uint_256:105) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at encode_uint_256:105) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at int_to_big_endian:110) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at int_to_big_endian:110) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at int_to_big_endian:110) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at int_to_big_endian:110) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: str
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L9 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Callable', 'List', 'Optional', 'Sequence', 'TypeVar')
    r6 = 'typing'
    r7 = faster_eth_abi._encoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L9 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    if 0 goto L5 else goto L5 :: bool
L5:
    r9 = 'T'
    r10 = faster_eth_abi._encoding.globals :: static
    r11 = 'TypeVar'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L9 (error at <module>:17) else goto L6
L6:
    r13 = [r9]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L9 (error at <module>:17) else goto L7
L7:
    r16 = faster_eth_abi._encoding.globals :: static
    r17 = 'T'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L9 (error at <module>:17) else goto L8 :: bool
L8:
    return 1
L9:
    r20 = <error> :: None
    return r20

def encode_c(self, types, args):
    self, types, args :: object
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11, r12 :: bytes
L0:
    r0 = 'args'
    r1 = validate_list_like_param(args, r0)
    if is_error(r1) goto L8 (error at encode_c:42) else goto L1
L1:
    r2 = '_registry'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L8 (error at encode_c:44) else goto L2
L2:
    r4 = 'get_tuple_encoder'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L8 (error at encode_c:44) else goto L3
L3:
    r6 = PySequence_Tuple(types)
    if is_error(r6) goto L9 (error at encode_c:44) else goto L4
L4:
    r7 = PyObject_CallObject(r5, r6)
    dec_ref r5
    dec_ref r6
    if is_error(r7) goto L8 (error at encode_c:44) else goto L5
L5:
    r8 = [args]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L8 (error at encode_c:46) else goto L6
L6:
    r11 = cast(bytes, r10)
    if is_error(r11) goto L8 (error at encode_c:46) else goto L7
L7:
    return r11
L8:
    r12 = <error> :: bytes
    return r12
L9:
    dec_ref r5
    goto L8

def decode_c(self, types, data, strict):
    self, types :: object
    data :: union[bytes, object]
    strict :: bool
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: str
    r9 :: tuple
    r10 :: object
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: tuple
L0:
    if is_error(strict) goto L1 else goto L2
L1:
    strict = 1
L2:
    r0 = 'data'
    r1 = validate_bytes_param(data, r0)
    if is_error(r1) goto L14 (error at decode_c:72) else goto L3
L3:
    r2 = '_registry'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L14 (error at decode_c:74) else goto L4
L4:
    r4 = 'get_tuple_decoder'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L14 (error at decode_c:74) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L15 (error at decode_c:74) else goto L6
L6:
    r7 = CPyList_Extend(r6, types)
    if is_error(r7) goto L16 (error at decode_c:74) else goto L17
L7:
    r8 = 'strict'
    r9 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r9) goto L15 (error at decode_c:74) else goto L8
L8:
    r10 = box(bool, strict)
    r11 = CPyDict_Build(1, r8, r10)
    if is_error(r11) goto L18 (error at decode_c:74) else goto L9
L9:
    r12 = PyObject_Call(r5, r9, r11)
    dec_ref r5
    dec_ref r9
    dec_ref r11
    if is_error(r12) goto L14 (error at decode_c:74) else goto L10
L10:
    r13 = 'stream_class'
    r14 = [self, data]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L19 (error at decode_c:75) else goto L11
L11:
    r17 = [r16]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r12, r18, 1, 0)
    dec_ref r12
    if is_error(r19) goto L20 (error at decode_c:77) else goto L12
L12:
    dec_ref r16
    r20 = cast(tuple, r19)
    if is_error(r20) goto L14 (error at decode_c:77) else goto L13
L13:
    return r20
L14:
    r21 = <error> :: tuple
    return r21
L15:
    dec_ref r5
    goto L14
L16:
    dec_ref r5
    dec_ref r6
    goto L14
L17:
    dec_ref r7
    goto L7
L18:
    dec_ref r5
    dec_ref r9
    goto L14
L19:
    dec_ref r12
    goto L14
L20:
    dec_ref r16
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Iterable', 'Tuple')
    r6 = 'typing'
    r7 = faster_eth_abi._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('Decodable', 'TypeStr')
    r10 = 'eth_typing'
    r11 = faster_eth_abi._codec.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L8 (error at <module>:8) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('validate_bytes_param', 'validate_list_like_param')
    r14 = 'faster_eth_abi.utils.validation'
    r15 = faster_eth_abi._codec.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L8 (error at <module>:13) else goto L6
L6:
    faster_eth_abi.utils.validation = r16 :: module
    dec_ref r16
    if 0 goto L7 else goto L7 :: bool
L7:
    return 1
L8:
    r17 = <error> :: None
    return r17

def zpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad:2) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad:2) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad(value, 64)
    if is_error(r0) goto L2 (error at zpad32:6) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def zpad_right(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'ljust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad_right:10) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad_right:10) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32_right(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad_right(value, 64)
    if is_error(r0) goto L2 (error at zpad32_right:14) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def fpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\xff'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at fpad:18) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at fpad:18) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def fpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = fpad(value, 64)
    if is_error(r0) goto L2 (error at fpad32:22) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: bool
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: bool
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L31 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L31 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABICodec',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L31 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L31 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.abi.globals :: static
    r18 = 'registry'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L31 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.abi.globals :: static
    r21 = 'ABICodec'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L32 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L32 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.abi.default_codec = r25 :: static
    r26 = faster_eth_abi.abi.globals :: static
    r27 = 'default_codec'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L31 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.abi.default_codec :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_codec" was not set')
    if not r31 goto L31 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L31 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.abi.encode = r33 :: static
    r34 = faster_eth_abi.abi.globals :: static
    r35 = 'encode'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L31 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.abi.default_codec :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_codec" was not set')
    if not r39 goto L31 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'decode'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L31 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.abi.decode = r41 :: static
    r42 = faster_eth_abi.abi.globals :: static
    r43 = 'decode'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L31 (error at <module>:15) else goto L20 :: bool
L20:
    r46 = faster_eth_abi.abi.default_codec :: static
    if is_error(r46) goto L21 else goto L23
L21:
    r47 = raise NameError('value for final name "default_codec" was not set')
    if not r47 goto L31 (error at <module>:16) else goto L22 :: bool
L22:
    unreachable
L23:
    r48 = 'is_encodable'
    r49 = CPyObject_GetAttr(r46, r48)
    if is_error(r49) goto L31 (error at <module>:16) else goto L24
L24:
    faster_eth_abi.abi.is_encodable = r49 :: static
    r50 = faster_eth_abi.abi.globals :: static
    r51 = 'is_encodable'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L31 (error at <module>:16) else goto L25 :: bool
L25:
    r54 = faster_eth_abi.abi.default_codec :: static
    if is_error(r54) goto L26 else goto L28
L26:
    r55 = raise NameError('value for final name "default_codec" was not set')
    if not r55 goto L31 (error at <module>:17) else goto L27 :: bool
L27:
    unreachable
L28:
    r56 = 'is_encodable_type'
    r57 = CPyObject_GetAttr(r54, r56)
    if is_error(r57) goto L31 (error at <module>:17) else goto L29
L29:
    faster_eth_abi.abi.is_encodable_type = r57 :: static
    r58 = faster_eth_abi.abi.globals :: static
    r59 = 'is_encodable_type'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L31 (error at <module>:17) else goto L30 :: bool
L30:
    return 1
L31:
    r62 = <error> :: None
    return r62
L32:
    dec_ref r19
    goto L31

def new_from_type_str_parse_type_str_decorator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_type_str_decorator_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2 :: str
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, type_str_repr :: str
    r10 :: bool
    r11 :: bit
    r12, r13, r14, r15 :: str
    r16 :: object[3]
    r17 :: object_ptr
    r18 :: object
    r19, r20, r21, r22, r23 :: str
    r24 :: object[3]
    r25 :: object_ptr
    r26 :: object
    r27, r28 :: str
    r29 :: list
    r30, r31, r32, r33, r34 :: ptr
    r35 :: str
    r36 :: union[str, None]
    r37 :: object
    r38 :: bit
    r39 :: object
    r40 :: bool
    r41 :: object
    r42, r43, r44, r45 :: str
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: faster_eth_abi._grammar.BasicType
    r53 :: str
    r54 :: union[str, None]
    r55 :: str
    r56 :: bool
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: union[str, None]
    r61, r62, r63, r64, r65, r66 :: str
    r67 :: object
    r68 :: str
    r69 :: object
    r70 :: object[1]
    r71 :: object_ptr
    r72 :: object
    r73 :: bool
    r74 :: str
    r75, r76 :: object
    r77 :: bit
    r78 :: object
    r79, r80, r81, r82, r83 :: str
    r84 :: object
    r85 :: str
    r86 :: object
    r87 :: object[1]
    r88 :: object_ptr
    r89 :: object
    r90 :: bool
    r91 :: str
    r92, r93 :: object
    r94 :: bit
    r95 :: object
    r96, r97, r98, r99, r100 :: str
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: object[1]
    r105 :: object_ptr
    r106 :: object
    r107 :: str
    r108 :: object[1]
    r109 :: object_ptr
    r110, r111 :: object
    r112 :: object[3]
    r113 :: object_ptr
    r114, r115 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L64 (error at new_from_type_str:50) else goto L1
L1:
    r1 = r0.__mypyc_env__
    if is_error(r1) goto L65 (error at new_from_type_str:50) else goto L2
L2:
    r2 = normalize(type_str)
    if is_error(r2) goto L66 (error at new_from_type_str:51) else goto L3
L3:
    r3 = faster_eth_abi.from_type_str.globals :: static
    r4 = 'parse'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L67 (error at new_from_type_str:52) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L67 (error at new_from_type_str:52) else goto L5
L5:
    r9 = PyObject_Repr(type_str)
    if is_error(r9) goto L68 (error at new_from_type_str:54) else goto L6
L6:
    type_str_repr = r9
    r10 = CPyStr_Equal(type_str, r2)
    r11 = r10 == 0
    if r11 goto L7 else goto L69 :: bool
L7:
    r12 = ''
    r13 = '{:{}}'
    r14 = ''
    r15 = 'format'
    r16 = [r13, type_str_repr, r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775811, 0)
    if is_error(r18) goto L70 (error at new_from_type_str:57) else goto L8
L8:
    dec_ref type_str_repr
    r19 = cast(str, r18)
    if is_error(r19) goto L68 (error at new_from_type_str:57) else goto L9
L9:
    r20 = ' (normalized to '
    r21 = '{!r:{}}'
    r22 = ''
    r23 = 'format'
    r24 = [r21, r2, r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775811, 0)
    if is_error(r26) goto L71 (error at new_from_type_str:57) else goto L10
L10:
    dec_ref r2
    r27 = cast(str, r26)
    if is_error(r27) goto L72 (error at new_from_type_str:57) else goto L11
L11:
    r28 = ')'
    r29 = PyList_New(4)
    if is_error(r29) goto L73 (error at new_from_type_str:57) else goto L12
L12:
    r30 = get_element_ptr r29 ob_item :: PyListObject
    r31 = load_mem r30 :: ptr*
    set_mem r31, r19 :: builtins.object*
    inc_ref r20
    r32 = r31 + 8
    set_mem r32, r20 :: builtins.object*
    r33 = r31 + 16
    set_mem r33, r27 :: builtins.object*
    inc_ref r28
    r34 = r31 + 24
    set_mem r34, r28 :: builtins.object*
    r35 = PyUnicode_Join(r12, r29)
    dec_ref r29
    if is_error(r35) goto L74 (error at new_from_type_str:57) else goto L13
L13:
    type_str_repr = r35
L14:
    r36 = r1.expected_base
    if is_error(r36) goto L75 (error at new_from_type_str:60) else goto L15
L15:
    r37 = load_address _Py_NoneStruct
    r38 = r36 != r37
    dec_ref r36
    if r38 goto L16 else goto L38 :: bool
L16:
    r39 = faster_eth_abi._grammar.BasicType :: type
    r40 = CPy_TypeCheck(r8, r39)
    if r40 goto L24 else goto L76 :: bool
L17:
    r41 = CPy_GetName(cls)
    if is_error(r41) goto L77 (error at new_from_type_str:64) else goto L18
L18:
    r42 = cast(str, r41)
    if is_error(r42) goto L77 (error at new_from_type_str:64) else goto L19
L19:
    r43 = 'Cannot create '
    r44 = ' for non-basic type '
    r45 = CPyStr_Build(4, r43, r42, r44, type_str_repr)
    dec_ref r42
    dec_ref type_str_repr
    if is_error(r45) goto L64 (error at new_from_type_str:63) else goto L20
L20:
    r46 = builtins :: module
    r47 = 'ValueError'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L78 (error at new_from_type_str:62) else goto L21
L21:
    r49 = [r45]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 1, 0)
    dec_ref r48
    if is_error(r51) goto L78 (error at new_from_type_str:62) else goto L22
L22:
    dec_ref r45
    CPy_Raise(r51)
    dec_ref r51
    if not 0 goto L64 (error at new_from_type_str:62) else goto L23 :: bool
L23:
    unreachable
L24:
    r52 = borrow cast(faster_eth_abi._grammar.BasicType, r8)
    if is_error(r52) goto L75 (error at new_from_type_str:68) else goto L25
L25:
    r53 = r52.base
    if is_error(r53) goto L75 (error at new_from_type_str:68) else goto L26
L26:
    r54 = r1.expected_base
    if is_error(r54) goto L79 (error at new_from_type_str:68) else goto L27
L27:
    r55 = cast(str, r54)
    if is_error(r55) goto L79 (error at new_from_type_str:68) else goto L28
L28:
    r56 = CPyStr_Equal(r53, r55)
    dec_ref r53
    dec_ref r55
    r57 = r56 == 0
    if r57 goto L80 else goto L38 :: bool
L29:
    r58 = CPy_GetName(cls)
    if is_error(r58) goto L81 (error at new_from_type_str:72) else goto L30
L30:
    r59 = cast(str, r58)
    if is_error(r59) goto L81 (error at new_from_type_str:72) else goto L31
L31:
    r60 = r1.expected_base
    dec_ref r1
    if is_error(r60) goto L82 (error at new_from_type_str:74) else goto L32
L32:
    r61 = cast(str, r60)
    if is_error(r61) goto L82 (error at new_from_type_str:74) else goto L33
L33:
    r62 = 'Cannot create '
    r63 = ' for type '
    r64 = ": expected type with base '"
    r65 = "'"
    r66 = CPyStr_Build(7, r62, r59, r63, type_str_repr, r64, r61, r65)
    dec_ref r59
    dec_ref type_str_repr
    dec_ref r61
    if is_error(r66) goto L64 (error at new_from_type_str:70) else goto L34
L34:
    r67 = builtins :: module
    r68 = 'ValueError'
    r69 = CPyObject_GetAttr(r67, r68)
    if is_error(r69) goto L83 (error at new_from_type_str:69) else goto L35
L35:
    r70 = [r66]
    r71 = load_address r70
    r72 = PyObject_Vectorcall(r69, r71, 1, 0)
    dec_ref r69
    if is_error(r72) goto L83 (error at new_from_type_str:69) else goto L36
L36:
    dec_ref r66
    CPy_Raise(r72)
    dec_ref r72
    if not 0 goto L64 (error at new_from_type_str:69) else goto L37 :: bool
L37:
    unreachable
L38:
    r73 = r1.with_arrlist
    if is_error(r73) goto L75 (error at new_from_type_str:78) else goto L39
L39:
    if r73 goto L49 else goto L40 :: bool
L40:
    r74 = 'arrlist'
    r75 = CPyObject_GetAttr(r8, r74)
    if is_error(r75) goto L75 (error at new_from_type_str:78) else goto L41
L41:
    r76 = load_address _Py_NoneStruct
    r77 = r75 != r76
    dec_ref r75
    if r77 goto L84 else goto L49 :: bool
L42:
    r78 = CPy_GetName(cls)
    if is_error(r78) goto L77 (error at new_from_type_str:82) else goto L43
L43:
    r79 = cast(str, r78)
    if is_error(r79) goto L77 (error at new_from_type_str:82) else goto L44
L44:
    r80 = 'Cannot create '
    r81 = ' for type '
    r82 = ': expected type with no array dimension list'
    r83 = CPyStr_Build(5, r80, r79, r81, type_str_repr, r82)
    dec_ref r79
    dec_ref type_str_repr
    if is_error(r83) goto L64 (error at new_from_type_str:80) else goto L45
L45:
    r84 = builtins :: module
    r85 = 'ValueError'
    r86 = CPyObject_GetAttr(r84, r85)
    if is_error(r86) goto L85 (error at new_from_type_str:79) else goto L46
L46:
    r87 = [r83]
    r88 = load_address r87
    r89 = PyObject_Vectorcall(r86, r88, 1, 0)
    dec_ref r86
    if is_error(r89) goto L85 (error at new_from_type_str:79) else goto L47
L47:
    dec_ref r83
    CPy_Raise(r89)
    dec_ref r89
    if not 0 goto L64 (error at new_from_type_str:79) else goto L48 :: bool
L48:
    unreachable
L49:
    r90 = r1.with_arrlist
    dec_ref r1
    if is_error(r90) goto L86 (error at new_from_type_str:86) else goto L50
L50:
    if r90 goto L51 else goto L87 :: bool
L51:
    r91 = 'arrlist'
    r92 = CPyObject_GetAttr(r8, r91)
    if is_error(r92) goto L86 (error at new_from_type_str:86) else goto L52
L52:
    r93 = load_address _Py_NoneStruct
    r94 = r92 == r93
    dec_ref r92
    if r94 goto L88 else goto L87 :: bool
L53:
    r95 = CPy_GetName(cls)
    if is_error(r95) goto L77 (error at new_from_type_str:90) else goto L54
L54:
    r96 = cast(str, r95)
    if is_error(r96) goto L77 (error at new_from_type_str:90) else goto L55
L55:
    r97 = 'Cannot create '
    r98 = ' for type '
    r99 = ': expected type with array dimension list'
    r100 = CPyStr_Build(5, r97, r96, r98, type_str_repr, r99)
    dec_ref r96
    dec_ref type_str_repr
    if is_error(r100) goto L64 (error at new_from_type_str:88) else goto L56
L56:
    r101 = builtins :: module
    r102 = 'ValueError'
    r103 = CPyObject_GetAttr(r101, r102)
    if is_error(r103) goto L89 (error at new_from_type_str:87) else goto L57
L57:
    r104 = [r100]
    r105 = load_address r104
    r106 = PyObject_Vectorcall(r103, r105, 1, 0)
    dec_ref r103
    if is_error(r106) goto L89 (error at new_from_type_str:87) else goto L58
L58:
    dec_ref r100
    CPy_Raise(r106)
    dec_ref r106
    if not 0 goto L64 (error at new_from_type_str:87) else goto L59 :: bool
L59:
    unreachable
L60:
    r107 = 'validate'
    r108 = [r8]
    r109 = load_address r108
    r110 = PyObject_VectorcallMethod(r107, r109, 9223372036854775809, 0)
    if is_error(r110) goto L90 (error at new_from_type_str:96) else goto L91
L61:
    r111 = r0.old_from_type_str
    dec_ref r0
    if is_error(r111) goto L92 (error at new_from_type_str:98) else goto L62
L62:
    r112 = [cls, r8, registry]
    r113 = load_address r112
    r114 = PyObject_Vectorcall(r111, r113, 3, 0)
    dec_ref r111
    if is_error(r114) goto L92 (error at new_from_type_str:98) else goto L63
L63:
    dec_ref r8
    return r114
L64:
    r115 = <error> :: object
    return r115
L65:
    dec_ref r0
    goto L64
L66:
    dec_ref r0
    dec_ref r1
    goto L64
L67:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L64
L68:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r8
    goto L64
L69:
    dec_ref r2
    goto L14
L70:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r8
    dec_ref type_str_repr
    goto L64
L71:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r8
    dec_ref r19
    goto L64
L72:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r19
    goto L64
L73:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r19
    dec_ref r27
    goto L64
L74:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L64
L75:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref type_str_repr
    goto L64
L76:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L17
L77:
    dec_ref type_str_repr
    goto L64
L78:
    dec_ref r45
    goto L64
L79:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref type_str_repr
    dec_ref r53
    goto L64
L80:
    dec_ref r0
    dec_ref r8
    goto L29
L81:
    dec_ref r1
    dec_ref type_str_repr
    goto L64
L82:
    dec_ref type_str_repr
    dec_ref r59
    goto L64
L83:
    dec_ref r66
    goto L64
L84:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L42
L85:
    dec_ref r83
    goto L64
L86:
    dec_ref r0
    dec_ref r8
    dec_ref type_str_repr
    goto L64
L87:
    dec_ref type_str_repr
    goto L60
L88:
    dec_ref r0
    dec_ref r8
    goto L53
L89:
    dec_ref r100
    goto L64
L90:
    dec_ref r0
    dec_ref r8
    goto L64
L91:
    dec_ref r110
    goto L61
L92:
    dec_ref r8
    goto L64

def decorator_parse_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def decorator_parse_type_str_obj.__call__(__mypyc_self__, old_from_type_str):
    __mypyc_self__ :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    r5 :: bool
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L14 (error at decorator:48) else goto L1
L1:
    r1 = decorator_parse_type_str_env()
    if is_error(r1) goto L15 (error at decorator:48) else goto L2
L2:
    r1.__mypyc_env__ = r0; r2 = is_error
    if not r2 goto L16 (error at decorator:48) else goto L3 :: bool
L3:
    inc_ref old_from_type_str
    r1.old_from_type_str = old_from_type_str; r3 = is_error
    if not r3 goto L16 (error at decorator:48) else goto L4 :: bool
L4:
    r4 = new_from_type_str_parse_type_str_decorator_obj()
    if is_error(r4) goto L16 (error at decorator:50) else goto L5
L5:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L17 (error at decorator:50) else goto L6 :: bool
L6:
    r6 = r1.old_from_type_str
    dec_ref r1
    if is_error(r6) goto L18 (error at decorator:49) else goto L7
L7:
    r7 = functools :: module
    r8 = 'wraps'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L19 (error at decorator:49) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L19 (error at decorator:49) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L18 (error at decorator:50) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = faster_eth_abi.from_type_str.globals :: static
    r17 = 'new_from_type_str'
    r18 = PyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at decorator:50) else goto L11 :: bool
L11:
    r20 = builtins :: module
    r21 = 'classmethod'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L20 (error at decorator:100) else goto L12
L12:
    r23 = [r15]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L20 (error at decorator:100) else goto L13
L13:
    dec_ref r15
    return r25
L14:
    r26 = <error> :: object
    return r26
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r1
    goto L14
L17:
    dec_ref r1
    dec_ref r4
    goto L14
L18:
    dec_ref r4
    goto L14
L19:
    dec_ref r4
    dec_ref r6
    goto L14
L20:
    dec_ref r15
    goto L14

def parse_type_str(expected_base, with_arrlist):
    expected_base :: union[str, None]
    with_arrlist :: bool
    r0 :: object
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    r5 :: bool
    decorator, r6 :: object
L0:
    if is_error(expected_base) goto L1 else goto L11
L1:
    r0 = box(None, 1)
    inc_ref r0
    expected_base = r0
L2:
    if is_error(with_arrlist) goto L3 else goto L4
L3:
    with_arrlist = 0
L4:
    r1 = parse_type_str_env()
    if is_error(r1) goto L12 (error at parse_type_str:37) else goto L5
L5:
    r1.expected_base = expected_base; r2 = is_error
    if not r2 goto L13 (error at parse_type_str:37) else goto L6 :: bool
L6:
    r1.with_arrlist = with_arrlist; r3 = is_error
    if not r3 goto L13 (error at parse_type_str:37) else goto L7 :: bool
L7:
    r4 = decorator_parse_type_str_obj()
    if is_error(r4) goto L13 (error at parse_type_str:48) else goto L8
L8:
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at parse_type_str:48) else goto L9 :: bool
L9:
    decorator = r4
    return decorator
L10:
    r6 = <error> :: object
    return r6
L11:
    inc_ref expected_base
    goto L2
L12:
    dec_ref expected_base
    goto L10
L13:
    dec_ref r1
    goto L10
L14:
    dec_ref r4
    goto L10

def new_from_type_str_parse_tuple_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_tuple_type_str_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: str
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: bool
    r10, type_str_repr :: str
    r11 :: bool
    r12 :: bit
    r13, r14, r15, r16 :: str
    r17 :: object
    r18, r19, r20, r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: faster_eth_abi._grammar.TupleType
    r29 :: None
    r30 :: faster_eth_abi._grammar.TupleType
    r31 :: object
    r32 :: object[3]
    r33 :: object_ptr
    r34, r35 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L23 (error at new_from_type_str:115) else goto L1
L1:
    r1 = normalize(type_str)
    if is_error(r1) goto L24 (error at new_from_type_str:116) else goto L2
L2:
    r2 = faster_eth_abi.from_type_str.globals :: static
    r3 = 'parse'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L25 (error at new_from_type_str:117) else goto L3
L3:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L25 (error at new_from_type_str:117) else goto L4
L4:
    r8 = faster_eth_abi._grammar.TupleType :: type
    r9 = CPy_TypeCheck(r7, r8)
    if r9 goto L26 else goto L27 :: bool
L5:
    r10 = PyObject_Repr(type_str)
    if is_error(r10) goto L28 (error at new_from_type_str:120) else goto L6
L6:
    type_str_repr = r10
    r11 = CPyStr_Equal(type_str, r1)
    r12 = r11 == 0
    if r12 goto L7 else goto L29 :: bool
L7:
    r13 = PyObject_Repr(r1)
    dec_ref r1
    if is_error(r13) goto L30 (error at new_from_type_str:124) else goto L8
L8:
    r14 = ' (normalized to '
    r15 = ')'
    r16 = CPyStr_Build(4, type_str_repr, r14, r13, r15)
    dec_ref type_str_repr
    dec_ref r13
    if is_error(r16) goto L23 (error at new_from_type_str:122) else goto L9
L9:
    type_str_repr = r16
L10:
    r17 = CPy_GetName(cls)
    if is_error(r17) goto L30 (error at new_from_type_str:128) else goto L11
L11:
    r18 = cast(str, r17)
    if is_error(r18) goto L30 (error at new_from_type_str:128) else goto L12
L12:
    r19 = 'Cannot create '
    r20 = ' for non-tuple type '
    r21 = CPyStr_Build(4, r19, r18, r20, type_str_repr)
    dec_ref r18
    dec_ref type_str_repr
    if is_error(r21) goto L23 (error at new_from_type_str:127) else goto L13
L13:
    r22 = builtins :: module
    r23 = 'ValueError'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L31 (error at new_from_type_str:126) else goto L14
L14:
    r25 = [r21]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L31 (error at new_from_type_str:126) else goto L15
L15:
    dec_ref r21
    CPy_Raise(r27)
    dec_ref r27
    if not 0 goto L23 (error at new_from_type_str:126) else goto L16 :: bool
L16:
    unreachable
L17:
    inc_ref r7
    r28 = cast(faster_eth_abi._grammar.TupleType, r7)
    if is_error(r28) goto L32 (error at new_from_type_str:133) else goto L18
L18:
    r29 = r28.validate()
    dec_ref r28
    if is_error(r29) goto L32 (error at new_from_type_str:133) else goto L19
L19:
    r30 = cast(faster_eth_abi._grammar.TupleType, r7)
    if is_error(r30) goto L24 (error at new_from_type_str:135) else goto L20
L20:
    r31 = r0.old_from_type_str
    dec_ref r0
    if is_error(r31) goto L33 (error at new_from_type_str:135) else goto L21
L21:
    r32 = [cls, r30, registry]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r31, r33, 3, 0)
    dec_ref r31
    if is_error(r34) goto L33 (error at new_from_type_str:135) else goto L22
L22:
    dec_ref r30
    return r34
L23:
    r35 = <error> :: object
    return r35
L24:
    dec_ref r0
    goto L23
L25:
    dec_ref r0
    dec_ref r1
    goto L23
L26:
    dec_ref r1
    goto L17
L27:
    dec_ref r0
    dec_ref r7
    goto L5
L28:
    dec_ref r1
    goto L23
L29:
    dec_ref r1
    goto L10
L30:
    dec_ref type_str_repr
    goto L23
L31:
    dec_ref r21
    goto L23
L32:
    dec_ref r0
    dec_ref r7
    goto L23
L33:
    dec_ref r30
    goto L23

def parse_tuple_type_str(old_from_type_str):
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: bool
    r2 :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    r3 :: bool
    r4, r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = parse_tuple_type_str_env()
    if is_error(r0) goto L12 (error at parse_tuple_type_str:105) else goto L1
L1:
    inc_ref old_from_type_str
    r0.old_from_type_str = old_from_type_str; r1 = is_error
    if not r1 goto L13 (error at parse_tuple_type_str:105) else goto L2 :: bool
L2:
    r2 = new_from_type_str_parse_tuple_type_str_obj()
    if is_error(r2) goto L13 (error at parse_tuple_type_str:115) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L14 (error at parse_tuple_type_str:115) else goto L4 :: bool
L4:
    r4 = r0.old_from_type_str
    dec_ref r0
    if is_error(r4) goto L15 (error at parse_tuple_type_str:114) else goto L5
L5:
    r5 = functools :: module
    r6 = 'wraps'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L16 (error at parse_tuple_type_str:114) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L16 (error at parse_tuple_type_str:114) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L15 (error at parse_tuple_type_str:115) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'new_from_type_str'
    r16 = PyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L17 (error at parse_tuple_type_str:115) else goto L9 :: bool
L9:
    r18 = builtins :: module
    r19 = 'classmethod'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L17 (error at parse_tuple_type_str:137) else goto L10
L10:
    r21 = [r13]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L17 (error at parse_tuple_type_str:137) else goto L11
L11:
    dec_ref r13
    return r23
L12:
    r24 = <error> :: object
    return r24
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref r0
    dec_ref r2
    goto L12
L15:
    dec_ref r2
    goto L12
L16:
    dec_ref r2
    dec_ref r4
    goto L12
L17:
    dec_ref r13
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30 :: object
    r31 :: str
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: object[2]
    r41 :: object_ptr
    r42, r43 :: object
    r44 :: dict
    r45 :: str
    r46 :: i32
    r47 :: bit
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: str
    r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: object
    r56 :: list
    r57, r58, r59, r60 :: ptr
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: tuple[list, object]
    r65, r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: object
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: dict
    r78 :: str
    r79 :: object
    r80 :: dict
    r81 :: str
    r82 :: object
    r83 :: list
    r84, r85, r86 :: ptr
    r87 :: dict
    r88 :: str
    r89 :: object
    r90 :: tuple[object, list, object]
    r91, r92 :: object
    r93 :: dict
    r94 :: str
    r95 :: i32
    r96 :: bit
    r97 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = faster_eth_abi.from_type_str.globals :: static
    r12 = 'faster_eth_abi/from_type_str.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('TYPE_CHECKING', 'Any', 'Callable', 'Optional', 'Type', 'TypeVar')
    r16 = 'typing'
    r17 = faster_eth_abi.from_type_str.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('TypeStr',)
    r20 = 'eth_typing'
    r21 = faster_eth_abi.from_type_str.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L30 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('ABIType', 'BasicType', 'TupleType', 'normalize')
    r24 = 'faster_eth_abi._grammar'
    r25 = faster_eth_abi.from_type_str.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L30 (error at <module>:15) else goto L7
L7:
    faster_eth_abi._grammar = r26 :: module
    dec_ref r26
    r27 = ('parse',)
    r28 = 'faster_eth_abi.grammar'
    r29 = faster_eth_abi.from_type_str.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L30 (error at <module>:21) else goto L8
L8:
    faster_eth_abi.grammar = r30 :: module
    dec_ref r30
    if 0 goto L9 else goto L9 :: bool
L9:
    r31 = 'TType'
    r32 = faster_eth_abi.from_type_str.globals :: static
    r33 = 'Type'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L30 (error at <module>:31) else goto L10
L10:
    r35 = 'BaseCoder'
    r36 = PyObject_GetItem(r34, r35)
    dec_ref r34
    if is_error(r36) goto L30 (error at <module>:31) else goto L11
L11:
    r37 = faster_eth_abi.from_type_str.globals :: static
    r38 = 'TypeVar'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L31 (error at <module>:31) else goto L12
L12:
    r40 = [r31, r36]
    r41 = load_address r40
    r42 = ('bound',)
    r43 = PyObject_Vectorcall(r39, r41, 1, r42)
    dec_ref r39
    if is_error(r43) goto L31 (error at <module>:31) else goto L13
L13:
    dec_ref r36
    r44 = faster_eth_abi.from_type_str.globals :: static
    r45 = 'TType'
    r46 = CPyDict_SetItem(r44, r45, r43)
    dec_ref r43
    r47 = r46 >= 0 :: signed
    if not r47 goto L30 (error at <module>:31) else goto L14 :: bool
L14:
    r48 = faster_eth_abi.from_type_str.globals :: static
    r49 = 'Callable'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L30 (error at <module>:32) else goto L15
L15:
    r51 = 'BaseCoder'
    r52 = faster_eth_abi._grammar.ABIType :: type
    r53 = faster_eth_abi.from_type_str.globals :: static
    r54 = 'Any'
    r55 = CPyDict_GetItem(r53, r54)
    if is_error(r55) goto L32 (error at <module>:32) else goto L16
L16:
    r56 = PyList_New(3)
    if is_error(r56) goto L33 (error at <module>:32) else goto L17
L17:
    r57 = get_element_ptr r56 ob_item :: PyListObject
    r58 = load_mem r57 :: ptr*
    inc_ref r51
    set_mem r58, r51 :: builtins.object*
    inc_ref r52
    r59 = r58 + 8
    set_mem r59, r52 :: builtins.object*
    r60 = r58 + 16
    set_mem r60, r55 :: builtins.object*
    r61 = faster_eth_abi.from_type_str.globals :: static
    r62 = 'TType'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L34 (error at <module>:32) else goto L18
L18:
    r64 = (r56, r63)
    r65 = box(tuple[list, object], r64)
    r66 = PyObject_GetItem(r50, r65)
    dec_ref r50
    dec_ref r65
    if is_error(r66) goto L30 (error at <module>:32) else goto L19
L19:
    r67 = faster_eth_abi.from_type_str.globals :: static
    r68 = 'OldFromTypeStr'
    r69 = CPyDict_SetItem(r67, r68, r66)
    dec_ref r66
    r70 = r69 >= 0 :: signed
    if not r70 goto L30 (error at <module>:32) else goto L20 :: bool
L20:
    if 0 goto L21 else goto L29 :: bool
L21:
    r71 = builtins :: module
    r72 = 'classmethod'
    r73 = CPyObject_GetAttr(r71, r72)
    if is_error(r73) goto L30 (error at <module>:34) else goto L22
L22:
    r74 = faster_eth_abi.from_type_str.globals :: static
    r75 = 'TType'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L35 (error at <module>:34) else goto L23
L23:
    r77 = faster_eth_abi.from_type_str.globals :: static
    r78 = 'TypeStr'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L36 (error at <module>:34) else goto L24
L24:
    r80 = faster_eth_abi.from_type_str.globals :: static
    r81 = 'Any'
    r82 = CPyDict_GetItem(r80, r81)
    if is_error(r82) goto L37 (error at <module>:34) else goto L25
L25:
    r83 = PyList_New(2)
    if is_error(r83) goto L38 (error at <module>:34) else goto L26
L26:
    r84 = get_element_ptr r83 ob_item :: PyListObject
    r85 = load_mem r84 :: ptr*
    set_mem r85, r79 :: builtins.object*
    r86 = r85 + 8
    set_mem r86, r82 :: builtins.object*
    r87 = faster_eth_abi.from_type_str.globals :: static
    r88 = 'TType'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L39 (error at <module>:34) else goto L27
L27:
    r90 = (r76, r83, r89)
    r91 = box(tuple[object, list, object], r90)
    r92 = PyObject_GetItem(r73, r91)
    dec_ref r73
    dec_ref r91
    if is_error(r92) goto L30 (error at <module>:34) else goto L28
L28:
    r93 = faster_eth_abi.from_type_str.globals :: static
    r94 = 'NewFromTypeStr'
    r95 = CPyDict_SetItem(r93, r94, r92)
    dec_ref r92
    r96 = r95 >= 0 :: signed
    if not r96 goto L30 (error at <module>:34) else goto L29 :: bool
L29:
    return 1
L30:
    r97 = <error> :: None
    return r97
L31:
    dec_ref r36
    goto L30
L32:
    dec_ref r50
    goto L30
L33:
    dec_ref r50
    dec_ref r55
    goto L30
L34:
    dec_ref r50
    dec_ref r56
    goto L30
L35:
    dec_ref r73
    goto L30
L36:
    dec_ref r73
    dec_ref r76
    goto L30
L37:
    dec_ref r73
    dec_ref r76
    dec_ref r79
    goto L30
L38:
    dec_ref r73
    dec_ref r76
    dec_ref r79
    dec_ref r82
    goto L30
L39:
    dec_ref r73
    dec_ref r76
    dec_ref r83
    goto L30

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L21 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.packed.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L21 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABIEncoder',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.packed.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L21 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry_packed',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.packed.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L21 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.packed.globals :: static
    r18 = 'registry_packed'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L21 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.packed.globals :: static
    r21 = 'ABIEncoder'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L22 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L22 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.packed.default_encoder_packed = r25 :: static
    r26 = faster_eth_abi.packed.globals :: static
    r27 = 'default_encoder_packed'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r31 goto L21 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L21 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.packed.encode_packed = r33 :: static
    r34 = faster_eth_abi.packed.globals :: static
    r35 = 'encode_packed'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L21 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r39 goto L21 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'is_encodable'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L21 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.packed.is_encodable_packed = r41 :: static
    r42 = faster_eth_abi.packed.globals :: static
    r43 = 'is_encodable_packed'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L21 (error at <module>:15) else goto L20 :: bool
L20:
    return 1
L21:
    r46 = <error> :: None
    return r46
L22:
    dec_ref r19
    goto L21

def ceil32(x):
    x, r0 :: int
    r1 :: bit
    r2, r3, r4, r5 :: int
L0:
    r0 = CPyTagged_Remainder(x, 64)
    if is_error(r0) goto L5 (error at ceil32:21) else goto L1
L1:
    r1 = r0 == 0
    if r1 goto L6 else goto L3 :: bool
L2:
    inc_ref x :: int
    r2 = x
    goto L4
L3:
    r3 = CPyTagged_Add(x, 64)
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    dec_ref r0 :: int
    r2 = r4
L4:
    return r2
L5:
    r5 = <error> :: int
    return r5
L6:
    dec_ref r0 :: int
    goto L2

def compute_unsigned_integer_bounds(num_bits):
    num_bits :: int
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4, bounds :: union[tuple[int, int], None]
    r5 :: object
    r6 :: bit
    r7, r8, r9, r10, r11 :: object
    r12 :: tuple[int, object]
    r13 :: object
    r14 :: tuple[int, int]
    r15 :: dict
    r16 :: bool
    r17, r18 :: object
    r19 :: i32
    r20 :: bit
    r21, r22 :: tuple[int, int]
L0:
    r0 = faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_unsigned_integer_bounds_cache" was not set')
    if not r1 goto L15 (error at compute_unsigned_integer_bounds:29) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    r2 = box(int, num_bits)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r2
    if is_error(r3) goto L15 (error at compute_unsigned_integer_bounds:29) else goto L4
L4:
    r4 = cast(union[tuple[int, int], None], r3)
    if is_error(r4) goto L15 (error at compute_unsigned_integer_bounds:29) else goto L5
L5:
    bounds = r4
    r5 = load_address _Py_NoneStruct
    r6 = bounds == r5
    if r6 goto L16 else goto L13 :: bool
L6:
    r7 = object 2
    inc_ref num_bits :: int
    r8 = box(int, num_bits)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L15 (error at compute_unsigned_integer_bounds:31) else goto L7
L7:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L15 (error at compute_unsigned_integer_bounds:31) else goto L8
L8:
    r12 = (0, r11)
    r13 = box(tuple[int, object], r12)
    bounds = r13
    r14 = unbox(tuple[int, int], bounds)
    if is_error(r14) goto L17 (error at compute_unsigned_integer_bounds:32) else goto L9
L9:
    r15 = faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache :: static
    if is_error(r15) goto L18 else goto L12
L10:
    r16 = raise NameError('value for final name "_unsigned_integer_bounds_cache" was not set')
    if not r16 goto L15 (error at compute_unsigned_integer_bounds:32) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref num_bits :: int
    r17 = box(int, num_bits)
    r18 = box(tuple[int, int], r14)
    r19 = CPyDict_SetItem(r15, r17, r18)
    dec_ref r17
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L17 (error at compute_unsigned_integer_bounds:32) else goto L13 :: bool
L13:
    r21 = unbox(tuple[int, int], bounds)
    dec_ref bounds
    if is_error(r21) goto L15 (error at compute_unsigned_integer_bounds:33) else goto L14
L14:
    return r21
L15:
    r22 = <error> :: tuple[int, int]
    return r22
L16:
    dec_ref bounds
    goto L6
L17:
    dec_ref bounds
    goto L15
L18:
    dec_ref bounds
    dec_ref r14
    goto L10

def compute_signed_integer_bounds(num_bits):
    num_bits :: int
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4, bounds :: union[tuple[int, int], None]
    r5 :: object
    r6 :: bit
    r7 :: int
    r8, r9, r10, r11, r12, r13 :: object
    r14 :: tuple[object, object]
    r15 :: object
    r16 :: tuple[int, int]
    r17 :: dict
    r18 :: bool
    r19, r20 :: object
    r21 :: i32
    r22 :: bit
    r23, r24 :: tuple[int, int]
L0:
    r0 = faster_eth_abi.utils.numeric._signed_integer_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_signed_integer_bounds_cache" was not set')
    if not r1 goto L16 (error at compute_signed_integer_bounds:40) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    r2 = box(int, num_bits)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r2
    if is_error(r3) goto L16 (error at compute_signed_integer_bounds:40) else goto L4
L4:
    r4 = cast(union[tuple[int, int], None], r3)
    if is_error(r4) goto L16 (error at compute_signed_integer_bounds:40) else goto L5
L5:
    bounds = r4
    r5 = load_address _Py_NoneStruct
    r6 = bounds == r5
    if r6 goto L17 else goto L14 :: bool
L6:
    r7 = CPyTagged_Subtract(num_bits, 2)
    r8 = object 2
    r9 = box(int, r7)
    r10 = CPyNumber_Power(r8, r9)
    dec_ref r9
    if is_error(r10) goto L16 (error at compute_signed_integer_bounds:42) else goto L7
L7:
    r11 = PyNumber_Negative(r10)
    if is_error(r11) goto L18 (error at compute_signed_integer_bounds:43) else goto L8
L8:
    r12 = object 1
    r13 = PyNumber_Subtract(r10, r12)
    dec_ref r10
    if is_error(r13) goto L19 (error at compute_signed_integer_bounds:44) else goto L9
L9:
    r14 = (r11, r13)
    r15 = box(tuple[object, object], r14)
    bounds = r15
    r16 = unbox(tuple[int, int], bounds)
    if is_error(r16) goto L20 (error at compute_signed_integer_bounds:46) else goto L10
L10:
    r17 = faster_eth_abi.utils.numeric._signed_integer_bounds_cache :: static
    if is_error(r17) goto L21 else goto L13
L11:
    r18 = raise NameError('value for final name "_signed_integer_bounds_cache" was not set')
    if not r18 goto L16 (error at compute_signed_integer_bounds:46) else goto L12 :: bool
L12:
    unreachable
L13:
    inc_ref num_bits :: int
    r19 = box(int, num_bits)
    r20 = box(tuple[int, int], r16)
    r21 = CPyDict_SetItem(r17, r19, r20)
    dec_ref r19
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L20 (error at compute_signed_integer_bounds:46) else goto L14 :: bool
L14:
    r23 = unbox(tuple[int, int], bounds)
    dec_ref bounds
    if is_error(r23) goto L16 (error at compute_signed_integer_bounds:47) else goto L15
L15:
    return r23
L16:
    r24 = <error> :: tuple[int, int]
    return r24
L17:
    dec_ref bounds
    goto L6
L18:
    dec_ref r10
    goto L16
L19:
    dec_ref r11
    goto L16
L20:
    dec_ref bounds
    goto L16
L21:
    dec_ref bounds
    dec_ref r16
    goto L11

def compute_unsigned_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0 :: dict
    r1 :: bool
    r2 :: tuple[int, int]
    r3, r4 :: object
    upper :: union[object, None]
    r5 :: object
    r6 :: bit
    r7, r8, r9, r10, r11, r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16 :: object[1]
    r17 :: object_ptr
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: bool
    r28 :: object
    r29 :: bool
    r30 :: object[1]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: bool
    r35 :: int
    r36, r37, r38 :: object
    r39, r40 :: tuple[object, object, object]
    r41, r42, r43 :: object
    r44 :: object[4]
    r45 :: object_ptr
    r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: bool
    r50 :: bit
    r51, r52, r53 :: tuple[object, object, object]
    r54 :: object
    r55 :: object[4]
    r56 :: object_ptr
    r57 :: object
    r58 :: bit
    r59 :: dict
    r60 :: bool
    r61 :: tuple[int, int]
    r62 :: object
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: bool
    r67 :: tuple[object, union[object, None]]
    r68 :: tuple[object, object]
L0:
    r0 = faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_unsigned_fixed_bounds_cache" was not set')
    if not r1 goto L56 (error at compute_unsigned_fixed_bounds:57) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r2 = (num_bits, frac_places)
    r3 = box(tuple[int, int], r2)
    r4 = CPyDict_GetWithNone(r0, r3)
    dec_ref r3
    if is_error(r4) goto L56 (error at compute_unsigned_fixed_bounds:57) else goto L4
L4:
    upper = r4
    r5 = load_address _Py_NoneStruct
    r6 = upper == r5
    if r6 goto L5 else goto L52 :: bool
L5:
    r7 = object 2
    inc_ref num_bits :: int
    r8 = box(int, num_bits)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L57 (error at compute_unsigned_fixed_bounds:59) else goto L6
L6:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L57 (error at compute_unsigned_fixed_bounds:59) else goto L7
L7:
    r12 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r12) goto L58 else goto L10
L8:
    r13 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r13 goto L56 (error at compute_unsigned_fixed_bounds:61) else goto L9 :: bool
L9:
    unreachable
L10:
    r14 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r14) goto L59 else goto L13
L11:
    r15 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r15 goto L56 (error at compute_unsigned_fixed_bounds:61) else goto L12 :: bool
L12:
    unreachable
L13:
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r14, r17, 1, 0)
    if is_error(r18) goto L60 (error at compute_unsigned_fixed_bounds:61) else goto L14
L14:
    r19 = CPy_TYPE(r18)
    r20 = '__exit__'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L61 (error at compute_unsigned_fixed_bounds:61) else goto L15
L15:
    r22 = '__enter__'
    r23 = CPyObject_GetAttr(r19, r22)
    dec_ref r19
    if is_error(r23) goto L62 (error at compute_unsigned_fixed_bounds:61) else goto L16
L16:
    r24 = [r18]
    r25 = load_address r24
    r26 = PyObject_Vectorcall(r23, r25, 1, 0)
    dec_ref r23
    if is_error(r26) goto L62 (error at compute_unsigned_fixed_bounds:61) else goto L63
L17:
    r27 = 1
L18:
    r28 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r28) goto L64 else goto L21
L19:
    r29 = raise NameError('value for final name "Decimal" was not set')
    if not r29 goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L65 :: bool
L20:
    unreachable
L21:
    r30 = [r11]
    r31 = load_address r30
    r32 = PyObject_Vectorcall(r28, r31, 1, 0)
    if is_error(r32) goto L66 (error at compute_unsigned_fixed_bounds:62) else goto L22
L22:
    dec_ref r11
    r33 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r33) goto L67 else goto L25
L23:
    r34 = raise NameError('value for final name "TEN" was not set')
    if not r34 goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L68 :: bool
L24:
    unreachable
L25:
    r35 = CPyTagged_Negate(frac_places)
    r36 = box(int, r35)
    r37 = CPyNumber_Power(r33, r36)
    dec_ref r36
    if is_error(r37) goto L69 (error at compute_unsigned_fixed_bounds:62) else goto L26
L26:
    r38 = PyNumber_Multiply(r32, r37)
    dec_ref r32
    dec_ref r37
    if is_error(r38) goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L70
L27:
    upper = r38
    goto L36
L28:
    r39 = CPy_CatchError()
    r27 = 0
    r40 = CPy_GetExcInfo()
    r41 = r40[0]
    r42 = r40[1]
    r43 = r40[2]
    dec_ref r40
    r44 = [r18, r41, r42, r43]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r21, r45, 4, 0)
    if is_error(r46) goto L71 (error at compute_unsigned_fixed_bounds:61) else goto L29
L29:
    dec_ref r41
    dec_ref r42
    dec_ref r43
    r47 = PyObject_IsTrue(r46)
    dec_ref r46
    r48 = r47 >= 0 :: signed
    if not r48 goto L34 (error at compute_unsigned_fixed_bounds:61) else goto L30 :: bool
L30:
    r49 = truncate r47: i32 to builtins.bool
    if r49 goto L33 else goto L31 :: bool
L31:
    CPy_Reraise()
    if not 0 goto L34 else goto L72 :: bool
L32:
    unreachable
L33:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    goto L36
L34:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    r50 = CPy_KeepPropagating()
    if not r50 goto L37 else goto L73 :: bool
L35:
    unreachable
L36:
    r51 = <error> :: tuple[object, object, object]
    r52 = r51
    goto L38
L37:
    r53 = CPy_CatchError()
    r52 = r53
L38:
    if r27 goto L39 else goto L74 :: bool
L39:
    r54 = load_address _Py_NoneStruct
    r55 = [r18, r54, r54, r54]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r21, r56, 4, 0)
    dec_ref r21
    if is_error(r57) goto L75 (error at compute_unsigned_fixed_bounds:61) else goto L76
L40:
    dec_ref r18
L41:
    if is_error(r52) goto L48 else goto L77
L42:
    CPy_Reraise()
    if not 0 goto L44 else goto L78 :: bool
L43:
    unreachable
L44:
    if is_error(r52) goto L46 else goto L45
L45:
    CPy_RestoreExcInfo(r52)
    xdec_ref r52
L46:
    r58 = CPy_KeepPropagating()
    if not r58 goto L56 else goto L47 :: bool
L47:
    unreachable
L48:
    r59 = faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache :: static
    if is_error(r59) goto L79 else goto L51
L49:
    r60 = raise NameError('value for final name "_unsigned_fixed_bounds_cache" was not set')
    if not r60 goto L56 (error at compute_unsigned_fixed_bounds:64) else goto L50 :: bool
L50:
    unreachable
L51:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r61 = (num_bits, frac_places)
    r62 = box(tuple[int, int], r61)
    r63 = CPyDict_SetItem(r59, r62, upper)
    dec_ref r62
    r64 = r63 >= 0 :: signed
    if not r64 goto L57 (error at compute_unsigned_fixed_bounds:64) else goto L52 :: bool
L52:
    r65 = faster_eth_abi.utils.numeric.ZERO :: static
    if is_error(r65) goto L80 else goto L55
L53:
    r66 = raise NameError('value for final name "ZERO" was not set')
    if not r66 goto L56 (error at compute_unsigned_fixed_bounds:66) else goto L54 :: bool
L54:
    unreachable
L55:
    inc_ref r65
    r67 = (r65, upper)
    return r67
L56:
    r68 = <error> :: tuple[object, object]
    return r68
L57:
    dec_ref upper
    goto L56
L58:
    dec_ref upper
    dec_ref r11
    goto L8
L59:
    dec_ref upper
    dec_ref r11
    goto L11
L60:
    dec_ref upper
    dec_ref r11
    goto L56
L61:
    dec_ref upper
    dec_ref r11
    dec_ref r18
    dec_ref r19
    goto L56
L62:
    dec_ref upper
    dec_ref r11
    dec_ref r18
    dec_ref r21
    goto L56
L63:
    dec_ref r26
    goto L17
L64:
    dec_ref r11
    goto L19
L65:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L20
L66:
    dec_ref r11
    goto L28
L67:
    dec_ref r32
    goto L23
L68:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L24
L69:
    dec_ref r32
    goto L28
L70:
    dec_ref upper
    goto L27
L71:
    dec_ref r41
    dec_ref r42
    dec_ref r43
    goto L34
L72:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    dec_ref r39
    goto L32
L73:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L35
L74:
    dec_ref r18
    dec_ref r21
    goto L41
L75:
    dec_ref upper
    dec_ref r18
    goto L44
L76:
    dec_ref r57
    goto L40
L77:
    dec_ref upper
    goto L42
L78:
    xdec_ref r52
    goto L43
L79:
    dec_ref upper
    goto L49
L80:
    dec_ref upper
    goto L53

def compute_signed_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, lower, r1, upper :: object
    r2 :: dict
    r3 :: bool
    r4 :: tuple[int, int]
    r5, r6 :: object
    r7, bounds :: union[tuple[object, object], None]
    r8 :: object
    r9 :: bit
    r10 :: tuple[int, int]
    r11, r12, r13, r14 :: int
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: bool
    r33 :: int
    r34, r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42, r43 :: object
    r44 :: bool
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48, r49 :: object
    r50, r51 :: tuple[object, object, object]
    r52, r53, r54 :: object
    r55 :: object[4]
    r56 :: object_ptr
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: bit
    r62, r63, r64 :: tuple[object, object, object]
    r65 :: object
    r66 :: object[4]
    r67 :: object_ptr
    r68 :: object
    r69 :: bit
    r70, r71 :: bool
    r72 :: tuple[object, object]
    r73 :: object
    r74 :: tuple[object, object]
    r75 :: dict
    r76 :: bool
    r77 :: tuple[int, int]
    r78, r79 :: object
    r80 :: i32
    r81 :: bit
    r82, r83 :: tuple[object, object]
L0:
    r0 = <error> :: object
    lower = r0
    r1 = <error> :: object
    upper = r1
    r2 = faster_eth_abi.utils.numeric._signed_fixed_bounds_cache :: static
    if is_error(r2) goto L67 else goto L3
L1:
    r3 = raise NameError('value for final name "_signed_fixed_bounds_cache" was not set')
    if not r3 goto L66 (error at compute_signed_fixed_bounds:78) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r4 = (num_bits, frac_places)
    r5 = box(tuple[int, int], r4)
    r6 = CPyDict_GetWithNone(r2, r5)
    dec_ref r5
    if is_error(r6) goto L68 (error at compute_signed_fixed_bounds:78) else goto L4
L4:
    r7 = cast(union[tuple[object, object], None], r6)
    if is_error(r7) goto L68 (error at compute_signed_fixed_bounds:78) else goto L5
L5:
    bounds = r7
    r8 = load_address _Py_NoneStruct
    r9 = bounds == r8
    if r9 goto L69 else goto L70 :: bool
L6:
    r10 = compute_signed_integer_bounds(num_bits)
    if is_error(r10) goto L68 (error at compute_signed_fixed_bounds:80) else goto L7
L7:
    r11 = borrow r10[0]
    r12 = borrow r10[1]
    r13 = unborrow r11
    r14 = unborrow r12
    r15 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r15) goto L71 else goto L10
L8:
    r16 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r16 goto L66 (error at compute_signed_fixed_bounds:82) else goto L9 :: bool
L9:
    unreachable
L10:
    r17 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r17) goto L72 else goto L13
L11:
    r18 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r18 goto L66 (error at compute_signed_fixed_bounds:82) else goto L12 :: bool
L12:
    unreachable
L13:
    r19 = [r15]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L73 (error at compute_signed_fixed_bounds:82) else goto L14
L14:
    r22 = CPy_TYPE(r21)
    r23 = '__exit__'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L74 (error at compute_signed_fixed_bounds:82) else goto L15
L15:
    r25 = '__enter__'
    r26 = CPyObject_GetAttr(r22, r25)
    dec_ref r22
    if is_error(r26) goto L75 (error at compute_signed_fixed_bounds:82) else goto L16
L16:
    r27 = [r21]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L75 (error at compute_signed_fixed_bounds:82) else goto L76
L17:
    r30 = 1
L18:
    r31 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r31) goto L77 else goto L21
L19:
    r32 = raise NameError('value for final name "TEN" was not set')
    if not r32 goto L33 (error at compute_signed_fixed_bounds:83) else goto L78 :: bool
L20:
    unreachable
L21:
    r33 = CPyTagged_Negate(frac_places)
    r34 = box(int, r33)
    r35 = CPyNumber_Power(r31, r34)
    dec_ref r34
    if is_error(r35) goto L79 (error at compute_signed_fixed_bounds:83) else goto L22
L22:
    r36 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r36) goto L80 else goto L25
L23:
    r37 = raise NameError('value for final name "Decimal" was not set')
    if not r37 goto L33 (error at compute_signed_fixed_bounds:84) else goto L81 :: bool
L24:
    unreachable
L25:
    r38 = box(int, r13)
    r39 = [r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r36, r40, 1, 0)
    if is_error(r41) goto L82 (error at compute_signed_fixed_bounds:84) else goto L26
L26:
    dec_ref r38
    r42 = PyNumber_Multiply(r41, r35)
    dec_ref r41
    if is_error(r42) goto L83 (error at compute_signed_fixed_bounds:84) else goto L84
L27:
    lower = r42
    r43 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r43) goto L85 else goto L30
L28:
    r44 = raise NameError('value for final name "Decimal" was not set')
    if not r44 goto L33 (error at compute_signed_fixed_bounds:85) else goto L86 :: bool
L29:
    unreachable
L30:
    r45 = box(int, r14)
    r46 = [r45]
    r47 = load_address r46
    r48 = PyObject_Vectorcall(r43, r47, 1, 0)
    if is_error(r48) goto L87 (error at compute_signed_fixed_bounds:85) else goto L31
L31:
    dec_ref r45
    r49 = PyNumber_Multiply(r48, r35)
    dec_ref r48
    dec_ref r35
    if is_error(r49) goto L33 (error at compute_signed_fixed_bounds:85) else goto L88
L32:
    upper = r49
    goto L41
L33:
    r50 = CPy_CatchError()
    r30 = 0
    r51 = CPy_GetExcInfo()
    r52 = r51[0]
    r53 = r51[1]
    r54 = r51[2]
    dec_ref r51
    r55 = [r21, r52, r53, r54]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r24, r56, 4, 0)
    if is_error(r57) goto L89 (error at compute_signed_fixed_bounds:82) else goto L34
L34:
    dec_ref r52
    dec_ref r53
    dec_ref r54
    r58 = PyObject_IsTrue(r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L39 (error at compute_signed_fixed_bounds:82) else goto L35 :: bool
L35:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L38 else goto L36 :: bool
L36:
    CPy_Reraise()
    if not 0 goto L39 else goto L90 :: bool
L37:
    unreachable
L38:
    CPy_RestoreExcInfo(r50)
    dec_ref r50
    goto L41
L39:
    CPy_RestoreExcInfo(r50)
    dec_ref r50
    r61 = CPy_KeepPropagating()
    if not r61 goto L42 else goto L91 :: bool
L40:
    unreachable
L41:
    r62 = <error> :: tuple[object, object, object]
    r63 = r62
    goto L43
L42:
    r64 = CPy_CatchError()
    r63 = r64
L43:
    if r30 goto L44 else goto L92 :: bool
L44:
    r65 = load_address _Py_NoneStruct
    r66 = [r21, r65, r65, r65]
    r67 = load_address r66
    r68 = PyObject_Vectorcall(r24, r67, 4, 0)
    dec_ref r24
    if is_error(r68) goto L93 (error at compute_signed_fixed_bounds:82) else goto L94
L45:
    dec_ref r21
L46:
    if is_error(r63) goto L53 else goto L95
L47:
    CPy_Reraise()
    if not 0 goto L49 else goto L96 :: bool
L48:
    unreachable
L49:
    if is_error(r63) goto L51 else goto L50
L50:
    CPy_RestoreExcInfo(r63)
    xdec_ref r63
L51:
    r69 = CPy_KeepPropagating()
    if not r69 goto L66 else goto L52 :: bool
L52:
    unreachable
L53:
    if is_error(lower) goto L97 else goto L56
L54:
    r70 = raise UnboundLocalError('local variable "lower" referenced before assignment')
    if not r70 goto L66 (error at compute_signed_fixed_bounds:87) else goto L55 :: bool
L55:
    unreachable
L56:
    if is_error(upper) goto L98 else goto L59
L57:
    r71 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r71 goto L66 (error at compute_signed_fixed_bounds:87) else goto L58 :: bool
L58:
    unreachable
L59:
    r72 = (lower, upper)
    r73 = box(tuple[object, object], r72)
    bounds = r73
    r74 = unbox(tuple[object, object], bounds)
    if is_error(r74) goto L99 (error at compute_signed_fixed_bounds:88) else goto L60
L60:
    r75 = faster_eth_abi.utils.numeric._signed_fixed_bounds_cache :: static
    if is_error(r75) goto L100 else goto L63
L61:
    r76 = raise NameError('value for final name "_signed_fixed_bounds_cache" was not set')
    if not r76 goto L66 (error at compute_signed_fixed_bounds:88) else goto L62 :: bool
L62:
    unreachable
L63:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r77 = (num_bits, frac_places)
    r78 = box(tuple[int, int], r77)
    r79 = box(tuple[object, object], r74)
    r80 = CPyDict_SetItem(r75, r78, r79)
    dec_ref r78
    dec_ref r79
    r81 = r80 >= 0 :: signed
    if not r81 goto L99 (error at compute_signed_fixed_bounds:88) else goto L64 :: bool
L64:
    r82 = unbox(tuple[object, object], bounds)
    dec_ref bounds
    if is_error(r82) goto L66 (error at compute_signed_fixed_bounds:90) else goto L65
L65:
    return r82
L66:
    r83 = <error> :: tuple[object, object]
    return r83
L67:
    xdec_ref lower
    xdec_ref upper
    goto L1
L68:
    xdec_ref lower
    xdec_ref upper
    goto L66
L69:
    dec_ref bounds
    goto L6
L70:
    xdec_ref lower
    xdec_ref upper
    goto L64
L71:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L8
L72:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L11
L73:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L66
L74:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r21
    dec_ref r22
    goto L66
L75:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r21
    dec_ref r24
    goto L66
L76:
    dec_ref r29
    goto L17
L77:
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L19
L78:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L20
L79:
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L33
L80:
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r35
    goto L23
L81:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L24
L82:
    dec_ref r14 :: int
    dec_ref r35
    dec_ref r38
    goto L33
L83:
    dec_ref r14 :: int
    dec_ref r35
    goto L33
L84:
    xdec_ref lower
    goto L27
L85:
    dec_ref r14 :: int
    dec_ref r35
    goto L28
L86:
    dec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L29
L87:
    dec_ref r35
    dec_ref r45
    goto L33
L88:
    xdec_ref upper
    goto L32
L89:
    dec_ref r52
    dec_ref r53
    dec_ref r54
    goto L39
L90:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    dec_ref r50
    goto L37
L91:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L40
L92:
    dec_ref r21
    dec_ref r24
    goto L46
L93:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    goto L49
L94:
    dec_ref r68
    goto L45
L95:
    xdec_ref lower
    xdec_ref upper
    goto L47
L96:
    xdec_ref r63
    goto L48
L97:
    xdec_ref upper
    goto L54
L98:
    xdec_ref lower
    goto L57
L99:
    dec_ref bounds
    goto L66
L100:
    dec_ref bounds
    dec_ref r74
    goto L61

def f_scale_places_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def f_scale_places_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: faster_eth_abi.utils.numeric.f_scale_places_obj
    x :: object
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: bool
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: bool
    r17, r18, r19 :: object
    r20, r21 :: tuple[object, object, object]
    r22, r23, r24 :: object
    r25 :: object[4]
    r26 :: object_ptr
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: bit
    r32 :: object
    r33, r34 :: tuple[object, object, object]
    r35 :: object
    r36 :: tuple[object, object, object]
    r37 :: object
    r38 :: object[4]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42, r43 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L39 (error at f:107) else goto L1
L1:
    r1 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r1) goto L40 else goto L4
L2:
    r2 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r2 goto L39 (error at f:108) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r3) goto L41 else goto L7
L5:
    r4 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r4 goto L39 (error at f:108) else goto L6 :: bool
L6:
    unreachable
L7:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r3, r6, 1, 0)
    if is_error(r7) goto L42 (error at f:108) else goto L8
L8:
    r8 = CPy_TYPE(r7)
    r9 = '__exit__'
    r10 = CPyObject_GetAttr(r8, r9)
    if is_error(r10) goto L43 (error at f:108) else goto L9
L9:
    r11 = '__enter__'
    r12 = CPyObject_GetAttr(r8, r11)
    dec_ref r8
    if is_error(r12) goto L44 (error at f:108) else goto L10
L10:
    r13 = [r7]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L44 (error at f:108) else goto L45
L11:
    r16 = 1
L12:
    r17 = r0.scaling_factor
    dec_ref r0
    if is_error(r17) goto L15 (error at f:109) else goto L13
L13:
    r18 = PyNumber_Multiply(x, r17)
    dec_ref r17
    if is_error(r18) goto L15 (error at f:109) else goto L14
L14:
    r19 = r18
    goto L24
L15:
    r20 = CPy_CatchError()
    r16 = 0
    r21 = CPy_GetExcInfo()
    r22 = r21[0]
    r23 = r21[1]
    r24 = r21[2]
    dec_ref r21
    r25 = [r7, r22, r23, r24]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r10, r26, 4, 0)
    if is_error(r27) goto L46 (error at f:108) else goto L16
L16:
    dec_ref r22
    dec_ref r23
    dec_ref r24
    r28 = PyObject_IsTrue(r27)
    dec_ref r27
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at f:108) else goto L17 :: bool
L17:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L20 else goto L18 :: bool
L18:
    CPy_Reraise()
    if not 0 goto L21 else goto L47 :: bool
L19:
    unreachable
L20:
    CPy_RestoreExcInfo(r20)
    dec_ref r20
    goto L23
L21:
    CPy_RestoreExcInfo(r20)
    dec_ref r20
    r31 = CPy_KeepPropagating()
    if not r31 goto L25 else goto L48 :: bool
L22:
    unreachable
L23:
    r32 = <error> :: object
    r19 = r32
L24:
    r33 = <error> :: tuple[object, object, object]
    r34 = r33
    goto L26
L25:
    r35 = <error> :: object
    r19 = r35
    r36 = CPy_CatchError()
    r34 = r36
L26:
    if r16 goto L27 else goto L49 :: bool
L27:
    r37 = load_address _Py_NoneStruct
    r38 = [r7, r37, r37, r37]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r10, r39, 4, 0)
    dec_ref r10
    if is_error(r40) goto L50 (error at f:108) else goto L51
L28:
    dec_ref r7
L29:
    if is_error(r34) goto L32 else goto L52
L30:
    CPy_Reraise()
    if not 0 goto L34 else goto L53 :: bool
L31:
    unreachable
L32:
    if is_error(r19) goto L38 else goto L33
L33:
    return r19
L34:
    if is_error(r34) goto L36 else goto L35
L35:
    CPy_RestoreExcInfo(r34)
    xdec_ref r34
L36:
    r41 = CPy_KeepPropagating()
    if not r41 goto L39 else goto L37 :: bool
L37:
    unreachable
L38:
    r42 = box(None, 1)
    inc_ref r42
    return r42
L39:
    r43 = <error> :: object
    return r43
L40:
    dec_ref r0
    goto L2
L41:
    dec_ref r0
    goto L5
L42:
    dec_ref r0
    goto L39
L43:
    dec_ref r0
    dec_ref r7
    dec_ref r8
    goto L39
L44:
    dec_ref r0
    dec_ref r7
    dec_ref r10
    goto L39
L45:
    dec_ref r15
    goto L11
L46:
    dec_ref r22
    dec_ref r23
    dec_ref r24
    goto L21
L47:
    dec_ref r7
    dec_ref r10
    dec_ref r20
    goto L19
L48:
    dec_ref r7
    dec_ref r10
    goto L22
L49:
    dec_ref r7
    dec_ref r10
    goto L29
L50:
    dec_ref r7
    xdec_ref r19
    goto L34
L51:
    dec_ref r40
    goto L28
L52:
    xdec_ref r19
    goto L30
L53:
    xdec_ref r34
    goto L31

def scale_places(places):
    places :: int
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bit
    r3, r4, r5 :: str
    r6 :: object
    r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12, r13 :: str
    r14, r15 :: object
    r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22 :: list
    r23, r24, r25, r26, r27, r28 :: ptr
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: bool
    r40 :: object[1]
    r41 :: object_ptr
    r42, r43 :: object
    r44 :: str
    r45 :: object
    r46 :: str
    r47 :: object
    r48 :: object[1]
    r49 :: object_ptr
    r50 :: object
    r51 :: bool
    r52 :: object
    r53 :: bool
    r54 :: int
    r55, r56 :: object
    r57 :: bool
    r58, r59 :: tuple[object, object, object]
    r60, r61, r62 :: object
    r63 :: object[4]
    r64 :: object_ptr
    r65 :: object
    r66 :: i32
    r67 :: bit
    r68 :: bool
    r69 :: bit
    r70, r71, r72 :: tuple[object, object, object]
    r73 :: object
    r74 :: object[4]
    r75 :: object_ptr
    r76 :: object
    r77 :: bit
    r78 :: faster_eth_abi.utils.numeric.f_scale_places_obj
    r79 :: bool
    f :: object
    r80 :: native_int
    r81 :: bit
    r82 :: native_int
    r83, r84, r85 :: bit
    r86, r87, r88, r89, r90 :: str
    r91 :: int
    r92, r93, places_repr, r94, r95, r96 :: str
    r97 :: i32
    r98 :: bit
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: object
L0:
    r0 = scale_places_env()
    if is_error(r0) goto L62 (error at scale_places:93) else goto L1
L1:
    inc_ref places :: int
    r1 = box(int, places)
    r2 = PyLong_Check(r1)
    dec_ref r1
    if r2 goto L10 else goto L63 :: bool
L2:
    r3 = ''
    r4 = 'Argument `places` must be int.  Got value '
    r5 = '{:{}}'
    inc_ref places :: int
    r6 = box(int, places)
    r7 = ''
    r8 = 'format'
    r9 = [r5, r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L64 (error at scale_places:100) else goto L3
L3:
    dec_ref r6
    r12 = ' of type '
    r13 = '{:{}}'
    inc_ref places :: int
    r14 = box(int, places)
    r15 = CPy_TYPE(r14)
    dec_ref r14
    r16 = ''
    r17 = 'format'
    r18 = [r13, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L65 (error at scale_places:101) else goto L4
L4:
    dec_ref r15
    r21 = '.'
    r22 = PyList_New(5)
    if is_error(r22) goto L66 (error at scale_places:100) else goto L5
L5:
    r23 = get_element_ptr r22 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    inc_ref r4
    set_mem r24, r4 :: builtins.object*
    r25 = r24 + 8
    set_mem r25, r11 :: builtins.object*
    inc_ref r12
    r26 = r24 + 16
    set_mem r26, r12 :: builtins.object*
    r27 = r24 + 24
    set_mem r27, r20 :: builtins.object*
    inc_ref r21
    r28 = r24 + 32
    set_mem r28, r21 :: builtins.object*
    r29 = PyUnicode_Join(r3, r22)
    dec_ref r22
    if is_error(r29) goto L62 (error at scale_places:100) else goto L6
L6:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L67 (error at scale_places:99) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L67 (error at scale_places:99) else goto L8
L8:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L62 (error at scale_places:99) else goto L9 :: bool
L9:
    unreachable
L10:
    r36 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r36) goto L68 else goto L13
L11:
    r37 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r37 goto L62 (error at scale_places:104) else goto L12 :: bool
L12:
    unreachable
L13:
    r38 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r38) goto L69 else goto L16
L14:
    r39 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r39 goto L62 (error at scale_places:104) else goto L15 :: bool
L15:
    unreachable
L16:
    r40 = [r36]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r38, r41, 1, 0)
    if is_error(r42) goto L70 (error at scale_places:104) else goto L17
L17:
    r43 = CPy_TYPE(r42)
    r44 = '__exit__'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L71 (error at scale_places:104) else goto L18
L18:
    r46 = '__enter__'
    r47 = CPyObject_GetAttr(r43, r46)
    dec_ref r43
    if is_error(r47) goto L72 (error at scale_places:104) else goto L19
L19:
    r48 = [r42]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r47, r49, 1, 0)
    dec_ref r47
    if is_error(r50) goto L72 (error at scale_places:104) else goto L73
L20:
    r51 = 1
L21:
    r52 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r52) goto L22 else goto L24
L22:
    r53 = raise NameError('value for final name "TEN" was not set')
    if not r53 goto L26 (error at scale_places:105) else goto L74 :: bool
L23:
    unreachable
L24:
    r54 = CPyTagged_Negate(places)
    r55 = box(int, r54)
    r56 = CPyNumber_Power(r52, r55)
    dec_ref r55
    if is_error(r56) goto L26 (error at scale_places:105) else goto L25
L25:
    r0.scaling_factor = r56; r57 = is_error
    if not r57 goto L26 (error at scale_places:105) else goto L34 :: bool
L26:
    r58 = CPy_CatchError()
    r51 = 0
    r59 = CPy_GetExcInfo()
    r60 = r59[0]
    r61 = r59[1]
    r62 = r59[2]
    dec_ref r59
    r63 = [r42, r60, r61, r62]
    r64 = load_address r63
    r65 = PyObject_Vectorcall(r45, r64, 4, 0)
    if is_error(r65) goto L75 (error at scale_places:104) else goto L27
L27:
    dec_ref r60
    dec_ref r61
    dec_ref r62
    r66 = PyObject_IsTrue(r65)
    dec_ref r65
    r67 = r66 >= 0 :: signed
    if not r67 goto L32 (error at scale_places:104) else goto L28 :: bool
L28:
    r68 = truncate r66: i32 to builtins.bool
    if r68 goto L31 else goto L29 :: bool
L29:
    CPy_Reraise()
    if not 0 goto L32 else goto L76 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    goto L34
L32:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    r69 = CPy_KeepPropagating()
    if not r69 goto L35 else goto L77 :: bool
L33:
    unreachable
L34:
    r70 = <error> :: tuple[object, object, object]
    r71 = r70
    goto L36
L35:
    r72 = CPy_CatchError()
    r71 = r72
L36:
    if r51 goto L37 else goto L78 :: bool
L37:
    r73 = load_address _Py_NoneStruct
    r74 = [r42, r73, r73, r73]
    r75 = load_address r74
    r76 = PyObject_Vectorcall(r45, r75, 4, 0)
    dec_ref r45
    if is_error(r76) goto L79 (error at scale_places:104) else goto L80
L38:
    dec_ref r42
L39:
    if is_error(r71) goto L46 else goto L81
L40:
    CPy_Reraise()
    if not 0 goto L42 else goto L82 :: bool
L41:
    unreachable
L42:
    if is_error(r71) goto L44 else goto L43
L43:
    CPy_RestoreExcInfo(r71)
    xdec_ref r71
L44:
    r77 = CPy_KeepPropagating()
    if not r77 goto L62 else goto L45 :: bool
L45:
    unreachable
L46:
    r78 = f_scale_places_obj()
    if is_error(r78) goto L70 (error at scale_places:107) else goto L47
L47:
    r78.__mypyc_env__ = r0; r79 = is_error
    if not r79 goto L83 (error at scale_places:107) else goto L48 :: bool
L48:
    f = r78
    r80 = places & 1
    r81 = r80 != 0
    if r81 goto L50 else goto L49 :: bool
L49:
    r82 = 0 & 1
    r83 = r82 != 0
    if r83 goto L50 else goto L51 :: bool
L50:
    r84 = CPyTagged_IsLt_(0, places)
    if r84 goto L52 else goto L55 :: bool
L51:
    r85 = places > 0 :: signed
    if r85 goto L52 else goto L55 :: bool
L52:
    r86 = 'Eneg'
    r87 = CPyTagged_Str(places)
    if is_error(r87) goto L84 (error at scale_places:111) else goto L53
L53:
    r88 = CPyStr_Build(2, r86, r87)
    dec_ref r87
    if is_error(r88) goto L84 (error at scale_places:111) else goto L54
L54:
    r89 = r88
    goto L58
L55:
    r90 = 'Epos'
    r91 = CPyTagged_Negate(places)
    r92 = CPyTagged_Str(r91)
    dec_ref r91 :: int
    if is_error(r92) goto L84 (error at scale_places:111) else goto L56
L56:
    r93 = CPyStr_Build(2, r90, r92)
    dec_ref r92
    if is_error(r93) goto L84 (error at scale_places:111) else goto L57
L57:
    r89 = r93
L58:
    places_repr = r89
    r94 = 'scale_by_'
    r95 = CPyStr_Build(2, r94, places_repr)
    dec_ref places_repr
    if is_error(r95) goto L84 (error at scale_places:112) else goto L59
L59:
    r96 = '__name__'
    r97 = PyObject_SetAttr(f, r96, r95)
    r98 = r97 >= 0 :: signed
    if not r98 goto L85 (error at scale_places:114) else goto L60 :: bool
L60:
    r99 = '__qualname__'
    r100 = PyObject_SetAttr(f, r99, r95)
    dec_ref r95
    r101 = r100 >= 0 :: signed
    if not r101 goto L84 (error at scale_places:115) else goto L61 :: bool
L61:
    return f
L62:
    r102 = <error> :: object
    return r102
L63:
    dec_ref r0
    goto L2
L64:
    dec_ref r6
    goto L62
L65:
    dec_ref r11
    dec_ref r15
    goto L62
L66:
    dec_ref r11
    dec_ref r20
    goto L62
L67:
    dec_ref r29
    goto L62
L68:
    dec_ref r0
    goto L11
L69:
    dec_ref r0
    goto L14
L70:
    dec_ref r0
    goto L62
L71:
    dec_ref r0
    dec_ref r42
    dec_ref r43
    goto L62
L72:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L62
L73:
    dec_ref r50
    goto L20
L74:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L23
L75:
    dec_ref r60
    dec_ref r61
    dec_ref r62
    goto L32
L76:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    dec_ref r58
    goto L30
L77:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L33
L78:
    dec_ref r42
    dec_ref r45
    goto L39
L79:
    dec_ref r0
    dec_ref r42
    goto L42
L80:
    dec_ref r76
    goto L38
L81:
    dec_ref r0
    goto L40
L82:
    xdec_ref r71
    goto L41
L83:
    dec_ref r78
    goto L62
L84:
    dec_ref f
    goto L62
L85:
    dec_ref f
    dec_ref r95
    goto L62

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: str
    r26, r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: i32
    r42 :: bit
    r43 :: object
    r44 :: str
    r45, r46 :: object
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: object[1]
    r59 :: object_ptr
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72, r73 :: dict
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77, r78 :: dict
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82, r83 :: dict
    r84 :: str
    r85 :: i32
    r86 :: bit
    r87, r88 :: dict
    r89 :: str
    r90 :: i32
    r91 :: bit
    r92 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L28 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = faster_eth_abi.utils.numeric.globals :: static
    r12 = 'faster_eth_abi/utils/numeric.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L28 else goto L4 :: bool
L4:
    r15 = ('Callable', 'Dict', 'Final', 'Tuple')
    r16 = 'typing'
    r17 = faster_eth_abi.utils.numeric.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L28 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = faster_eth_abi.utils.numeric.globals :: static
    r20 = 'ABI_DECIMAL_PREC'
    r21 = object 999
    r22 = CPyDict_SetItem(r19, r20, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L28 (error at <module>:9) else goto L6 :: bool
L6:
    r24 = decimal :: module
    r25 = 'Context'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L28 (error at <module>:11) else goto L7
L7:
    r27 = object 999
    r28 = [r27]
    r29 = load_address r28
    r30 = ('prec',)
    r31 = PyObject_Vectorcall(r26, r29, 0, r30)
    dec_ref r26
    if is_error(r31) goto L28 (error at <module>:11) else goto L8
L8:
    faster_eth_abi.utils.numeric.abi_decimal_context = r31 :: static
    r32 = faster_eth_abi.utils.numeric.globals :: static
    r33 = 'abi_decimal_context'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L28 (error at <module>:11) else goto L9 :: bool
L9:
    r36 = decimal :: module
    r37 = 'localcontext'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L28 (error at <module>:12) else goto L10
L10:
    faster_eth_abi.utils.numeric.decimal_localcontext = r38 :: static
    r39 = faster_eth_abi.utils.numeric.globals :: static
    r40 = 'decimal_localcontext'
    r41 = CPyDict_SetItem(r39, r40, r38)
    dec_ref r38
    r42 = r41 >= 0 :: signed
    if not r42 goto L28 (error at <module>:12) else goto L11 :: bool
L11:
    r43 = decimal :: module
    r44 = 'Decimal'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L28 (error at <module>:14) else goto L12
L12:
    r46 = object 0
    r47 = [r46]
    r48 = load_address r47
    r49 = PyObject_Vectorcall(r45, r48, 1, 0)
    dec_ref r45
    if is_error(r49) goto L28 (error at <module>:14) else goto L13
L13:
    faster_eth_abi.utils.numeric.ZERO = r49 :: static
    r50 = faster_eth_abi.utils.numeric.globals :: static
    r51 = 'ZERO'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L28 (error at <module>:14) else goto L14 :: bool
L14:
    r54 = decimal :: module
    r55 = 'Decimal'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L28 (error at <module>:15) else goto L15
L15:
    r57 = object 10
    r58 = [r57]
    r59 = load_address r58
    r60 = PyObject_Vectorcall(r56, r59, 1, 0)
    dec_ref r56
    if is_error(r60) goto L28 (error at <module>:15) else goto L16
L16:
    faster_eth_abi.utils.numeric.TEN = r60 :: static
    r61 = faster_eth_abi.utils.numeric.globals :: static
    r62 = 'TEN'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L28 (error at <module>:15) else goto L17 :: bool
L17:
    r65 = decimal :: module
    r66 = 'Decimal'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L28 (error at <module>:17) else goto L18
L18:
    faster_eth_abi.utils.numeric.Decimal = r67 :: static
    r68 = faster_eth_abi.utils.numeric.globals :: static
    r69 = 'Decimal'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L28 (error at <module>:17) else goto L19 :: bool
L19:
    r72 = PyDict_New()
    if is_error(r72) goto L28 (error at <module>:25) else goto L20
L20:
    faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache = r72 :: static
    r73 = faster_eth_abi.utils.numeric.globals :: static
    r74 = '_unsigned_integer_bounds_cache'
    r75 = CPyDict_SetItem(r73, r74, r72)
    dec_ref r72
    r76 = r75 >= 0 :: signed
    if not r76 goto L28 (error at <module>:25) else goto L21 :: bool
L21:
    r77 = PyDict_New()
    if is_error(r77) goto L28 (error at <module>:36) else goto L22
L22:
    faster_eth_abi.utils.numeric._signed_integer_bounds_cache = r77 :: static
    r78 = faster_eth_abi.utils.numeric.globals :: static
    r79 = '_signed_integer_bounds_cache'
    r80 = CPyDict_SetItem(r78, r79, r77)
    dec_ref r77
    r81 = r80 >= 0 :: signed
    if not r81 goto L28 (error at <module>:36) else goto L23 :: bool
L23:
    r82 = PyDict_New()
    if is_error(r82) goto L28 (error at <module>:50) else goto L24
L24:
    faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache = r82 :: static
    r83 = faster_eth_abi.utils.numeric.globals :: static
    r84 = '_unsigned_fixed_bounds_cache'
    r85 = CPyDict_SetItem(r83, r84, r82)
    dec_ref r82
    r86 = r85 >= 0 :: signed
    if not r86 goto L28 (error at <module>:50) else goto L25 :: bool
L25:
    r87 = PyDict_New()
    if is_error(r87) goto L28 (error at <module>:71) else goto L26
L26:
    faster_eth_abi.utils.numeric._signed_fixed_bounds_cache = r87 :: static
    r88 = faster_eth_abi.utils.numeric.globals :: static
    r89 = '_signed_fixed_bounds_cache'
    r90 = CPyDict_SetItem(r88, r89, r87)
    dec_ref r87
    r91 = r90 >= 0 :: signed
    if not r91 goto L28 (error at <module>:71) else goto L27 :: bool
L27:
    return 1
L28:
    r92 = <error> :: None
    return r92

def Copyable.copy(self):
    self :: faster_eth_abi._registry.Copyable
L0:
    unreachable

def Copyable.copy__Copyable_glue(self):
    self :: faster_eth_abi._registry.Copyable
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: faster_eth_abi._registry.Copyable
L0:
    r0 = 'copy'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(faster_eth_abi._registry.Copyable, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: faster_eth_abi._registry.Copyable
    return r5

def Copyable.__copy__(self):
    self, r0, r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = self.copy()
    if is_error(r0) goto L2 (error at __copy__:61) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def Copyable.__copy____Copyable_glue(self):
    self :: faster_eth_abi._registry.Copyable
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4, r5 :: faster_eth_abi._registry.Copyable
L0:
    r0 = '__copy__'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 else goto L1
L1:
    r4 = cast(faster_eth_abi._registry.Copyable, r3)
    if is_error(r4) goto L3 else goto L2
L2:
    return r4
L3:
    r5 = <error> :: faster_eth_abi._registry.Copyable
    return r5

def Copyable.__deepcopy__(self, args):
    self :: faster_eth_abi._registry.Copyable
    args :: tuple
    r0, r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = self.copy()
    if is_error(r0) goto L2 (error at __deepcopy__:64) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def Copyable.__deepcopy____Copyable_glue(self, args):
    self :: faster_eth_abi._registry.Copyable
    args :: tuple
    r0 :: str
    r1, r2 :: object
    r3, r4 :: faster_eth_abi._registry.Copyable
L0:
    r0 = '__deepcopy__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L4 else goto L1
L1:
    r2 = PyObject_CallObject(r1, args)
    dec_ref r1
    if is_error(r2) goto L4 else goto L2
L2:
    r3 = cast(faster_eth_abi._registry.Copyable, r2)
    if is_error(r3) goto L4 else goto L3
L3:
    return r3
L4:
    r4 = <error> :: faster_eth_abi._registry.Copyable
    return r4

def PredicateMapping.__init__(self, name):
    self :: faster_eth_abi._registry.PredicateMapping
    name :: str
    r0 :: bool
    r1 :: dict
    r2 :: bool
    r3 :: dict
    r4 :: bool
    r5 :: None
L0:
    inc_ref name
    self._name = name; r0 = is_error
    if not r0 goto L6 (error at __init__:76) else goto L1 :: bool
L1:
    r1 = PyDict_New()
    if is_error(r1) goto L6 (error at __init__:77) else goto L2
L2:
    self._values = r1; r2 = is_error
    if not r2 goto L6 (error at __init__:77) else goto L3 :: bool
L3:
    r3 = PyDict_New()
    if is_error(r3) goto L6 (error at __init__:78) else goto L4
L4:
    self._labeled_predicates = r3; r4 = is_error
    if not r4 goto L6 (error at __init__:78) else goto L5 :: bool
L5:
    return 1
L6:
    r5 = <error> :: None
    return r5

def PredicateMapping.add(self, predicate, value, label):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: union[str, object]
    value :: object
    label :: union[str, None]
    r0 :: object
    r1 :: dict
    r2 :: i32
    r3 :: bit
    r4 :: bool
    r5, r6, r7, r8, r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14, r15, r16, r17, r18 :: str
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: str
    r23 :: list
    r24, r25, r26, r27, r28 :: ptr
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: bit
    r38 :: dict
    r39 :: str
    r40 :: i32
    r41 :: bit
    r42 :: bool
    r43, r44, r45, r46, r47 :: str
    r48 :: object[3]
    r49 :: object_ptr
    r50 :: object
    r51, r52, r53, r54, r55, r56 :: str
    r57 :: object[3]
    r58 :: object_ptr
    r59 :: object
    r60, r61, r62, r63, r64, r65 :: str
    r66 :: object[3]
    r67 :: object_ptr
    r68 :: object
    r69 :: str
    r70 :: list
    r71, r72, r73, r74, r75, r76, r77 :: ptr
    r78 :: str
    r79 :: object
    r80 :: str
    r81 :: object
    r82 :: object[1]
    r83 :: object_ptr
    r84 :: object
    r85 :: str
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: i32
    r90 :: bit
    r91 :: None
L0:
    if is_error(label) goto L1 else goto L41
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._values
    if is_error(r1) goto L42 (error at add:81) else goto L3
L3:
    r2 = PyDict_Contains(r1, predicate)
    dec_ref r1
    r3 = r2 >= 0 :: signed
    if not r3 goto L42 (error at add:81) else goto L4 :: bool
L4:
    r4 = truncate r2: i32 to builtins.bool
    if r4 goto L43 else goto L16 :: bool
L5:
    r5 = ''
    r6 = 'Matcher '
    r7 = '{!r:{}}'
    r8 = ''
    r9 = 'format'
    r10 = [r7, predicate, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L40 (error at add:82) else goto L6
L6:
    r13 = cast(str, r12)
    if is_error(r13) goto L40 (error at add:82) else goto L7
L7:
    r14 = ' already exists in '
    r15 = '{:{}}'
    r16 = self._name
    if is_error(r16) goto L44 (error at add:82) else goto L8
L8:
    r17 = ''
    r18 = 'format'
    r19 = [r15, r16, r17]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775811, 0)
    if is_error(r21) goto L45 (error at add:82) else goto L9
L9:
    dec_ref r16
    r22 = cast(str, r21)
    if is_error(r22) goto L44 (error at add:82) else goto L10
L10:
    r23 = PyList_New(4)
    if is_error(r23) goto L46 (error at add:82) else goto L11
L11:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r6
    set_mem r25, r6 :: builtins.object*
    r26 = r25 + 8
    set_mem r26, r13 :: builtins.object*
    inc_ref r14
    r27 = r25 + 16
    set_mem r27, r14 :: builtins.object*
    r28 = r25 + 24
    set_mem r28, r22 :: builtins.object*
    r29 = PyUnicode_Join(r5, r23)
    dec_ref r23
    if is_error(r29) goto L40 (error at add:82) else goto L12
L12:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L47 (error at add:82) else goto L13
L13:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L47 (error at add:82) else goto L14
L14:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L40 (error at add:82) else goto L15 :: bool
L15:
    unreachable
L16:
    r36 = load_address _Py_NoneStruct
    r37 = label != r36
    if r37 goto L17 else goto L48 :: bool
L17:
    r38 = self._labeled_predicates
    if is_error(r38) goto L42 (error at add:85) else goto L18
L18:
    inc_ref label
    r39 = cast(str, label)
    if is_error(r39) goto L49 (error at add:86) else goto L19
L19:
    r40 = PyDict_Contains(r38, r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L49 (error at add:86) else goto L20 :: bool
L20:
    r42 = truncate r40: i32 to builtins.bool
    if r42 goto L50 else goto L35 :: bool
L21:
    r43 = ''
    r44 = 'Matcher '
    r45 = '{!r:{}}'
    r46 = ''
    r47 = 'format'
    r48 = [r45, predicate, r46]
    r49 = load_address r48
    r50 = PyObject_VectorcallMethod(r47, r49, 9223372036854775811, 0)
    if is_error(r50) goto L42 (error at add:88) else goto L22
L22:
    r51 = cast(str, r50)
    if is_error(r51) goto L42 (error at add:88) else goto L23
L23:
    r52 = " with label '"
    r53 = '{:{}}'
    r54 = cast(str, label)
    if is_error(r54) goto L51 (error at add:88) else goto L24
L24:
    r55 = ''
    r56 = 'format'
    r57 = [r53, r54, r55]
    r58 = load_address r57
    r59 = PyObject_VectorcallMethod(r56, r58, 9223372036854775811, 0)
    if is_error(r59) goto L52 (error at add:88) else goto L25
L25:
    dec_ref r54
    r60 = cast(str, r59)
    if is_error(r60) goto L51 (error at add:88) else goto L26
L26:
    r61 = "' already exists in "
    r62 = '{:{}}'
    r63 = self._name
    if is_error(r63) goto L53 (error at add:89) else goto L27
L27:
    r64 = ''
    r65 = 'format'
    r66 = [r62, r63, r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775811, 0)
    if is_error(r68) goto L54 (error at add:89) else goto L28
L28:
    dec_ref r63
    r69 = cast(str, r68)
    if is_error(r69) goto L53 (error at add:89) else goto L29
L29:
    r70 = PyList_New(6)
    if is_error(r70) goto L55 (error at add:88) else goto L30
L30:
    r71 = get_element_ptr r70 ob_item :: PyListObject
    r72 = load_mem r71 :: ptr*
    inc_ref r44
    set_mem r72, r44 :: builtins.object*
    r73 = r72 + 8
    set_mem r73, r51 :: builtins.object*
    inc_ref r52
    r74 = r72 + 16
    set_mem r74, r52 :: builtins.object*
    r75 = r72 + 24
    set_mem r75, r60 :: builtins.object*
    inc_ref r61
    r76 = r72 + 32
    set_mem r76, r61 :: builtins.object*
    r77 = r72 + 40
    set_mem r77, r69 :: builtins.object*
    r78 = PyUnicode_Join(r43, r70)
    dec_ref r70
    if is_error(r78) goto L40 (error at add:88) else goto L31
L31:
    r79 = builtins :: module
    r80 = 'ValueError'
    r81 = CPyObject_GetAttr(r79, r80)
    if is_error(r81) goto L56 (error at add:87) else goto L32
L32:
    r82 = [r78]
    r83 = load_address r82
    r84 = PyObject_Vectorcall(r81, r83, 1, 0)
    dec_ref r81
    if is_error(r84) goto L56 (error at add:87) else goto L33
L33:
    dec_ref r78
    CPy_Raise(r84)
    dec_ref r84
    if not 0 goto L40 (error at add:87) else goto L34 :: bool
L34:
    unreachable
L35:
    r85 = cast(str, label)
    if is_error(r85) goto L57 (error at add:92) else goto L36
L36:
    r86 = CPyDict_SetItem(r38, r85, predicate)
    dec_ref r38
    dec_ref r85
    r87 = r86 >= 0 :: signed
    if not r87 goto L40 (error at add:92) else goto L37 :: bool
L37:
    r88 = self._values
    if is_error(r88) goto L40 (error at add:94) else goto L38
L38:
    r89 = CPyDict_SetItem(r88, predicate, value)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L40 (error at add:94) else goto L39 :: bool
L39:
    return 1
L40:
    r91 = <error> :: None
    return r91
L41:
    inc_ref label
    goto L2
L42:
    dec_ref label
    goto L40
L43:
    dec_ref label
    goto L5
L44:
    dec_ref r13
    goto L40
L45:
    dec_ref r13
    dec_ref r16
    goto L40
L46:
    dec_ref r13
    dec_ref r22
    goto L40
L47:
    dec_ref r29
    goto L40
L48:
    dec_ref label
    goto L37
L49:
    dec_ref label
    dec_ref r38
    goto L40
L50:
    dec_ref r38
    goto L21
L51:
    dec_ref r51
    goto L40
L52:
    dec_ref r51
    dec_ref r54
    goto L40
L53:
    dec_ref r51
    dec_ref r60
    goto L40
L54:
    dec_ref r51
    dec_ref r60
    dec_ref r63
    goto L40
L55:
    dec_ref r51
    dec_ref r60
    dec_ref r69
    goto L40
L56:
    dec_ref r78
    goto L40
L57:
    dec_ref r38
    goto L40

def PredicateMapping.find(self, type_str):
    self :: faster_eth_abi._registry.PredicateMapping
    type_str :: object
    r0 :: list
    r1 :: dict
    r2 :: short_int
    r3 :: native_int
    r4 :: object
    r5 :: tuple[bool, short_int, object, object]
    r6 :: short_int
    r7 :: bool
    r8, r9 :: object
    predicate :: union[str, object]
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: bool
    r16 :: tuple[union[str, object], object]
    r17 :: object
    r18 :: i32
    r19, r20, r21 :: bit
    r22 :: tuple
    r23 :: ptr
    r24 :: native_int
    r25 :: short_int
    r26 :: bit
    r27, r28, r29, r30, r31 :: str
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: object[1]
    r36 :: object_ptr
    r37, r38 :: object
    r39 :: str
    r40, r41 :: object
    r42 :: tuple
    r43 :: i32
    r44 :: bit
    r45, r46 :: object
    r47, r48 :: tuple
    r49 :: ptr
    r50 :: native_int
    r51 :: short_int
    r52 :: bit
    r53 :: str
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: str
    r59 :: object
    r60 :: object[2]
    r61 :: object_ptr
    r62 :: object
    r63, r64, r65, r66, r67, r68, r69, r70 :: str
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: object[1]
    r75 :: object_ptr
    r76, r77, r78 :: object
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L39 (error at find:102) else goto L1
L1:
    r1 = self._values
    if is_error(r1) goto L40 (error at find:104) else goto L2
L2:
    r2 = 0
    r3 = PyDict_Size(r1)
    r4 = CPyDict_GetItemsIter(r1)
    if is_error(r4) goto L41 (error at find:102) else goto L3
L3:
    r5 = CPyDict_NextItem(r4, r2)
    r6 = r5[1]
    r2 = r6
    r7 = r5[0]
    if r7 goto L4 else goto L42 :: bool
L4:
    r8 = r5[2]
    r9 = r5[3]
    dec_ref r5
    predicate = r8
    r10 = [type_str]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(predicate, r11, 1, 0)
    if is_error(r12) goto L43 (error at find:105) else goto L5
L5:
    r13 = PyObject_IsTrue(r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L43 (error at find:105) else goto L6 :: bool
L6:
    r15 = truncate r13: i32 to builtins.bool
    if r15 goto L7 else goto L44 :: bool
L7:
    r16 = (predicate, r9)
    r17 = box(tuple[union[str, object], object], r16)
    r18 = PyList_Append(r0, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L45 (error at find:102) else goto L8 :: bool
L8:
    r20 = CPyDict_CheckSize(r1, r3)
    if not r20 goto L45 (error at find:102) else goto L3 :: bool
L9:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L40 (error at find:102) else goto L10 :: bool
L10:
    r22 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r22) goto L39 (error at find:102) else goto L11
L11:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    r25 = r24 << 1
    r26 = r25 == 0
    if r26 goto L46 else goto L19 :: bool
L12:
    r27 = "No matching entries for '"
    r28 = PyObject_Str(type_str)
    if is_error(r28) goto L39 (error at find:110) else goto L13
L13:
    r29 = "' in "
    r30 = self._name
    if is_error(r30) goto L47 (error at find:110) else goto L14
L14:
    r31 = CPyStr_Build(4, r27, r28, r29, r30)
    dec_ref r28
    dec_ref r30
    if is_error(r31) goto L39 (error at find:110) else goto L15
L15:
    r32 = faster_eth_abi._registry.globals :: static
    r33 = 'NoEntriesFound'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L48 (error at find:109) else goto L16
L16:
    r35 = [r31]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r34, r36, 1, 0)
    dec_ref r34
    if is_error(r37) goto L48 (error at find:109) else goto L17
L17:
    dec_ref r31
    CPy_Raise(r37)
    dec_ref r37
    if not 0 goto L39 (error at find:109) else goto L18 :: bool
L18:
    unreachable
L19:
    r38 = builtins :: module
    r39 = 'zip'
    r40 = CPyObject_GetAttr(r38, r39)
    if is_error(r40) goto L49 (error at find:113) else goto L20
L20:
    r41 = PyObject_CallObject(r40, r22)
    dec_ref r40
    if is_error(r41) goto L49 (error at find:113) else goto L21
L21:
    r42 = PySequence_Tuple(r41)
    dec_ref r41
    if is_error(r42) goto L49 (error at find:113) else goto L22
L22:
    r43 = CPySequence_CheckUnpackCount(r42, 2)
    r44 = r43 >= 0 :: signed
    if not r44 goto L50 (error at find:113) else goto L23 :: bool
L23:
    r45 = CPySequenceTuple_GetItemUnsafe(r42, 0)
    r46 = CPySequenceTuple_GetItemUnsafe(r42, 1)
    dec_ref r42
    r47 = cast(tuple, r45)
    if is_error(r47) goto L51 (error at find:113) else goto L24
L24:
    r48 = cast(tuple, r46)
    if is_error(r48) goto L52 (error at find:113) else goto L25
L25:
    r49 = get_element_ptr r22 ob_size :: PyVarObject
    r50 = load_mem r49 :: native_int*
    dec_ref r22
    r51 = r50 << 1
    r52 = r51 > 2 :: signed
    if r52 goto L53 else goto L54 :: bool
L26:
    r53 = ', '
    r54 = builtins :: module
    r55 = 'repr'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L55 (error at find:116) else goto L27
L27:
    r57 = builtins :: module
    r58 = 'map'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L56 (error at find:116) else goto L28
L28:
    r60 = [r56, r47]
    r61 = load_address r60
    r62 = PyObject_Vectorcall(r59, r61, 2, 0)
    dec_ref r59
    if is_error(r62) goto L56 (error at find:116) else goto L29
L29:
    dec_ref r56
    dec_ref r47
    r63 = PyUnicode_Join(r53, r62)
    dec_ref r62
    if is_error(r63) goto L39 (error at find:116) else goto L30
L30:
    r64 = "Multiple matching entries for '"
    r65 = PyObject_Str(type_str)
    if is_error(r65) goto L57 (error at find:118) else goto L31
L31:
    r66 = "' in "
    r67 = self._name
    if is_error(r67) goto L58 (error at find:118) else goto L32
L32:
    r68 = ': '
    r69 = '. This occurs when two registrations match the same type string. You may need to delete one of the registrations or modify its matching behavior to ensure it doesn\'t collide with other registrations. See the "Registry" documentation for more information.'
    r70 = CPyStr_Build(7, r64, r65, r66, r67, r68, r63, r69)
    dec_ref r65
    dec_ref r67
    dec_ref r63
    if is_error(r70) goto L39 (error at find:118) else goto L33
L33:
    r71 = faster_eth_abi._registry.globals :: static
    r72 = 'MultipleEntriesFound'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L59 (error at find:117) else goto L34
L34:
    r74 = [r70]
    r75 = load_address r74
    r76 = PyObject_Vectorcall(r73, r75, 1, 0)
    dec_ref r73
    if is_error(r76) goto L59 (error at find:117) else goto L35
L35:
    dec_ref r70
    CPy_Raise(r76)
    dec_ref r76
    if not 0 goto L39 (error at find:117) else goto L36 :: bool
L36:
    unreachable
L37:
    r77 = CPySequenceTuple_GetItem(r48, 0)
    dec_ref r48
    if is_error(r77) goto L39 (error at find:126) else goto L38
L38:
    return r77
L39:
    r78 = <error> :: object
    return r78
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    dec_ref r1
    goto L39
L42:
    dec_ref r1
    dec_ref r4
    dec_ref r5
    goto L9
L43:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    dec_ref predicate
    dec_ref r9
    goto L39
L44:
    dec_ref predicate
    dec_ref r9
    goto L8
L45:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    goto L39
L46:
    dec_ref r22
    goto L12
L47:
    dec_ref r28
    goto L39
L48:
    dec_ref r31
    goto L39
L49:
    dec_ref r22
    goto L39
L50:
    dec_ref r22
    dec_ref r42
    goto L39
L51:
    dec_ref r22
    dec_ref r46
    goto L39
L52:
    dec_ref r22
    dec_ref r47
    goto L39
L53:
    dec_ref r48
    goto L26
L54:
    dec_ref r47
    goto L37
L55:
    dec_ref r47
    goto L39
L56:
    dec_ref r47
    dec_ref r56
    goto L39
L57:
    dec_ref r63
    goto L39
L58:
    dec_ref r63
    dec_ref r65
    goto L39
L59:
    dec_ref r70
    goto L39

def PredicateMapping.remove_by_equality(self, predicate):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: union[str, object]
    r0 :: dict
    r1 :: i32
    r2 :: bit
    r3 :: tuple[object, object, object]
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: bit
    r8, r9, r10, r11, r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16, r17, r18, r19, r20, r21 :: str
    r22 :: object[3]
    r23 :: object_ptr
    r24 :: object
    r25 :: str
    r26 :: list
    r27, r28, r29, r30, r31 :: ptr
    r32 :: str
    r33 :: object
    r34 :: str
    r35 :: object
    r36 :: object[1]
    r37 :: object_ptr
    r38 :: object
    r39 :: bit
    r40 :: str
    r41 :: tuple[object, object, object]
    r42 :: object
    r43 :: str
    r44 :: object
    r45, r46 :: bit
    r47 :: dict
    r48 :: i32
    r49 :: bit
    r50 :: None
L0:
L1:
    r0 = self._values
    if is_error(r0) goto L3 (error at remove_by_equality:131) else goto L2
L2:
    r1 = PyObject_DelItem(r0, predicate)
    dec_ref r0
    r2 = r1 >= 0 :: signed
    if not r2 goto L3 (error at remove_by_equality:131) else goto L20 :: bool
L3:
    r3 = CPy_CatchError()
    r4 = builtins :: module
    r5 = 'KeyError'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at remove_by_equality:132) else goto L4
L4:
    r7 = CPy_ExceptionMatches(r6)
    dec_ref r6
    if r7 goto L5 else goto L16 :: bool
L5:
    r8 = ''
    r9 = 'Matcher '
    r10 = '{!r:{}}'
    r11 = ''
    r12 = 'format'
    r13 = [r10, predicate, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L18 (error at remove_by_equality:133) else goto L6
L6:
    r16 = cast(str, r15)
    if is_error(r16) goto L18 (error at remove_by_equality:133) else goto L7
L7:
    r17 = ' not found in '
    r18 = '{:{}}'
    r19 = self._name
    if is_error(r19) goto L33 (error at remove_by_equality:133) else goto L8
L8:
    r20 = ''
    r21 = 'format'
    r22 = [r18, r19, r20]
    r23 = load_address r22
    r24 = PyObject_VectorcallMethod(r21, r23, 9223372036854775811, 0)
    if is_error(r24) goto L34 (error at remove_by_equality:133) else goto L9
L9:
    dec_ref r19
    r25 = cast(str, r24)
    if is_error(r25) goto L33 (error at remove_by_equality:133) else goto L10
L10:
    r26 = PyList_New(4)
    if is_error(r26) goto L35 (error at remove_by_equality:133) else goto L11
L11:
    r27 = get_element_ptr r26 ob_item :: PyListObject
    r28 = load_mem r27 :: ptr*
    inc_ref r9
    set_mem r28, r9 :: builtins.object*
    r29 = r28 + 8
    set_mem r29, r16 :: builtins.object*
    inc_ref r17
    r30 = r28 + 16
    set_mem r30, r17 :: builtins.object*
    r31 = r28 + 24
    set_mem r31, r25 :: builtins.object*
    r32 = PyUnicode_Join(r8, r26)
    dec_ref r26
    if is_error(r32) goto L18 (error at remove_by_equality:133) else goto L12
L12:
    r33 = builtins :: module
    r34 = 'KeyError'
    r35 = CPyObject_GetAttr(r33, r34)
    if is_error(r35) goto L36 (error at remove_by_equality:133) else goto L13
L13:
    r36 = [r32]
    r37 = load_address r36
    r38 = PyObject_Vectorcall(r35, r37, 1, 0)
    dec_ref r35
    if is_error(r38) goto L36 (error at remove_by_equality:133) else goto L14
L14:
    dec_ref r32
    CPy_Raise(r38)
    dec_ref r38
    if not 0 goto L18 (error at remove_by_equality:133) else goto L37 :: bool
L15:
    unreachable
L16:
    CPy_Reraise()
    if not 0 goto L18 else goto L38 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r3)
    dec_ref r3
    r39 = CPy_KeepPropagating()
    if not r39 goto L32 else goto L19 :: bool
L19:
    unreachable
L20:
    r40 = self._label_for_predicate(predicate)
    if is_error(r40) goto L22 (error at remove_by_equality:137) else goto L21
L21:
    goto L29
L22:
    r41 = CPy_CatchError()
    r42 = builtins :: module
    r43 = 'ValueError'
    r44 = CPyObject_GetAttr(r42, r43)
    if is_error(r44) goto L27 (error at remove_by_equality:138) else goto L23
L23:
    r45 = CPy_ExceptionMatches(r44)
    dec_ref r44
    if r45 goto L26 else goto L24 :: bool
L24:
    CPy_Reraise()
    if not 0 goto L27 else goto L39 :: bool
L25:
    unreachable
L26:
    CPy_RestoreExcInfo(r41)
    dec_ref r41
    goto L31
L27:
    CPy_RestoreExcInfo(r41)
    dec_ref r41
    r46 = CPy_KeepPropagating()
    if not r46 goto L32 else goto L28 :: bool
L28:
    unreachable
L29:
    r47 = self._labeled_predicates
    if is_error(r47) goto L40 (error at remove_by_equality:141) else goto L30
L30:
    r48 = PyObject_DelItem(r47, r40)
    dec_ref r47
    dec_ref r40
    r49 = r48 >= 0 :: signed
    if not r49 goto L32 (error at remove_by_equality:141) else goto L31 :: bool
L31:
    return 1
L32:
    r50 = <error> :: None
    return r50
L33:
    dec_ref r16
    goto L18
L34:
    dec_ref r16
    dec_ref r19
    goto L18
L35:
    dec_ref r16
    dec_ref r25
    goto L18
L36:
    dec_ref r32
    goto L18
L37:
    dec_ref r3
    goto L15
L38:
    dec_ref r3
    goto L17
L39:
    dec_ref r41
    goto L25
L40:
    dec_ref r40
    goto L32

def PredicateMapping._label_for_predicate(self, predicate):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: union[str, object]
    r0 :: dict
    r1 :: short_int
    r2 :: native_int
    r3 :: object
    r4 :: tuple[bool, short_int, object, object]
    r5 :: short_int
    r6 :: bool
    r7, r8 :: object
    r9 :: str
    value :: union[str, object]
    r10, r11, r12 :: bit
    r13, r14, r15, r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21, r22, r23, r24, r25, r26 :: str
    r27 :: object[3]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: list
    r32, r33, r34, r35, r36 :: ptr
    r37 :: str
    r38 :: object
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: str
L0:
    r0 = self._labeled_predicates
    if is_error(r0) goto L19 (error at _label_for_predicate:146) else goto L1
L1:
    r1 = 0
    r2 = PyDict_Size(r0)
    r3 = CPyDict_GetItemsIter(r0)
    if is_error(r3) goto L20 (error at _label_for_predicate:146) else goto L2
L2:
    r4 = CPyDict_NextItem(r3, r1)
    r5 = r4[1]
    r1 = r5
    r6 = r4[0]
    if r6 goto L3 else goto L21 :: bool
L3:
    r7 = r4[2]
    r8 = r4[3]
    dec_ref r4
    r9 = cast(str, r7)
    if is_error(r9) goto L22 (error at _label_for_predicate:146) else goto L4
L4:
    value = r8
    r10 = value == predicate
    dec_ref value
    if r10 goto L23 else goto L24 :: bool
L5:
    return r9
L6:
    r11 = CPyDict_CheckSize(r0, r2)
    if not r11 goto L25 (error at _label_for_predicate:146) else goto L2 :: bool
L7:
    r12 = CPy_NoErrOccurred()
    if not r12 goto L19 (error at _label_for_predicate:146) else goto L8 :: bool
L8:
    r13 = ''
    r14 = 'Matcher '
    r15 = '{!r:{}}'
    r16 = ''
    r17 = 'format'
    r18 = [r15, predicate, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L19 (error at _label_for_predicate:151) else goto L9
L9:
    r21 = cast(str, r20)
    if is_error(r21) goto L19 (error at _label_for_predicate:151) else goto L10
L10:
    r22 = ' not referred to by any label in '
    r23 = '{:{}}'
    r24 = self._name
    if is_error(r24) goto L26 (error at _label_for_predicate:151) else goto L11
L11:
    r25 = ''
    r26 = 'format'
    r27 = [r23, r24, r25]
    r28 = load_address r27
    r29 = PyObject_VectorcallMethod(r26, r28, 9223372036854775811, 0)
    if is_error(r29) goto L27 (error at _label_for_predicate:151) else goto L12
L12:
    dec_ref r24
    r30 = cast(str, r29)
    if is_error(r30) goto L26 (error at _label_for_predicate:151) else goto L13
L13:
    r31 = PyList_New(4)
    if is_error(r31) goto L28 (error at _label_for_predicate:151) else goto L14
L14:
    r32 = get_element_ptr r31 ob_item :: PyListObject
    r33 = load_mem r32 :: ptr*
    inc_ref r14
    set_mem r33, r14 :: builtins.object*
    r34 = r33 + 8
    set_mem r34, r21 :: builtins.object*
    inc_ref r22
    r35 = r33 + 16
    set_mem r35, r22 :: builtins.object*
    r36 = r33 + 24
    set_mem r36, r30 :: builtins.object*
    r37 = PyUnicode_Join(r13, r31)
    dec_ref r31
    if is_error(r37) goto L19 (error at _label_for_predicate:151) else goto L15
L15:
    r38 = builtins :: module
    r39 = 'ValueError'
    r40 = CPyObject_GetAttr(r38, r39)
    if is_error(r40) goto L29 (error at _label_for_predicate:150) else goto L16
L16:
    r41 = [r37]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L29 (error at _label_for_predicate:150) else goto L17
L17:
    dec_ref r37
    CPy_Raise(r43)
    dec_ref r43
    if not 0 goto L19 (error at _label_for_predicate:150) else goto L18 :: bool
L18:
    unreachable
L19:
    r44 = <error> :: str
    return r44
L20:
    dec_ref r0
    goto L19
L21:
    dec_ref r0
    dec_ref r3
    dec_ref r4
    goto L7
L22:
    dec_ref r0
    dec_ref r3
    dec_ref r8
    goto L19
L23:
    dec_ref r0
    dec_ref r3
    goto L5
L24:
    dec_ref r9
    goto L6
L25:
    dec_ref r0
    dec_ref r3
    goto L19
L26:
    dec_ref r21
    goto L19
L27:
    dec_ref r21
    dec_ref r24
    goto L19
L28:
    dec_ref r21
    dec_ref r30
    goto L19
L29:
    dec_ref r37
    goto L19

def PredicateMapping.remove_by_label(self, label):
    self :: faster_eth_abi._registry.PredicateMapping
    label :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    predicate :: union[str, object, None]
    r6 :: object
    r7 :: bit
    r8, r9, r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: dict
    r19 :: i32
    r20 :: bit
    r21 :: None
L0:
    r0 = self._labeled_predicates
    if is_error(r0) goto L12 (error at remove_by_label:155) else goto L1
L1:
    r1 = 'pop'
    r2 = box(None, 1)
    r3 = [r0, label, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L13 (error at remove_by_label:155) else goto L2
L2:
    dec_ref r0
    predicate = r5
    r6 = load_address _Py_NoneStruct
    r7 = predicate == r6
    if r7 goto L14 else goto L9 :: bool
L3:
    r8 = "Label '"
    r9 = "' not found in "
    r10 = self._name
    if is_error(r10) goto L12 (error at remove_by_label:157) else goto L4
L4:
    r11 = CPyStr_Build(4, r8, label, r9, r10)
    dec_ref r10
    if is_error(r11) goto L12 (error at remove_by_label:157) else goto L5
L5:
    r12 = builtins :: module
    r13 = 'KeyError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L15 (error at remove_by_label:157) else goto L6
L6:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L15 (error at remove_by_label:157) else goto L7
L7:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L12 (error at remove_by_label:157) else goto L8 :: bool
L8:
    unreachable
L9:
    r18 = self._values
    if is_error(r18) goto L16 (error at remove_by_label:159) else goto L10
L10:
    r19 = PyObject_DelItem(r18, predicate)
    dec_ref r18
    dec_ref predicate
    r20 = r19 >= 0 :: signed
    if not r20 goto L12 (error at remove_by_label:159) else goto L11 :: bool
L11:
    return 1
L12:
    r21 = <error> :: None
    return r21
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref predicate
    goto L3
L15:
    dec_ref r11
    goto L12
L16:
    dec_ref predicate
    goto L12

def PredicateMapping.remove(self, predicate_or_label):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate_or_label :: union[str, object]
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bool
    r7 :: None
    r8 :: bit
    r9 :: str
    r10 :: None
    r11, r12, r13 :: str
    r14 :: object
    r15, r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20 :: list
    r21, r22, r23 :: ptr
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: None
L0:
    r0 = builtins :: module
    r1 = 'callable'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L16 (error at remove:162) else goto L1
L1:
    r3 = [predicate_or_label]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L16 (error at remove:162) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L16 (error at remove:162) else goto L3
L3:
    if r6 goto L4 else goto L5 :: bool
L4:
    r7 = self.remove_by_equality(predicate_or_label)
    if is_error(r7) goto L16 (error at remove:163) else goto L15
L5:
    r8 = PyUnicode_Check(predicate_or_label)
    if r8 goto L6 else goto L8 :: bool
L6:
    inc_ref predicate_or_label
    r9 = cast(str, predicate_or_label)
    if is_error(r9) goto L16 (error at remove:165) else goto L7
L7:
    r10 = self.remove_by_label(r9)
    dec_ref r9
    if is_error(r10) goto L16 (error at remove:165) else goto L15
L8:
    r11 = ''
    r12 = 'Key to be removed must be callable or string: got '
    r13 = '{:{}}'
    r14 = CPy_TYPE(predicate_or_label)
    r15 = ''
    r16 = 'format'
    r17 = [r13, r14, r15]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r16, r18, 9223372036854775811, 0)
    if is_error(r19) goto L17 (error at remove:169) else goto L9
L9:
    dec_ref r14
    r20 = PyList_New(2)
    if is_error(r20) goto L18 (error at remove:168) else goto L10
L10:
    r21 = get_element_ptr r20 ob_item :: PyListObject
    r22 = load_mem r21 :: ptr*
    inc_ref r12
    set_mem r22, r12 :: builtins.object*
    r23 = r22 + 8
    set_mem r23, r19 :: builtins.object*
    r24 = PyUnicode_Join(r11, r20)
    dec_ref r20
    if is_error(r24) goto L16 (error at remove:168) else goto L11
L11:
    r25 = builtins :: module
    r26 = 'TypeError'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L19 (error at remove:167) else goto L12
L12:
    r28 = [r24]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r27, r29, 1, 0)
    dec_ref r27
    if is_error(r30) goto L19 (error at remove:167) else goto L13
L13:
    dec_ref r24
    CPy_Raise(r30)
    dec_ref r30
    if not 0 goto L16 (error at remove:167) else goto L14 :: bool
L14:
    unreachable
L15:
    return 1
L16:
    r31 = <error> :: None
    return r31
L17:
    dec_ref r14
    goto L16
L18:
    dec_ref r19
    goto L16
L19:
    dec_ref r24
    goto L16

def PredicateMapping.copy(self):
    self :: faster_eth_abi._registry.PredicateMapping
    r0 :: object
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: faster_eth_abi._registry.PredicateMapping
    r6 :: dict
    r7 :: object
    r8 :: bool
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: dict
    r13 :: bool
    r14 :: dict
    r15 :: object
    r16 :: bool
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: bool
    r22 :: faster_eth_abi._registry.PredicateMapping
L0:
    r0 = CPy_TYPE(self)
    r1 = self._name
    if is_error(r1) goto L19 (error at copy:173) else goto L1
L1:
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    dec_ref r0
    if is_error(r4) goto L20 (error at copy:173) else goto L2
L2:
    dec_ref r1
    r5 = cast(faster_eth_abi._registry.PredicateMapping, r4)
    if is_error(r5) goto L18 (error at copy:173) else goto L3
L3:
    r6 = self._values
    if is_error(r6) goto L21 (error at copy:175) else goto L4
L4:
    r7 = faster_eth_abi._registry.copy :: static
    if is_error(r7) goto L22 else goto L7
L5:
    r8 = raise NameError('value for final name "copy" was not set')
    if not r8 goto L18 (error at copy:175) else goto L6 :: bool
L6:
    unreachable
L7:
    r9 = [r6]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 1, 0)
    if is_error(r11) goto L23 (error at copy:175) else goto L8
L8:
    dec_ref r6
    r12 = cast(dict, r11)
    if is_error(r12) goto L21 (error at copy:175) else goto L9
L9:
    r5._values = r12; r13 = is_error
    if not r13 goto L21 (error at copy:175) else goto L10 :: bool
L10:
    r14 = self._labeled_predicates
    if is_error(r14) goto L21 (error at copy:176) else goto L11
L11:
    r15 = faster_eth_abi._registry.copy :: static
    if is_error(r15) goto L24 else goto L14
L12:
    r16 = raise NameError('value for final name "copy" was not set')
    if not r16 goto L18 (error at copy:176) else goto L13 :: bool
L13:
    unreachable
L14:
    r17 = [r14]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r15, r18, 1, 0)
    if is_error(r19) goto L25 (error at copy:176) else goto L15
L15:
    dec_ref r14
    r20 = cast(dict, r19)
    if is_error(r20) goto L21 (error at copy:176) else goto L16
L16:
    r5._labeled_predicates = r20; r21 = is_error
    if not r21 goto L21 (error at copy:176) else goto L17 :: bool
L17:
    return r5
L18:
    r22 = <error> :: faster_eth_abi._registry.PredicateMapping
    return r22
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r1
    goto L18
L21:
    dec_ref r5
    goto L18
L22:
    dec_ref r5
    dec_ref r6
    goto L5
L23:
    dec_ref r5
    dec_ref r6
    goto L18
L24:
    dec_ref r5
    dec_ref r14
    goto L12
L25:
    dec_ref r5
    dec_ref r14
    goto L18

def PredicateMapping.copy__Copyable_glue(self):
    self, r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = PredicateMapping.copy(self)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def Predicate.__call__(self, arg):
    self :: faster_eth_abi._registry.Predicate
    arg, r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
L0:
    r0 = 'Must implement `__call__`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at __call__:192) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __call__:192) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at __call__:192) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: bool
    return r7

def Predicate.__str__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
L0:
    r0 = 'Must implement `__str__`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at __str__:195) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __str__:195) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at __str__:195) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: str
    return r7

def Predicate.__repr__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: str
    r1, r2 :: object
    r3, r4, r5, r6, r7, r8 :: str
L0:
    r0 = '<'
    r1 = CPy_TYPE(self)
    r2 = CPy_GetName(r1)
    dec_ref r1
    if is_error(r2) goto L5 (error at __repr__:198) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L5 (error at __repr__:198) else goto L2
L2:
    r4 = ' '
    r5 = PyObject_Str(self)
    if is_error(r5) goto L6 (error at __repr__:198) else goto L3
L3:
    r6 = '>'
    r7 = CPyStr_Build(5, r0, r3, r4, r5, r6)
    dec_ref r3
    dec_ref r5
    if is_error(r7) goto L5 (error at __repr__:198) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: str
    return r8
L6:
    dec_ref r3
    goto L5

def __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: faster_eth_abi._registry.Predicate
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: bool
    r8 :: tuple
    r9 :: ptr
    r10 :: native_int
    r11, r12 :: bool
    r13, r14 :: native_int
    r15 :: bit
    r16 :: tuple
    r17 :: native_int
    r18 :: object
    r19 :: bool
    r20 :: faster_eth_abi._registry.Predicate
    r21, r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: bit
    r26, r27 :: native_int
    r28 :: bool
    r29 :: object
    r30 :: bool
    r31, r32 :: bit
    r33 :: bool
    r34 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L31
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L35 (error at __iter__:200) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r3) goto L35 (error at __iter__:201) else goto L5
L5:
    r4 = '__attrs__'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L35 (error at __iter__:201) else goto L6
L6:
    r6 = cast(tuple, r5)
    if is_error(r6) goto L35 (error at __iter__:201) else goto L7
L7:
    __mypyc_self__.__mypyc_temp__0 = r6; r7 = is_error
    if not r7 goto L35 (error at __iter__:-1) else goto L8 :: bool
L8:
    r8 = __mypyc_self__.__mypyc_temp__0
    if is_error(r8) goto L35 (error at __iter__:201) else goto L9
L9:
    r9 = get_element_ptr r8 ob_size :: PyVarObject
    r10 = load_mem r9 :: native_int*
    dec_ref r8
    __mypyc_self__.__mypyc_temp__1 = r10; r11 = is_error
    if not r11 goto L35 (error at __iter__:-1) else goto L10 :: bool
L10:
    __mypyc_self__.__mypyc_temp__2 = 0; r12 = is_error
    if not r12 goto L35 (error at __iter__:-1) else goto L11 :: bool
L11:
    r13 = __mypyc_self__.__mypyc_temp__1
    if is_error(r13) goto L35 (error at __iter__:201) else goto L12
L12:
    r14 = __mypyc_self__.__mypyc_temp__2
    if is_error(r14) goto L35 (error at __iter__:201) else goto L13
L13:
    r15 = r14 < r13 :: signed
    if r15 goto L14 else goto L26 :: bool
L14:
    r16 = __mypyc_self__.__mypyc_temp__0
    if is_error(r16) goto L35 (error at __iter__:201) else goto L15
L15:
    r17 = __mypyc_self__.__mypyc_temp__2
    if is_error(r17) goto L36 (error at __iter__:201) else goto L16
L16:
    r18 = CPySequenceTuple_GetItemUnsafe(r16, r17)
    dec_ref r16
    __mypyc_self__.__mypyc_generator_attribute__attr = r18; r19 = is_error
    if not r19 goto L35 (error at __iter__:201) else goto L17 :: bool
L17:
    r20 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r20) goto L35 (error at __iter__:202) else goto L18
L18:
    r21 = __mypyc_self__.__mypyc_generator_attribute__attr
    if is_error(r21) goto L37 (error at __iter__:202) else goto L19
L19:
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    dec_ref r21
    if is_error(r22) goto L35 (error at __iter__:202) else goto L20
L20:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r22
L21:
    r24 = load_address _Py_NoneStruct
    r25 = type != r24
    if r25 goto L22 else goto L24 :: bool
L22:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L35 (error at __iter__:202) else goto L23 :: bool
L23:
    unreachable
L24:
    r26 = __mypyc_self__.__mypyc_temp__2
    if is_error(r26) goto L35 (error at __iter__:201) else goto L25
L25:
    r27 = r26 + 1
    __mypyc_self__.__mypyc_temp__2 = r27; r28 = is_error
    if not r28 goto L35 (error at __iter__:201) else goto L11 :: bool
L26:
    r29 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L27:
    if is_error(stop_iter_ptr) goto L28 else goto L30
L28:
    CPyGen_SetStopIterationValue(r29)
    if not 0 goto L35 else goto L29 :: bool
L29:
    unreachable
L30:
    inc_ref r29
    set_mem stop_iter_ptr, r29 :: builtins.object*
    return 0
L31:
    r31 = r0 == 0
    if r31 goto L1 else goto L32 :: bool
L32:
    r32 = r0 == 1
    if r32 goto L21 else goto L33 :: bool
L33:
    r33 = raise StopIteration
    if not r33 goto L35 (error at __iter__:200) else goto L34 :: bool
L34:
    unreachable
L35:
    r34 = <error> :: object
    return r34
L36:
    dec_ref r16
    goto L35
L37:
    dec_ref r20
    goto L35

def __iter___Predicate_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___Predicate_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___Predicate_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___Predicate_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___Predicate_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def Predicate.__iter__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: faster_eth_abi._registry.__iter___Predicate_gen
    r1, r2 :: bool
    r3 :: faster_eth_abi._registry.__iter___Predicate_gen
L0:
    r0 = __iter___Predicate_gen()
    if is_error(r0) goto L3 (error at __iter__:200) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L4 (error at __iter__:200) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: faster_eth_abi._registry.__iter___Predicate_gen
    return r3
L4:
    dec_ref r0
    goto L3

def Predicate.__hash__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: tuple
    r1, r2 :: int
L0:
    r0 = PySequence_Tuple(self)
    if is_error(r0) goto L3 (error at __hash__:205) else goto L1
L1:
    r1 = CPyObject_Hash(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at __hash__:205) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: int
    return r2

def Predicate.__eq__(self, other):
    self, other :: faster_eth_abi._registry.Predicate
    r0, r1 :: object
    r2 :: bit
    r3 :: bool
    r4, r5 :: tuple
    r6 :: object
    r7 :: bool
    r8, r9 :: object
L0:
    r0 = CPy_TYPE(self)
    r1 = CPy_TYPE(other)
    r2 = r0 == r1
    dec_ref r0
    dec_ref r1
    if r2 goto L2 else goto L1 :: bool
L1:
    r3 = r2
    goto L7
L2:
    r4 = PySequence_Tuple(self)
    if is_error(r4) goto L8 (error at __eq__:208) else goto L3
L3:
    r5 = PySequence_Tuple(other)
    if is_error(r5) goto L9 (error at __eq__:208) else goto L4
L4:
    r6 = PyObject_RichCompare(r4, r5, 2)
    dec_ref r4
    dec_ref r5
    if is_error(r6) goto L8 (error at __eq__:208) else goto L5
L5:
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L8 (error at __eq__:208) else goto L6
L6:
    r3 = r7
L7:
    r8 = box(bool, r3)
    inc_ref r8
    return r8
L8:
    r9 = <error> :: object
    return r9
L9:
    dec_ref r4
    goto L8

def Predicate.__ne__(__mypyc_self__, rhs):
    __mypyc_self__ :: faster_eth_abi._registry.Predicate
    rhs, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4, r5 :: bit
    r6 :: object
    r7 :: bit
    r8 :: i32
    r9 :: bit
    r10 :: bool
    r11, r12 :: object
L0:
    r0 = __mypyc_self__.__eq__(rhs)
    if is_error(r0) goto L10 else goto L1
L1:
    r1 = load_address _Py_NotImplementedStruct
    r2 = r0 == r1
    if r2 goto L11 else goto L2 :: bool
L2:
    r3 = load_global Py_True :: static
    r4 = r0 == r3
    if r4 goto L12 else goto L4 :: bool
L3:
    r5 = 0
    goto L8
L4:
    r6 = load_global Py_False :: static
    r7 = r0 == r6
    if r7 goto L13 else goto L6 :: bool
L5:
    r5 = 1
    goto L8
L6:
    r8 = PyObject_Not(r0)
    dec_ref r0
    r9 = r8 >= 0 :: signed
    if not r9 goto L10 else goto L7 :: bool
L7:
    r10 = truncate r8: i32 to builtins.bool
    r5 = r10
L8:
    r11 = box(bit, r5)
    inc_ref r11
    return r11
L9:
    inc_ref r1
    return r1
L10:
    r12 = <error> :: object
    return r12
L11:
    dec_ref r0
    goto L9
L12:
    dec_ref r0
    goto L3
L13:
    dec_ref r0
    goto L5

def Equals.__init__(self, value):
    self :: faster_eth_abi._registry.Equals
    value :: str
    r0 :: bool
    r1 :: None
L0:
    inc_ref value
    self.value = value; r0 = is_error
    if not r0 goto L2 (error at __init__:222) else goto L1 :: bool
L1:
    return 1
L2:
    r1 = <error> :: None
    return r1

def Equals.__call__(self, other):
    self :: faster_eth_abi._registry.Equals
    other :: object
    r0 :: str
    r1 :: object
    r2 :: i32
    r3 :: bit
    r4, r5 :: bool
L0:
    r0 = self.value
    if is_error(r0) goto L4 (error at __call__:230) else goto L1
L1:
    r1 = PyObject_RichCompare(r0, other, 2)
    dec_ref r0
    if is_error(r1) goto L4 (error at __call__:230) else goto L2
L2:
    r2 = PyObject_IsTrue(r1)
    dec_ref r1
    r3 = r2 >= 0 :: signed
    if not r3 goto L4 (error at __call__:230) else goto L3 :: bool
L3:
    r4 = truncate r2: i32 to builtins.bool
    return r4
L4:
    r5 = <error> :: bool
    return r5

def Equals.__call____Predicate_glue(self, arg):
    self :: faster_eth_abi._registry.Equals
    arg :: str
    r0, r1 :: bool
L0:
    r0 = Equals.__call__(self, arg)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bool
    return r1

def Equals.__str__(self):
    self :: faster_eth_abi._registry.Equals
    r0, r1, r2, r3, r4, r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: str
    r11 :: list
    r12, r13, r14, r15 :: ptr
    r16, r17 :: str
L0:
    r0 = ''
    r1 = '(== '
    r2 = '{!r:{}}'
    r3 = self.value
    if is_error(r3) goto L6 (error at __str__:233) else goto L1
L1:
    r4 = ''
    r5 = 'format'
    r6 = [r2, r3, r4]
    r7 = load_address r6
    r8 = PyObject_VectorcallMethod(r5, r7, 9223372036854775811, 0)
    if is_error(r8) goto L7 (error at __str__:233) else goto L2
L2:
    dec_ref r3
    r9 = cast(str, r8)
    if is_error(r9) goto L6 (error at __str__:233) else goto L3
L3:
    r10 = ')'
    r11 = PyList_New(3)
    if is_error(r11) goto L8 (error at __str__:233) else goto L4
L4:
    r12 = get_element_ptr r11 ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    inc_ref r1
    set_mem r13, r1 :: builtins.object*
    r14 = r13 + 8
    set_mem r14, r9 :: builtins.object*
    inc_ref r10
    r15 = r13 + 16
    set_mem r15, r10 :: builtins.object*
    r16 = PyUnicode_Join(r0, r11)
    dec_ref r11
    if is_error(r16) goto L6 (error at __str__:233) else goto L5
L5:
    return r16
L6:
    r17 = <error> :: str
    return r17
L7:
    dec_ref r3
    goto L6
L8:
    dec_ref r9
    goto L6

def BaseEquals.__init__(self, base, with_sub):
    self :: faster_eth_abi._registry.BaseEquals
    base :: str
    with_sub :: union[bool, None]
    r0 :: object
    r1, r2 :: bool
    r3 :: None
L0:
    if is_error(with_sub) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    with_sub = r0
L2:
    inc_ref base
    self.base = base; r1 = is_error
    if not r1 goto L7 (error at __init__:251) else goto L3 :: bool
L3:
    self.with_sub = with_sub; r2 = is_error
    if not r2 goto L5 (error at __init__:252) else goto L4 :: bool
L4:
    return 1
L5:
    r3 = <error> :: None
    return r3
L6:
    inc_ref with_sub
    goto L2
L7:
    dec_ref with_sub
    goto L5

def BaseEquals.__call__(self, type_str):
    self :: faster_eth_abi._registry.BaseEquals
    type_str :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: dict
    r8 :: str
    r9, r10 :: object
    r11 :: str
    r12 :: object
    r13 :: tuple[object, object]
    r14 :: object
    r15, r16 :: bit
    r17 :: object
    r18 :: bool
    r19 :: faster_eth_abi._grammar.BasicType
    r20 :: union[object, None]
    r21 :: object
    r22 :: bit
    r23 :: union[bool, None]
    r24 :: object
    r25 :: bit
    r26 :: bool
    r27 :: faster_eth_abi._grammar.BasicType
    r28 :: union[int, tuple, None]
    r29 :: object
    r30 :: bit
    r31 :: bool
    r32 :: faster_eth_abi._grammar.BasicType
    r33 :: union[int, tuple, None]
    r34 :: object
    r35 :: bit
    r36 :: faster_eth_abi._grammar.BasicType
    r37, r38 :: str
    r39, r40 :: bool
L0:
L1:
    r0 = faster_eth_abi._registry.globals :: static
    r1 = 'parse'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L4 (error at __call__:261) else goto L2
L2:
    r3 = [type_str]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at __call__:261) else goto L3
L3:
    goto L12
L4:
    r6 = CPy_CatchError()
    r7 = faster_eth_abi._registry.globals :: static
    r8 = 'ParseError'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L10 (error at __call__:262) else goto L5
L5:
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L37 (error at __call__:262) else goto L6
L6:
    r13 = (r9, r12)
    r14 = box(tuple[object, object], r13)
    r15 = CPy_ExceptionMatches(r14)
    dec_ref r14
    if r15 goto L7 else goto L8 :: bool
L7:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    return 0
L8:
    CPy_Reraise()
    if not 0 goto L10 else goto L38 :: bool
L9:
    unreachable
L10:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r16 = CPy_KeepPropagating()
    if not r16 goto L36 else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = faster_eth_abi._grammar.BasicType :: type
    r18 = CPy_TypeCheck(r5, r17)
    if r18 goto L13 else goto L39 :: bool
L13:
    r19 = borrow cast(faster_eth_abi._grammar.BasicType, r5)
    if is_error(r19) goto L40 (error at __call__:266) else goto L14
L14:
    r20 = borrow r19.arrlist
    if is_error(r20) goto L40 (error at __call__:266) else goto L15
L15:
    r21 = load_address _Py_NoneStruct
    r22 = r20 != r21
    if r22 goto L41 else goto L17 :: bool
L16:
    return 0
L17:
    r23 = self.with_sub
    if is_error(r23) goto L40 (error at __call__:269) else goto L18
L18:
    r24 = load_address _Py_NoneStruct
    r25 = r23 != r24
    if r25 goto L19 else goto L42 :: bool
L19:
    r26 = unbox(bool, r23)
    if is_error(r26) goto L43 (error at __call__:271) else goto L20
L20:
    if r26 goto L21 else goto L25 :: bool
L21:
    r27 = borrow cast(faster_eth_abi._grammar.BasicType, r5)
    if is_error(r27) goto L43 (error at __call__:271) else goto L22
L22:
    r28 = borrow r27.sub
    if is_error(r28) goto L43 (error at __call__:271) else goto L23
L23:
    r29 = load_address _Py_NoneStruct
    r30 = r28 == r29
    if r30 goto L44 else goto L25 :: bool
L24:
    return 0
L25:
    r31 = unbox(bool, r23)
    dec_ref r23
    if is_error(r31) goto L40 (error at __call__:273) else goto L26
L26:
    if r31 goto L31 else goto L27 :: bool
L27:
    r32 = borrow cast(faster_eth_abi._grammar.BasicType, r5)
    if is_error(r32) goto L40 (error at __call__:273) else goto L28
L28:
    r33 = borrow r32.sub
    if is_error(r33) goto L40 (error at __call__:273) else goto L29
L29:
    r34 = load_address _Py_NoneStruct
    r35 = r33 != r34
    if r35 goto L45 else goto L31 :: bool
L30:
    return 0
L31:
    r36 = borrow cast(faster_eth_abi._grammar.BasicType, r5)
    if is_error(r36) goto L40 (error at __call__:276) else goto L32
L32:
    r37 = r36.base
    if is_error(r37) goto L40 (error at __call__:276) else goto L33
L33:
    dec_ref r5
    r38 = self.base
    if is_error(r38) goto L46 (error at __call__:276) else goto L34
L34:
    r39 = CPyStr_Equal(r37, r38)
    dec_ref r37
    dec_ref r38
    return r39
L35:
    return 0
L36:
    r40 = <error> :: bool
    return r40
L37:
    dec_ref r9
    goto L10
L38:
    dec_ref r6
    goto L9
L39:
    dec_ref r5
    goto L35
L40:
    dec_ref r5
    goto L36
L41:
    dec_ref r5
    goto L16
L42:
    dec_ref r23
    goto L31
L43:
    dec_ref r5
    dec_ref r23
    goto L36
L44:
    dec_ref r5
    dec_ref r23
    goto L24
L45:
    dec_ref r5
    goto L30
L46:
    dec_ref r37
    goto L36

def BaseEquals.__call____Predicate_glue(self, arg):
    self :: faster_eth_abi._registry.BaseEquals
    arg :: str
    r0, r1 :: bool
L0:
    r0 = BaseEquals.__call__(self, arg)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bool
    return r1

def BaseEquals.__str__(self):
    self :: faster_eth_abi._registry.BaseEquals
    r0 :: union[bool, None]
    r1, r2, r3, r4, r5, r6 :: str
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10 :: str
    r11 :: list
    r12, r13, r14 :: ptr
    r15 :: str
    r16 :: object
    r17 :: bit
    r18, r19 :: str
    r20 :: bool
    r21, r22, r23, r24, r25, r26, r27 :: str
L0:
    r0 = self.with_sub
    if is_error(r0) goto L16 (error at __str__:283) else goto L1
L1:
    r1 = ''
    r2 = '(base == '
    r3 = '{!r:{}}'
    r4 = self.base
    if is_error(r4) goto L17 (error at __str__:285) else goto L2
L2:
    r5 = ''
    r6 = 'format'
    r7 = [r3, r4, r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775811, 0)
    if is_error(r9) goto L18 (error at __str__:285) else goto L3
L3:
    dec_ref r4
    r10 = cast(str, r9)
    if is_error(r10) goto L17 (error at __str__:285) else goto L4
L4:
    r11 = PyList_New(2)
    if is_error(r11) goto L19 (error at __str__:285) else goto L5
L5:
    r12 = get_element_ptr r11 ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    inc_ref r2
    set_mem r13, r2 :: builtins.object*
    r14 = r13 + 8
    set_mem r14, r10 :: builtins.object*
    r15 = PyUnicode_Join(r1, r11)
    dec_ref r11
    if is_error(r15) goto L17 (error at __str__:285) else goto L6
L6:
    r16 = load_address _Py_NoneStruct
    r17 = r0 == r16
    if r17 goto L20 else goto L8 :: bool
L7:
    r18 = ''
    inc_ref r18
    r19 = r18
    goto L13
L8:
    r20 = unbox(bool, r0)
    dec_ref r0
    if is_error(r20) goto L21 (error at __str__:289) else goto L9
L9:
    if r20 goto L10 else goto L11 :: bool
L10:
    r21 = ' and sub is not None'
    inc_ref r21
    r22 = r21
    goto L12
L11:
    r23 = ' and sub is None'
    inc_ref r23
    r22 = r23
L12:
    r19 = r22
L13:
    r24 = PyUnicode_Concat(r15, r19)
    dec_ref r15
    dec_ref r19
    if is_error(r24) goto L16 (error at __str__:285) else goto L14
L14:
    r25 = ')'
    r26 = PyUnicode_Concat(r24, r25)
    dec_ref r24
    if is_error(r26) goto L16 (error at __str__:285) else goto L15
L15:
    return r26
L16:
    r27 = <error> :: str
    return r27
L17:
    dec_ref r0
    goto L16
L18:
    dec_ref r0
    dec_ref r4
    goto L16
L19:
    dec_ref r0
    dec_ref r10
    goto L16
L20:
    dec_ref r0
    goto L7
L21:
    dec_ref r15
    goto L16

def has_arrlist(type_str):
    type_str :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: dict
    r8 :: str
    r9, r10 :: object
    r11 :: str
    r12 :: object
    r13 :: tuple[object, object]
    r14 :: object
    r15, r16 :: bit
    r17 :: str
    r18, r19 :: object
    r20 :: bit
    r21 :: bool
L0:
L1:
    r0 = faster_eth_abi._registry.globals :: static
    r1 = 'parse'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L4 (error at has_arrlist:300) else goto L2
L2:
    r3 = [type_str]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at has_arrlist:300) else goto L3
L3:
    goto L12
L4:
    r6 = CPy_CatchError()
    r7 = faster_eth_abi._registry.globals :: static
    r8 = 'ParseError'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L10 (error at has_arrlist:301) else goto L5
L5:
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L15 (error at has_arrlist:301) else goto L6
L6:
    r13 = (r9, r12)
    r14 = box(tuple[object, object], r13)
    r15 = CPy_ExceptionMatches(r14)
    dec_ref r14
    if r15 goto L7 else goto L8 :: bool
L7:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    return 0
L8:
    CPy_Reraise()
    if not 0 goto L10 else goto L16 :: bool
L9:
    unreachable
L10:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r16 = CPy_KeepPropagating()
    if not r16 goto L14 else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = 'arrlist'
    r18 = CPyObject_GetAttr(r5, r17)
    dec_ref r5
    if is_error(r18) goto L14 (error at has_arrlist:304) else goto L13
L13:
    r19 = load_address _Py_NoneStruct
    r20 = r18 != r19
    dec_ref r18
    return r20
L14:
    r21 = <error> :: bool
    return r21
L15:
    dec_ref r9
    goto L10
L16:
    dec_ref r6
    goto L9

def is_base_tuple(type_str):
    type_str :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: dict
    r8 :: str
    r9, r10 :: object
    r11 :: str
    r12 :: object
    r13 :: tuple[object, object]
    r14 :: object
    r15, r16 :: bit
    r17 :: object
    r18, r19 :: bool
    r20 :: faster_eth_abi._grammar.TupleType
    r21 :: union[object, None]
    r22 :: object
    r23 :: bit
    r24 :: bool
L0:
L1:
    r0 = faster_eth_abi._registry.globals :: static
    r1 = 'parse'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L4 (error at is_base_tuple:312) else goto L2
L2:
    r3 = [type_str]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at is_base_tuple:312) else goto L3
L3:
    goto L12
L4:
    r6 = CPy_CatchError()
    r7 = faster_eth_abi._registry.globals :: static
    r8 = 'ParseError'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L10 (error at is_base_tuple:313) else goto L5
L5:
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L19 (error at is_base_tuple:313) else goto L6
L6:
    r13 = (r9, r12)
    r14 = box(tuple[object, object], r13)
    r15 = CPy_ExceptionMatches(r14)
    dec_ref r14
    if r15 goto L7 else goto L8 :: bool
L7:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    return 0
L8:
    CPy_Reraise()
    if not 0 goto L10 else goto L20 :: bool
L9:
    unreachable
L10:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r16 = CPy_KeepPropagating()
    if not r16 goto L18 else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = faster_eth_abi._grammar.TupleType :: type
    r18 = CPy_TypeCheck(r5, r17)
    if r18 goto L14 else goto L21 :: bool
L13:
    r19 = r18
    goto L17
L14:
    r20 = borrow cast(faster_eth_abi._grammar.TupleType, r5)
    if is_error(r20) goto L22 (error at is_base_tuple:316) else goto L15
L15:
    r21 = borrow r20.arrlist
    if is_error(r21) goto L22 (error at is_base_tuple:316) else goto L16
L16:
    r22 = load_address _Py_NoneStruct
    r23 = r21 == r22
    dec_ref r5
    r19 = r23
L17:
    return r19
L18:
    r24 = <error> :: bool
    return r24
L19:
    dec_ref r9
    goto L10
L20:
    dec_ref r6
    goto L9
L21:
    dec_ref r5
    goto L13
L22:
    dec_ref r5
    goto L18

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15, r16 :: object
    r17 :: str
    r18 :: dict
    r19, r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43, r44 :: object
    r45 :: str
    r46 :: dict
    r47, r48 :: object
    r49 :: str
    r50 :: dict
    r51 :: object
    r52 :: str
    r53 :: dict
    r54 :: str
    r55 :: object
    r56 :: object[1]
    r57 :: object_ptr
    r58 :: object
    r59 :: dict
    r60 :: str
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: object
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: list
    r76, r77 :: ptr
    r78 :: object
    r79 :: tuple[list, object]
    r80, r81 :: object
    r82 :: tuple[object, object]
    r83, r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: dict
    r93 :: str
    r94 :: i32
    r95 :: bit
    r96 :: object
    r97 :: str
    r98 :: object
    r99 :: tuple
    r100 :: str
    r101, r102 :: object
    r103 :: bool
    r104, r105 :: str
    r106 :: tuple
    r107 :: i32
    r108 :: bit
    r109 :: dict
    r110 :: str
    r111 :: i32
    r112 :: bit
    r113 :: object
    r114 :: tuple
    r115 :: str
    r116, r117 :: object
    r118 :: bool
    r119, r120, r121, r122, r123 :: str
    r124 :: tuple
    r125 :: i32
    r126 :: bit
    r127 :: dict
    r128 :: str
    r129 :: i32
    r130 :: bit
    r131 :: dict
    r132 :: str
    r133 :: object
    r134 :: dict
    r135 :: str
    r136, r137 :: object
    r138 :: tuple
    r139 :: str
    r140, r141 :: object
    r142 :: bool
    r143, r144 :: str
    r145 :: tuple
    r146 :: i32
    r147 :: bit
    r148 :: dict
    r149 :: str
    r150 :: i32
    r151 :: bit
    r152, r153, r154 :: object
    r155 :: tuple
    r156 :: str
    r157 :: i32
    r158 :: bit
    r159, r160, r161 :: object
    r162 :: tuple
    r163 :: str
    r164, r165 :: object
    r166 :: bool
    r167, r168, r169 :: str
    r170 :: tuple
    r171 :: i32
    r172 :: bit
    r173 :: dict
    r174 :: str
    r175 :: i32
    r176 :: bit
    r177 :: object
    r178 :: str
    r179 :: tuple[str]
    r180 :: str
    r181 :: object
    r182 :: i32
    r183 :: bit
    r184 :: object
    r185 :: dict
    r186 :: str
    r187, r188 :: object
    r189 :: dict
    r190 :: str
    r191, r192, r193 :: object
    r194 :: tuple[object, object]
    r195, r196, r197 :: object
    r198 :: tuple
    r199 :: str
    r200, r201 :: object
    r202 :: bool
    r203, r204, r205, r206 :: str
    r207 :: tuple
    r208 :: i32
    r209 :: bit
    r210 :: dict
    r211 :: str
    r212 :: i32
    r213 :: bit
    r214 :: object
    r215, r216 :: str
    r217 :: tuple[str, str]
    r218 :: str
    r219 :: object
    r220 :: i32
    r221 :: bit
    r222 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L72 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address abc :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('abc', 'abc', 'abc'),)
    r11 = faster_eth_abi._registry.globals :: static
    r12 = 'faster_eth_abi/_registry.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L72 else goto L4 :: bool
L4:
    r15 = ('copy',)
    r16 = ('stdlib_copy',)
    r17 = 'copy'
    r18 = faster_eth_abi._registry.globals :: static
    r19 = CPyImport_ImportFromMany(r17, r15, r16, r18)
    if is_error(r19) goto L72 (error at <module>:2) else goto L5
L5:
    copy = r19 :: module
    dec_ref r19
    r20 = ('Any', 'Callable', 'ClassVar', 'Dict', 'Final', 'Generic', 'Iterator', 'Optional', 'TypeVar', 'Union', 'final')
    r21 = 'typing'
    r22 = faster_eth_abi._registry.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L72 (error at <module>:5) else goto L6
L6:
    typing = r23 :: module
    dec_ref r23
    r24 = ('TypeStr',)
    r25 = 'eth_typing'
    r26 = faster_eth_abi._registry.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L72 (error at <module>:19) else goto L7
L7:
    eth_typing = r27 :: module
    dec_ref r27
    r28 = ('mypyc_attr',)
    r29 = 'mypy_extensions'
    r30 = faster_eth_abi._registry.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L72 (error at <module>:22) else goto L8
L8:
    mypy_extensions = r31 :: module
    dec_ref r31
    r32 = ('Self',)
    r33 = 'typing_extensions'
    r34 = faster_eth_abi._registry.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L72 (error at <module>:25) else goto L9
L9:
    typing_extensions = r35 :: module
    dec_ref r35
    r36 = ('BasicType', 'TupleType')
    r37 = 'faster_eth_abi._grammar'
    r38 = faster_eth_abi._registry.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L72 (error at <module>:29) else goto L10
L10:
    faster_eth_abi._grammar = r39 :: module
    dec_ref r39
    r40 = ('BaseCoder',)
    r41 = 'faster_eth_abi.base'
    r42 = faster_eth_abi._registry.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L72 (error at <module>:33) else goto L11
L11:
    faster_eth_abi.base = r43 :: module
    dec_ref r43
    r44 = ('MultipleEntriesFound', 'NoEntriesFound', 'ParseError')
    r45 = 'faster_eth_abi.exceptions'
    r46 = faster_eth_abi._registry.globals :: static
    r47 = CPyImport_ImportFromMany(r45, r44, r44, r46)
    if is_error(r47) goto L72 (error at <module>:36) else goto L12
L12:
    faster_eth_abi.exceptions = r47 :: module
    dec_ref r47
    r48 = ('parse',)
    r49 = 'faster_eth_abi.grammar'
    r50 = faster_eth_abi._registry.globals :: static
    r51 = CPyImport_ImportFromMany(r49, r48, r48, r50)
    if is_error(r51) goto L72 (error at <module>:41) else goto L13
L13:
    faster_eth_abi.grammar = r51 :: module
    dec_ref r51
    r52 = '_T'
    r53 = faster_eth_abi._registry.globals :: static
    r54 = 'TypeVar'
    r55 = CPyDict_GetItem(r53, r54)
    if is_error(r55) goto L72 (error at <module>:46) else goto L14
L14:
    r56 = [r52]
    r57 = load_address r56
    r58 = PyObject_Vectorcall(r55, r57, 1, 0)
    dec_ref r55
    if is_error(r58) goto L72 (error at <module>:46) else goto L15
L15:
    r59 = faster_eth_abi._registry.globals :: static
    r60 = '_T'
    r61 = CPyDict_SetItem(r59, r60, r58)
    dec_ref r58
    r62 = r61 >= 0 :: signed
    if not r62 goto L72 (error at <module>:46) else goto L16 :: bool
L16:
    r63 = faster_eth_abi._registry.globals :: static
    r64 = 'Union'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L72 (error at <module>:48) else goto L17
L17:
    r66 = faster_eth_abi._registry.globals :: static
    r67 = 'TypeStr'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L73 (error at <module>:48) else goto L18
L18:
    r69 = faster_eth_abi._registry.globals :: static
    r70 = 'Callable'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L74 (error at <module>:48) else goto L19
L19:
    r72 = faster_eth_abi._registry.globals :: static
    r73 = 'TypeStr'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L75 (error at <module>:48) else goto L20
L20:
    r75 = PyList_New(1)
    if is_error(r75) goto L76 (error at <module>:48) else goto L21
L21:
    r76 = get_element_ptr r75 ob_item :: PyListObject
    r77 = load_mem r76 :: ptr*
    set_mem r77, r74 :: builtins.object*
    r78 = load_address PyBool_Type
    inc_ref r78
    r79 = (r75, r78)
    r80 = box(tuple[list, object], r79)
    r81 = PyObject_GetItem(r71, r80)
    dec_ref r71
    dec_ref r80
    if is_error(r81) goto L74 (error at <module>:48) else goto L22
L22:
    r82 = (r68, r81)
    r83 = box(tuple[object, object], r82)
    r84 = PyObject_GetItem(r65, r83)
    dec_ref r65
    dec_ref r83
    if is_error(r84) goto L72 (error at <module>:48) else goto L23
L23:
    r85 = faster_eth_abi._registry.globals :: static
    r86 = 'Lookup'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L72 (error at <module>:48) else goto L24 :: bool
L24:
    r89 = faster_eth_abi._registry.globals :: static
    r90 = 'stdlib_copy'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L72 (error at <module>:51) else goto L25
L25:
    faster_eth_abi._registry.copy = r91 :: static
    r92 = faster_eth_abi._registry.globals :: static
    r93 = 'copy'
    r94 = CPyDict_SetItem(r92, r93, r91)
    dec_ref r91
    r95 = r94 >= 0 :: signed
    if not r95 goto L72 (error at <module>:51) else goto L26 :: bool
L26:
    r96 = abc :: module
    r97 = 'ABC'
    r98 = CPyObject_GetAttr(r96, r97)
    if is_error(r98) goto L72 (error at <module>:55) else goto L27
L27:
    r99 = PyTuple_Pack(1, r98)
    dec_ref r98
    if is_error(r99) goto L72 (error at <module>:55) else goto L28
L28:
    r100 = 'faster_eth_abi._registry'
    r101 = faster_eth_abi._registry.Copyable_template :: type
    r102 = CPyType_FromTemplate(r101, r99, r100)
    dec_ref r99
    if is_error(r102) goto L72 (error at <module>:55) else goto L29
L29:
    r103 = Copyable_trait_vtable_setup()
    if is_error(r103) goto L77 (error at <module>:-1) else goto L30
L30:
    r104 = '__mypyc_attrs__'
    r105 = '__dict__'
    r106 = PyTuple_Pack(1, r105)
    if is_error(r106) goto L77 (error at <module>:55) else goto L31
L31:
    r107 = PyObject_SetAttr(r102, r104, r106)
    dec_ref r106
    r108 = r107 >= 0 :: signed
    if not r108 goto L77 (error at <module>:55) else goto L32 :: bool
L32:
    faster_eth_abi._registry.Copyable = r102 :: type
    r109 = faster_eth_abi._registry.globals :: static
    r110 = 'Copyable'
    r111 = PyDict_SetItem(r109, r110, r102)
    dec_ref r102
    r112 = r111 >= 0 :: signed
    if not r112 goto L72 (error at <module>:55) else goto L33 :: bool
L33:
    r113 = faster_eth_abi._registry.Copyable :: type
    r114 = PyTuple_Pack(1, r113)
    if is_error(r114) goto L72 (error at <module>:68) else goto L34
L34:
    r115 = 'faster_eth_abi._registry'
    r116 = faster_eth_abi._registry.PredicateMapping_template :: type
    r117 = CPyType_FromTemplate(r116, r114, r115)
    dec_ref r114
    if is_error(r117) goto L72 (error at <module>:68) else goto L35
L35:
    r118 = PredicateMapping_trait_vtable_setup()
    if is_error(r118) goto L78 (error at <module>:-1) else goto L36
L36:
    r119 = '__mypyc_attrs__'
    r120 = '_name'
    r121 = '_values'
    r122 = '_labeled_predicates'
    r123 = '__dict__'
    r124 = PyTuple_Pack(4, r120, r121, r122, r123)
    if is_error(r124) goto L78 (error at <module>:68) else goto L37
L37:
    r125 = PyObject_SetAttr(r117, r119, r124)
    dec_ref r124
    r126 = r125 >= 0 :: signed
    if not r126 goto L78 (error at <module>:68) else goto L38 :: bool
L38:
    faster_eth_abi._registry.PredicateMapping = r117 :: type
    r127 = faster_eth_abi._registry.globals :: static
    r128 = 'PredicateMapping'
    r129 = PyDict_SetItem(r127, r128, r117)
    dec_ref r117
    r130 = r129 >= 0 :: signed
    if not r130 goto L72 (error at <module>:68) else goto L39 :: bool
L39:
    r131 = faster_eth_abi._registry.globals :: static
    r132 = 'Generic'
    r133 = CPyDict_GetItem(r131, r132)
    if is_error(r133) goto L72 (error at <module>:181) else goto L40
L40:
    r134 = faster_eth_abi._registry.globals :: static
    r135 = '_T'
    r136 = CPyDict_GetItem(r134, r135)
    if is_error(r136) goto L79 (error at <module>:181) else goto L41
L41:
    r137 = PyObject_GetItem(r133, r136)
    dec_ref r133
    dec_ref r136
    if is_error(r137) goto L72 (error at <module>:181) else goto L42
L42:
    r138 = PyTuple_Pack(1, r137)
    dec_ref r137
    if is_error(r138) goto L72 (error at <module>:181) else goto L43
L43:
    r139 = 'faster_eth_abi._registry'
    r140 = faster_eth_abi._registry.Predicate_template :: type
    r141 = CPyType_FromTemplate(r140, r138, r139)
    dec_ref r138
    if is_error(r141) goto L72 (error at <module>:181) else goto L44
L44:
    r142 = Predicate_trait_vtable_setup()
    if is_error(r142) goto L80 (error at <module>:-1) else goto L45
L45:
    r143 = '__mypyc_attrs__'
    r144 = '__dict__'
    r145 = PyTuple_Pack(1, r144)
    if is_error(r145) goto L80 (error at <module>:181) else goto L46
L46:
    r146 = PyObject_SetAttr(r141, r143, r145)
    dec_ref r145
    r147 = r146 >= 0 :: signed
    if not r147 goto L80 (error at <module>:181) else goto L47 :: bool
L47:
    faster_eth_abi._registry.Predicate = r141 :: type
    r148 = faster_eth_abi._registry.globals :: static
    r149 = 'Predicate'
    r150 = PyDict_SetItem(r148, r149, r141)
    dec_ref r141
    r151 = r150 >= 0 :: signed
    if not r151 goto L72 (error at <module>:181) else goto L48 :: bool
L48:
    r152 = faster_eth_abi._registry.Predicate :: type
    r153 = load_address PyTuple_Type
    r154 = PyObject_Vectorcall(r153, 0, 0, 0)
    if is_error(r154) goto L72 (error at <module>:189) else goto L49
L49:
    r155 = cast(tuple, r154)
    if is_error(r155) goto L72 (error at <module>:189) else goto L50
L50:
    r156 = '__attrs__'
    r157 = PyObject_SetAttr(r152, r156, r155)
    dec_ref r155
    r158 = r157 >= 0 :: signed
    if not r158 goto L72 (error at <module>:189) else goto L51 :: bool
L51:
    r159 = faster_eth_abi._registry.Predicate :: type
    r160 = load_address PyUnicode_Type
    r161 = PyObject_GetItem(r159, r160)
    if is_error(r161) goto L72 (error at <module>:212) else goto L52
L52:
    r162 = PyTuple_Pack(1, r161)
    dec_ref r161
    if is_error(r162) goto L72 (error at <module>:212) else goto L53
L53:
    r163 = 'faster_eth_abi._registry'
    r164 = faster_eth_abi._registry.Equals_template :: type
    r165 = CPyType_FromTemplate(r164, r162, r163)
    dec_ref r162
    if is_error(r165) goto L72 (error at <module>:212) else goto L54
L54:
    r166 = Equals_trait_vtable_setup()
    if is_error(r166) goto L81 (error at <module>:-1) else goto L55
L55:
    r167 = '__mypyc_attrs__'
    r168 = 'value'
    r169 = '__dict__'
    r170 = PyTuple_Pack(2, r168, r169)
    if is_error(r170) goto L81 (error at <module>:212) else goto L56
L56:
    r171 = PyObject_SetAttr(r165, r167, r170)
    dec_ref r170
    r172 = r171 >= 0 :: signed
    if not r172 goto L81 (error at <module>:212) else goto L57 :: bool
L57:
    faster_eth_abi._registry.Equals = r165 :: type
    r173 = faster_eth_abi._registry.globals :: static
    r174 = 'Equals'
    r175 = PyDict_SetItem(r173, r174, r165)
    dec_ref r165
    r176 = r175 >= 0 :: signed
    if not r176 goto L72 (error at <module>:212) else goto L58 :: bool
L58:
    r177 = faster_eth_abi._registry.Equals :: type
    r178 = 'value'
    inc_ref r178
    r179 = (r178)
    r180 = '__attrs__'
    r181 = box(tuple[str], r179)
    r182 = PyObject_SetAttr(r177, r180, r181)
    dec_ref r181
    r183 = r182 >= 0 :: signed
    if not r183 goto L72 (error at <module>:219) else goto L59 :: bool
L59:
    r184 = faster_eth_abi._registry.Predicate :: type
    r185 = faster_eth_abi._registry.globals :: static
    r186 = 'Union'
    r187 = CPyDict_GetItem(r185, r186)
    if is_error(r187) goto L72 (error at <module>:237) else goto L60
L60:
    r188 = load_address PyUnicode_Type
    r189 = faster_eth_abi._registry.globals :: static
    r190 = 'Optional'
    r191 = CPyDict_GetItem(r189, r190)
    if is_error(r191) goto L82 (error at <module>:237) else goto L61
L61:
    r192 = load_address PyBool_Type
    r193 = PyObject_GetItem(r191, r192)
    dec_ref r191
    if is_error(r193) goto L82 (error at <module>:237) else goto L62
L62:
    inc_ref r188
    r194 = (r188, r193)
    r195 = box(tuple[object, object], r194)
    r196 = PyObject_GetItem(r187, r195)
    dec_ref r187
    dec_ref r195
    if is_error(r196) goto L72 (error at <module>:237) else goto L63
L63:
    r197 = PyObject_GetItem(r184, r196)
    dec_ref r196
    if is_error(r197) goto L72 (error at <module>:237) else goto L64
L64:
    r198 = PyTuple_Pack(1, r197)
    dec_ref r197
    if is_error(r198) goto L72 (error at <module>:237) else goto L65
L65:
    r199 = 'faster_eth_abi._registry'
    r200 = faster_eth_abi._registry.BaseEquals_template :: type
    r201 = CPyType_FromTemplate(r200, r198, r199)
    dec_ref r198
    if is_error(r201) goto L72 (error at <module>:237) else goto L66
L66:
    r202 = BaseEquals_trait_vtable_setup()
    if is_error(r202) goto L83 (error at <module>:-1) else goto L67
L67:
    r203 = '__mypyc_attrs__'
    r204 = 'base'
    r205 = 'with_sub'
    r206 = '__dict__'
    r207 = PyTuple_Pack(3, r204, r205, r206)
    if is_error(r207) goto L83 (error at <module>:237) else goto L68
L68:
    r208 = PyObject_SetAttr(r201, r203, r207)
    dec_ref r207
    r209 = r208 >= 0 :: signed
    if not r209 goto L83 (error at <module>:237) else goto L69 :: bool
L69:
    faster_eth_abi._registry.BaseEquals = r201 :: type
    r210 = faster_eth_abi._registry.globals :: static
    r211 = 'BaseEquals'
    r212 = PyDict_SetItem(r210, r211, r201)
    dec_ref r201
    r213 = r212 >= 0 :: signed
    if not r213 goto L72 (error at <module>:237) else goto L70 :: bool
L70:
    r214 = faster_eth_abi._registry.BaseEquals :: type
    r215 = 'base'
    r216 = 'with_sub'
    inc_ref r215
    inc_ref r216
    r217 = (r215, r216)
    r218 = '__attrs__'
    r219 = box(tuple[str, str], r217)
    r220 = PyObject_SetAttr(r214, r218, r219)
    dec_ref r219
    r221 = r220 >= 0 :: signed
    if not r221 goto L72 (error at <module>:248) else goto L71 :: bool
L71:
    return 1
L72:
    r222 = <error> :: None
    return r222
L73:
    dec_ref r65
    goto L72
L74:
    dec_ref r65
    dec_ref r68
    goto L72
L75:
    dec_ref r65
    dec_ref r68
    dec_ref r71
    goto L72
L76:
    dec_ref r65
    dec_ref r68
    dec_ref r71
    dec_ref r74
    goto L72
L77:
    dec_ref r102
    goto L72
L78:
    dec_ref r117
    goto L72
L79:
    dec_ref r133
    goto L72
L80:
    dec_ref r141
    goto L72
L81:
    dec_ref r165
    goto L72
L82:
    dec_ref r187
    goto L72
L83:
    dec_ref r201
    goto L72

def validate_bytes_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: str
    r11 :: object
    r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: None
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L10 (error at validate_bytes_param:7) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(param, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L10 (error at validate_bytes_param:7) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L9 else goto L3 :: bool
L3:
    r9 = 'The `'
    r10 = '` value must be of bytes type. Got '
    r11 = CPy_TYPE(param)
    r12 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r12) goto L10 (error at validate_bytes_param:9) else goto L4
L4:
    r13 = CPyStr_Build(4, r9, param_name, r10, r12)
    dec_ref r12
    if is_error(r13) goto L10 (error at validate_bytes_param:9) else goto L5
L5:
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L11 (error at validate_bytes_param:8) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L11 (error at validate_bytes_param:8) else goto L7
L7:
    dec_ref r13
    CPy_Raise(r19)
    dec_ref r19
    if not 0 goto L10 (error at validate_bytes_param:8) else goto L8 :: bool
L8:
    unreachable
L9:
    return 1
L10:
    r20 = <error> :: None
    return r20
L11:
    dec_ref r13
    goto L10

def validate_list_like_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: tuple[object, object]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7, r8 :: str
    r9 :: object
    r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: None
L0:
    r0 = load_address PyList_Type
    r1 = load_address PyTuple_Type
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[object, object], r2)
    r4 = PyObject_IsInstance(param, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L9 (error at validate_list_like_param:14) else goto L1 :: bool
L1:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L8 else goto L2 :: bool
L2:
    r7 = 'The `'
    r8 = '` value type must be one of list or tuple. Got '
    r9 = CPy_TYPE(param)
    r10 = PyObject_Str(r9)
    dec_ref r9
    if is_error(r10) goto L9 (error at validate_list_like_param:16) else goto L3
L3:
    r11 = CPyStr_Build(4, r7, param_name, r8, r10)
    dec_ref r10
    if is_error(r11) goto L9 (error at validate_list_like_param:16) else goto L4
L4:
    r12 = builtins :: module
    r13 = 'TypeError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L10 (error at validate_list_like_param:15) else goto L5
L5:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L10 (error at validate_list_like_param:15) else goto L6
L6:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L9 (error at validate_list_like_param:15) else goto L7 :: bool
L7:
    unreachable
L8:
    return 1
L9:
    r18 = <error> :: None
    return r18
L10:
    dec_ref r11
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.validation.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9
