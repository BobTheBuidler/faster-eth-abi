def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('get_abi_strategy',)
    r6 = 'faster_eth_abi.tools._strategies'
    r7 = faster_eth_abi.tools.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    faster_eth_abi.tools._strategies = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L21 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.packed.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L21 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABIEncoder',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.packed.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L21 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry_packed',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.packed.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L21 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.packed.globals :: static
    r18 = 'registry_packed'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L21 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.packed.globals :: static
    r21 = 'ABIEncoder'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L22 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L22 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.packed.default_encoder_packed = r25 :: static
    r26 = faster_eth_abi.packed.globals :: static
    r27 = 'default_encoder_packed'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r31 goto L21 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L21 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.packed.encode_packed = r33 :: static
    r34 = faster_eth_abi.packed.globals :: static
    r35 = 'encode_packed'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L21 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r39 goto L21 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'is_encodable'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L21 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.packed.is_encodable_packed = r41 :: static
    r42 = faster_eth_abi.packed.globals :: static
    r43 = 'is_encodable_packed'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L21 (error at <module>:15) else goto L20 :: bool
L20:
    return 1
L21:
    r46 = <error> :: None
    return r46
L22:
    dec_ref r19
    goto L21

def encode_tuple(values, encoders):
    values, encoders :: object
    r0, r1 :: list
    r2, r3, r4, r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bytes
    r19 :: i32
    r20 :: bit
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: bytes
    r25 :: i32
    r26 :: bit
    r27 :: bytes
    r28 :: i32
    r29, r30, r31 :: bit
    r32 :: int
    r33 :: short_int
    r34 :: ptr
    r35 :: native_int
    r36 :: short_int
    r37 :: bit
    r38 :: native_int
    r39, r40 :: ptr
    r41 :: native_int
    r42 :: ptr
    r43 :: object
    r44 :: union[bytes, None]
    r45 :: object
    r46 :: bit
    r47 :: int
    r48 :: bytes
    r49 :: ptr
    r50 :: native_int
    r51 :: short_int
    r52 :: int
    r53 :: short_int
    head_length :: int
    r54 :: object
    r55 :: list
    r56 :: ptr
    r57 :: native_int
    r58 :: list
    r59 :: short_int
    r60 :: ptr
    r61 :: native_int
    r62 :: short_int
    r63 :: bit
    r64 :: native_int
    r65, r66 :: ptr
    r67 :: native_int
    r68 :: ptr
    r69 :: object
    r70 :: bytes
    r71 :: ptr
    r72 :: native_int
    r73 :: short_int
    r74 :: object
    r75 :: bit
    r76 :: short_int
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: object[1]
    r82 :: object_ptr
    r83 :: object
    r84 :: list
    r85 :: object
    r86, r87 :: ptr
    r88 :: object
    r89 :: tuple
    r90 :: list
    r91, r92 :: short_int
    r93 :: ptr
    r94 :: native_int
    r95 :: short_int
    r96 :: bit
    r97 :: ptr
    r98 :: native_int
    r99 :: short_int
    r100 :: bit
    r101 :: native_int
    r102, r103 :: ptr
    r104 :: native_int
    r105 :: ptr
    r106 :: object
    r107 :: union[bytes, None]
    r108 :: object
    r109 :: int
    r110 :: object
    r111 :: bit
    r112 :: int
    r113, r114, r115 :: bytes
    r116 :: i32
    r117 :: bit
    r118, r119 :: short_int
    r120 :: tuple
    r121, r122, r123, r124, r125, r126 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L61 (error at encode_tuple:27) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L62 (error at encode_tuple:28) else goto L2
L2:
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L63 (error at encode_tuple:29) else goto L3
L3:
    r3 = PyObject_GetIter(encoders)
    if is_error(r3) goto L64 (error at encode_tuple:29) else goto L4
L4:
    r4 = PyIter_Next(r2)
    if is_error(r4) goto L65 else goto L5
L5:
    r5 = PyIter_Next(r3)
    if is_error(r5) goto L66 else goto L6
L6:
    r6 = 'is_dynamic'
    r7 = box(bool, 0)
    r8 = CPyObject_GetAttr3(r5, r6, r7)
    if is_error(r8) goto L67 (error at encode_tuple:30) else goto L7
L7:
    r9 = PyObject_IsTrue(r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L67 (error at encode_tuple:30) else goto L8 :: bool
L8:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L9 else goto L13 :: bool
L9:
    r12 = box(None, 1)
    r13 = PyList_Append(r0, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L67 (error at encode_tuple:31) else goto L10 :: bool
L10:
    r15 = [r4]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r5, r16, 1, 0)
    dec_ref r5
    if is_error(r17) goto L68 (error at encode_tuple:32) else goto L11
L11:
    dec_ref r4
    r18 = cast(bytes, r17)
    if is_error(r18) goto L69 (error at encode_tuple:32) else goto L12
L12:
    r19 = PyList_Append(r1, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L69 (error at encode_tuple:32) else goto L4 :: bool
L13:
    r21 = [r4]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r5, r22, 1, 0)
    dec_ref r5
    if is_error(r23) goto L68 (error at encode_tuple:34) else goto L14
L14:
    dec_ref r4
    r24 = cast(bytes, r23)
    if is_error(r24) goto L69 (error at encode_tuple:34) else goto L15
L15:
    r25 = PyList_Append(r0, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L69 (error at encode_tuple:34) else goto L16 :: bool
L16:
    r27 = b''
    r28 = PyList_Append(r1, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L69 (error at encode_tuple:35) else goto L4 :: bool
L17:
    r30 = CPy_NoErrOccurred()
    if not r30 goto L63 (error at encode_tuple:29) else goto L18 :: bool
L18:
    r31 = CPy_NoErrOccurred()
    if not r31 goto L63 (error at encode_tuple:29) else goto L19 :: bool
L19:
    r32 = 0
    r33 = 0
L20:
    r34 = get_element_ptr r0 ob_size :: PyVarObject
    r35 = load_mem r34 :: native_int*
    r36 = r35 << 1
    r37 = r33 < r36 :: signed
    if r37 goto L21 else goto L28 :: bool
L21:
    r38 = r33 >> 1
    r39 = get_element_ptr r0 ob_item :: PyListObject
    r40 = load_mem r39 :: ptr*
    r41 = r38 * 8
    r42 = r40 + r41
    r43 = load_mem r42 :: builtins.object*
    inc_ref r43
    r44 = cast(union[bytes, None], r43)
    if is_error(r44) goto L70 (error at encode_tuple:37) else goto L22
L22:
    r45 = load_address _Py_NoneStruct
    r46 = r44 == r45
    if r46 goto L71 else goto L24 :: bool
L23:
    r47 = 64
    goto L26
L24:
    r48 = cast(bytes, r44)
    if is_error(r48) goto L70 (error at encode_tuple:37) else goto L25
L25:
    r49 = get_element_ptr r48 ob_size :: PyVarObject
    r50 = load_mem r49 :: native_int*
    dec_ref r48
    r51 = r50 << 1
    r47 = r51
L26:
    r52 = CPyTagged_Add(r32, r47)
    dec_ref r32 :: int
    dec_ref r47 :: int
    r32 = r52
L27:
    r53 = r33 + 2
    r33 = r53
    goto L20
L28:
    head_length = r32
    r54 = CPyList_GetSlice(r1, 0, -2)
    if is_error(r54) goto L72 (error at encode_tuple:38) else goto L29
L29:
    r55 = cast(list, r54)
    if is_error(r55) goto L72 (error at encode_tuple:38) else goto L30
L30:
    r56 = get_element_ptr r55 ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = PyList_New(r57)
    if is_error(r58) goto L73 (error at encode_tuple:38) else goto L31
L31:
    r59 = 0
L32:
    r60 = get_element_ptr r55 ob_size :: PyVarObject
    r61 = load_mem r60 :: native_int*
    r62 = r61 << 1
    r63 = r59 < r62 :: signed
    if r63 goto L33 else goto L74 :: bool
L33:
    r64 = r59 >> 1
    r65 = get_element_ptr r55 ob_item :: PyListObject
    r66 = load_mem r65 :: ptr*
    r67 = r64 * 8
    r68 = r66 + r67
    r69 = load_mem r68 :: builtins.object*
    inc_ref r69
    r70 = cast(bytes, r69)
    if is_error(r70) goto L75 (error at encode_tuple:38) else goto L34
L34:
    r71 = get_element_ptr r70 ob_size :: PyVarObject
    r72 = load_mem r71 :: native_int*
    dec_ref r70
    r73 = r72 << 1
    r74 = box(short_int, r73)
    r75 = CPyList_SetItemUnsafe(r58, r59, r74)
    if not r75 goto L75 (error at encode_tuple:38) else goto L35 :: bool
L35:
    r76 = r59 + 2
    r59 = r76
    goto L32
L36:
    r77 = PyObject_GetIter(r58)
    dec_ref r58
    if is_error(r77) goto L72 (error at encode_tuple:38) else goto L37
L37:
    r78 = faster_eth_abi._encoding.globals :: static
    r79 = 'accumulate'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L76 (error at encode_tuple:38) else goto L38
L38:
    r81 = [r77]
    r82 = load_address r81
    r83 = PyObject_Vectorcall(r80, r82, 1, 0)
    dec_ref r80
    if is_error(r83) goto L76 (error at encode_tuple:38) else goto L39
L39:
    dec_ref r77
    r84 = PyList_New(1)
    if is_error(r84) goto L77 (error at encode_tuple:38) else goto L40
L40:
    r85 = object 0
    r86 = get_element_ptr r84 ob_item :: PyListObject
    r87 = load_mem r86 :: ptr*
    inc_ref r85
    set_mem r87, r85 :: builtins.object*
    r88 = CPyList_Extend(r84, r83)
    dec_ref r83
    if is_error(r88) goto L78 (error at encode_tuple:38) else goto L79
L41:
    r89 = PyList_AsTuple(r84)
    dec_ref r84
    if is_error(r89) goto L72 (error at encode_tuple:38) else goto L42
L42:
    r90 = PyList_New(0)
    if is_error(r90) goto L80 (error at encode_tuple:39) else goto L43
L43:
    r91 = 0
    r92 = 0
L44:
    r93 = get_element_ptr r0 ob_size :: PyVarObject
    r94 = load_mem r93 :: native_int*
    r95 = r94 << 1
    r96 = r91 < r95 :: signed
    if r96 goto L45 else goto L81 :: bool
L45:
    r97 = get_element_ptr r89 ob_size :: PyVarObject
    r98 = load_mem r97 :: native_int*
    r99 = r98 << 1
    r100 = r92 < r99 :: signed
    if r100 goto L46 else goto L81 :: bool
L46:
    r101 = r91 >> 1
    r102 = get_element_ptr r0 ob_item :: PyListObject
    r103 = load_mem r102 :: ptr*
    r104 = r101 * 8
    r105 = r103 + r104
    r106 = load_mem r105 :: builtins.object*
    inc_ref r106
    r107 = cast(union[bytes, None], r106)
    if is_error(r107) goto L82 (error at encode_tuple:39) else goto L47
L47:
    r108 = CPySequenceTuple_GetItem(r89, r92)
    if is_error(r108) goto L83 (error at encode_tuple:39) else goto L48
L48:
    r109 = unbox(int, r108)
    dec_ref r108
    if is_error(r109) goto L83 (error at encode_tuple:39) else goto L49
L49:
    r110 = load_address _Py_NoneStruct
    r111 = r107 == r110
    if r111 goto L84 else goto L85 :: bool
L50:
    r112 = CPyTagged_Add(head_length, r109)
    dec_ref r109 :: int
    r113 = encode_uint_256(r112)
    dec_ref r112 :: int
    if is_error(r113) goto L82 (error at encode_tuple:40) else goto L51
L51:
    r114 = r113
    goto L54
L52:
    r115 = cast(bytes, r107)
    if is_error(r115) goto L82 (error at encode_tuple:40) else goto L53
L53:
    r114 = r115
L54:
    r116 = PyList_Append(r90, r114)
    dec_ref r114
    r117 = r116 >= 0 :: signed
    if not r117 goto L82 (error at encode_tuple:39) else goto L55 :: bool
L55:
    r118 = r91 + 2
    r91 = r118
    r119 = r92 + 2
    r92 = r119
    goto L44
L56:
    r120 = PyList_AsTuple(r90)
    dec_ref r90
    if is_error(r120) goto L86 (error at encode_tuple:39) else goto L57
L57:
    r121 = b''
    r122 = CPyBytes_Join(r121, r120)
    dec_ref r120
    if is_error(r122) goto L86 (error at encode_tuple:44) else goto L58
L58:
    r123 = b''
    r124 = CPyBytes_Join(r123, r1)
    dec_ref r1
    if is_error(r124) goto L87 (error at encode_tuple:44) else goto L59
L59:
    r125 = CPyBytes_Concat(r122, r124)
    dec_ref r124
    if is_error(r125) goto L61 (error at encode_tuple:44) else goto L60
L60:
    return r125
L61:
    r126 = <error> :: bytes
    return r126
L62:
    dec_ref r0
    goto L61
L63:
    dec_ref r0
    dec_ref r1
    goto L61
L64:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L61
L65:
    dec_ref r2
    dec_ref r3
    goto L17
L66:
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L17
L67:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    goto L61
L68:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L61
L69:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L61
L70:
    dec_ref r0
    dec_ref r1
    dec_ref r32 :: int
    goto L61
L71:
    dec_ref r44
    goto L23
L72:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    goto L61
L73:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r55
    goto L61
L74:
    dec_ref r55
    goto L36
L75:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r55
    dec_ref r58
    goto L61
L76:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r77
    goto L61
L77:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r83
    goto L61
L78:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r84
    goto L61
L79:
    dec_ref r88
    goto L41
L80:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r89
    goto L61
L81:
    dec_ref r0
    dec_ref head_length :: int
    dec_ref r89
    goto L56
L82:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r89
    dec_ref r90
    goto L61
L83:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r89
    dec_ref r90
    dec_ref r107
    goto L61
L84:
    dec_ref r107
    goto L50
L85:
    dec_ref r109 :: int
    goto L52
L86:
    dec_ref r1
    goto L61
L87:
    dec_ref r122
    goto L61

def encode_fixed(value, encode_fn, is_big_endian, data_byte_size):
    value, encode_fn :: object
    is_big_endian :: bool
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3, r4 :: bytes
    r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bytes
    r12 :: str
    r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L9 (error at encode_fixed:53) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L9 (error at encode_fixed:53) else goto L2
L2:
    if is_big_endian goto L3 else goto L6 :: bool
L3:
    r4 = b'\x00'
    r5 = 'rjust'
    inc_ref data_byte_size :: int
    r6 = box(int, data_byte_size)
    r7 = [r3, r6, r4]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r5, r8, 9223372036854775811, 0)
    if is_error(r9) goto L10 (error at encode_fixed:55) else goto L4
L4:
    dec_ref r3
    dec_ref r6
    r10 = cast(bytes, r9)
    if is_error(r10) goto L9 (error at encode_fixed:55) else goto L5
L5:
    return r10
L6:
    r11 = b'\x00'
    r12 = 'ljust'
    inc_ref data_byte_size :: int
    r13 = box(int, data_byte_size)
    r14 = [r3, r13, r11]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r12, r15, 9223372036854775811, 0)
    if is_error(r16) goto L11 (error at encode_fixed:57) else goto L7
L7:
    dec_ref r3
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at encode_fixed:57) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r3
    dec_ref r6
    goto L9
L11:
    dec_ref r3
    dec_ref r13
    goto L9

def encode_signed(value, encode_fn, data_byte_size):
    value, encode_fn :: object
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3 :: bytes
    r4, r5 :: object
    r6 :: bool
    r7 :: bytes
    r8 :: str
    r9 :: object
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L11 (error at encode_signed:65) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L11 (error at encode_signed:65) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(value, r4, 5)
    if is_error(r5) goto L12 (error at encode_signed:66) else goto L3
L3:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L12 (error at encode_signed:66) else goto L4
L4:
    if r6 goto L5 else goto L8 :: bool
L5:
    r7 = b'\x00'
    r8 = 'rjust'
    inc_ref data_byte_size :: int
    r9 = box(int, data_byte_size)
    r10 = [r3, r9, r7]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r8, r11, 9223372036854775811, 0)
    if is_error(r12) goto L13 (error at encode_signed:67) else goto L6
L6:
    dec_ref r3
    dec_ref r9
    r13 = cast(bytes, r12)
    if is_error(r13) goto L11 (error at encode_signed:67) else goto L7
L7:
    return r13
L8:
    r14 = b'\xff'
    r15 = 'rjust'
    inc_ref data_byte_size :: int
    r16 = box(int, data_byte_size)
    r17 = [r3, r16, r14]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r15, r18, 9223372036854775811, 0)
    if is_error(r19) goto L14 (error at encode_signed:69) else goto L9
L9:
    dec_ref r3
    dec_ref r16
    r20 = cast(bytes, r19)
    if is_error(r20) goto L11 (error at encode_signed:69) else goto L10
L10:
    return r20
L11:
    r21 = <error> :: bytes
    return r21
L12:
    dec_ref r3
    goto L11
L13:
    dec_ref r3
    dec_ref r9
    goto L11
L14:
    dec_ref r3
    dec_ref r16
    goto L11

def encode_elements(item_encoder, value):
    item_encoder, value :: object
    r0 :: list
    r1, r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bytes
    r7 :: i32
    r8, r9 :: bit
    r10 :: tuple
    r11 :: str
    r12, r13 :: object
    items_are_dynamic :: union[object, bool]
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: int
    r18 :: bit
    r19, r20 :: bytes
    r21, r22 :: int
    r23 :: object
    r24 :: tuple
    r25 :: ptr
    r26 :: native_int
    r27 :: list
    r28 :: short_int
    r29 :: ptr
    r30 :: native_int
    r31 :: short_int
    r32 :: bit
    r33 :: object
    r34 :: bytes
    r35 :: ptr
    r36 :: native_int
    r37 :: short_int
    r38 :: object
    r39 :: bit
    r40 :: short_int
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: object[1]
    r46 :: object_ptr
    r47 :: object
    r48 :: list
    r49 :: object
    r50, r51 :: ptr
    r52 :: object
    r53 :: tuple
    r54 :: ptr
    r55 :: native_int
    r56 :: tuple
    r57 :: short_int
    r58 :: ptr
    r59 :: native_int
    r60 :: short_int
    r61 :: bit
    r62 :: object
    r63, r64 :: int
    r65 :: bytes
    r66 :: bit
    r67 :: short_int
    r68, r69, r70, r71, r72, r73 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L43 (error at encode_elements:73) else goto L1
L1:
    r1 = PyObject_GetIter(value)
    if is_error(r1) goto L44 (error at encode_elements:73) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L45 else goto L3
L3:
    r3 = [r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(item_encoder, r4, 1, 0)
    if is_error(r5) goto L46 (error at encode_elements:73) else goto L4
L4:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L47 (error at encode_elements:73) else goto L5
L5:
    r7 = PyList_Append(r0, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L47 (error at encode_elements:73) else goto L2 :: bool
L6:
    r9 = CPy_NoErrOccurred()
    if not r9 goto L44 (error at encode_elements:73) else goto L7 :: bool
L7:
    r10 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r10) goto L43 (error at encode_elements:73) else goto L8
L8:
    r11 = 'is_dynamic'
    r12 = box(bool, 0)
    r13 = CPyObject_GetAttr3(item_encoder, r11, r12)
    if is_error(r13) goto L48 (error at encode_elements:75) else goto L9
L9:
    items_are_dynamic = r13
    r14 = PyObject_IsTrue(items_are_dynamic)
    dec_ref items_are_dynamic
    r15 = r14 >= 0 :: signed
    if not r15 goto L48 (error at encode_elements:75) else goto L10 :: bool
L10:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L11 else goto L13 :: bool
L11:
    r17 = CPyObject_Size(value)
    if is_error(r17) goto L48 (error at encode_elements:76) else goto L12
L12:
    r18 = r17 == 0
    dec_ref r17 :: int
    if r18 goto L13 else goto L15 :: bool
L13:
    r19 = b''
    r20 = CPyBytes_Join(r19, r10)
    dec_ref r10
    if is_error(r20) goto L43 (error at encode_elements:77) else goto L14
L14:
    return r20
L15:
    r21 = CPyObject_Size(value)
    if is_error(r21) goto L48 (error at encode_elements:79) else goto L16
L16:
    r22 = CPyTagged_Multiply(64, r21)
    dec_ref r21 :: int
    r23 = CPySequenceTuple_GetSlice(r10, 0, -2)
    if is_error(r23) goto L49 (error at encode_elements:80) else goto L17
L17:
    r24 = cast(tuple, r23)
    if is_error(r24) goto L49 (error at encode_elements:80) else goto L18
L18:
    r25 = get_element_ptr r24 ob_size :: PyVarObject
    r26 = load_mem r25 :: native_int*
    r27 = PyList_New(r26)
    if is_error(r27) goto L50 (error at encode_elements:80) else goto L19
L19:
    r28 = 0
L20:
    r29 = get_element_ptr r24 ob_size :: PyVarObject
    r30 = load_mem r29 :: native_int*
    r31 = r30 << 1
    r32 = r28 < r31 :: signed
    if r32 goto L21 else goto L51 :: bool
L21:
    r33 = CPySequenceTuple_GetItem(r24, r28)
    if is_error(r33) goto L52 (error at encode_elements:80) else goto L22
L22:
    r34 = cast(bytes, r33)
    if is_error(r34) goto L52 (error at encode_elements:80) else goto L23
L23:
    r35 = get_element_ptr r34 ob_size :: PyVarObject
    r36 = load_mem r35 :: native_int*
    dec_ref r34
    r37 = r36 << 1
    r38 = box(short_int, r37)
    r39 = CPyList_SetItemUnsafe(r27, r28, r38)
    if not r39 goto L52 (error at encode_elements:80) else goto L24 :: bool
L24:
    r40 = r28 + 2
    r28 = r40
    goto L20
L25:
    r41 = PyObject_GetIter(r27)
    dec_ref r27
    if is_error(r41) goto L49 (error at encode_elements:80) else goto L26
L26:
    r42 = faster_eth_abi._encoding.globals :: static
    r43 = 'accumulate'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L53 (error at encode_elements:80) else goto L27
L27:
    r45 = [r41]
    r46 = load_address r45
    r47 = PyObject_Vectorcall(r44, r46, 1, 0)
    dec_ref r44
    if is_error(r47) goto L53 (error at encode_elements:80) else goto L28
L28:
    dec_ref r41
    r48 = PyList_New(1)
    if is_error(r48) goto L54 (error at encode_elements:80) else goto L29
L29:
    r49 = object 0
    r50 = get_element_ptr r48 ob_item :: PyListObject
    r51 = load_mem r50 :: ptr*
    inc_ref r49
    set_mem r51, r49 :: builtins.object*
    r52 = CPyList_Extend(r48, r47)
    dec_ref r47
    if is_error(r52) goto L55 (error at encode_elements:80) else goto L56
L30:
    r53 = PyList_AsTuple(r48)
    dec_ref r48
    if is_error(r53) goto L49 (error at encode_elements:80) else goto L31
L31:
    r54 = get_element_ptr r53 ob_size :: PyVarObject
    r55 = load_mem r54 :: native_int*
    r56 = PyTuple_New(r55)
    if is_error(r56) goto L57 (error at encode_elements:81) else goto L32
L32:
    r57 = 0
L33:
    r58 = get_element_ptr r53 ob_size :: PyVarObject
    r59 = load_mem r58 :: native_int*
    r60 = r59 << 1
    r61 = r57 < r60 :: signed
    if r61 goto L34 else goto L58 :: bool
L34:
    r62 = CPySequenceTuple_GetItem(r53, r57)
    if is_error(r62) goto L59 (error at encode_elements:81) else goto L35
L35:
    r63 = unbox(int, r62)
    dec_ref r62
    if is_error(r63) goto L59 (error at encode_elements:81) else goto L36
L36:
    r64 = CPyTagged_Add(r22, r63)
    dec_ref r63 :: int
    r65 = encode_uint_256(r64)
    dec_ref r64 :: int
    if is_error(r65) goto L59 (error at encode_elements:82) else goto L37
L37:
    r66 = CPySequenceTuple_SetItemUnsafe(r56, r57, r65)
    if not r66 goto L59 (error at encode_elements:81) else goto L38 :: bool
L38:
    r67 = r57 + 2
    r57 = r67
    goto L33
L39:
    r68 = b''
    r69 = CPyBytes_Join(r68, r56)
    dec_ref r56
    if is_error(r69) goto L48 (error at encode_elements:84) else goto L40
L40:
    r70 = b''
    r71 = CPyBytes_Join(r70, r10)
    dec_ref r10
    if is_error(r71) goto L60 (error at encode_elements:84) else goto L41
L41:
    r72 = CPyBytes_Concat(r69, r71)
    dec_ref r71
    if is_error(r72) goto L43 (error at encode_elements:84) else goto L42
L42:
    return r72
L43:
    r73 = <error> :: bytes
    return r73
L44:
    dec_ref r0
    goto L43
L45:
    dec_ref r1
    goto L6
L46:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L43
L47:
    dec_ref r0
    dec_ref r1
    goto L43
L48:
    dec_ref r10
    goto L43
L49:
    dec_ref r10
    dec_ref r22 :: int
    goto L43
L50:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r24
    goto L43
L51:
    dec_ref r24
    goto L25
L52:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r24
    dec_ref r27
    goto L43
L53:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r41
    goto L43
L54:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r47
    goto L43
L55:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r48
    goto L43
L56:
    dec_ref r52
    goto L30
L57:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r53
    goto L43
L58:
    dec_ref r22 :: int
    dec_ref r53
    goto L39
L59:
    dec_ref r10
    dec_ref r22 :: int
    dec_ref r53
    dec_ref r56
    goto L43
L60:
    dec_ref r69
    goto L43

def encode_elements_dynamic(item_encoder, value):
    item_encoder, value :: object
    r0 :: int
    r1, r2, r3, r4 :: bytes
L0:
    r0 = CPyObject_Size(value)
    if is_error(r0) goto L5 (error at encode_elements_dynamic:88) else goto L1
L1:
    r1 = encode_uint_256(r0)
    dec_ref r0 :: int
    if is_error(r1) goto L5 (error at encode_elements_dynamic:88) else goto L2
L2:
    r2 = encode_elements(item_encoder, value)
    if is_error(r2) goto L6 (error at encode_elements_dynamic:89) else goto L3
L3:
    r3 = CPyBytes_Concat(r1, r2)
    dec_ref r2
    if is_error(r3) goto L5 (error at encode_elements_dynamic:90) else goto L4
L4:
    return r3
L5:
    r4 = <error> :: bytes
    return r4
L6:
    dec_ref r1
    goto L5

def encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = int_to_big_endian(i)
    if is_error(r0) goto L4 (error at encode_uint_256:96) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at encode_uint_256:97) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at encode_uint_256:97) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at int_to_big_endian:102) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at int_to_big_endian:102) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at int_to_big_endian:102) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at int_to_big_endian:102) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('accumulate',)
    r6 = 'itertools'
    r7 = faster_eth_abi._encoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    itertools = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Callable', 'List', 'Optional', 'Sequence', 'TypeVar')
    r10 = 'typing'
    r11 = faster_eth_abi._encoding.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    if 0 goto L6 else goto L6 :: bool
L6:
    r13 = 'T'
    r14 = faster_eth_abi._encoding.globals :: static
    r15 = 'TypeVar'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L10 (error at <module>:20) else goto L7
L7:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L10 (error at <module>:20) else goto L8
L8:
    r20 = faster_eth_abi._encoding.globals :: static
    r21 = 'T'
    r22 = CPyDict_SetItem(r20, r21, r19)
    dec_ref r19
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:20) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24

def StrategyRegistry.__init__(self):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
    r8 :: None
L0:
    r0 = 'strategy registry'
    r1 = faster_eth_abi.tools._strategies.globals :: static
    r2 = 'PredicateMapping'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L4 (error at __init__:43) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __init__:43) else goto L2
L2:
    self._strategies = r6; r7 = is_error
    if not r7 goto L4 (error at __init__:43) else goto L3 :: bool
L3:
    return 1
L4:
    r8 = <error> :: None
    return r8

def StrategyRegistry.register_strategy(self, lookup, registration, label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup :: union[str, object]
    registration :: object
    label :: union[str, None]
    r0, r1 :: object
    r2 :: str
    r3 :: object[5]
    r4 :: object_ptr
    r5, r6 :: object
    r7 :: None
L0:
    if is_error(label) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._strategies
    if is_error(r1) goto L7 (error at register_strategy:51) else goto L3
L3:
    r2 = '_register'
    r3 = [self, r1, lookup, registration, label]
    r4 = load_address r3
    r5 = ('label',)
    r6 = PyObject_VectorcallMethod(r2, r4, 9223372036854775812, r5)
    if is_error(r6) goto L8 (error at register_strategy:51) else goto L9
L4:
    dec_ref r1
    dec_ref label
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    inc_ref label
    goto L2
L7:
    dec_ref label
    goto L5
L8:
    dec_ref label
    dec_ref r1
    goto L5
L9:
    dec_ref r6
    goto L4

def StrategyRegistry.unregister_strategy(self, lookup_or_label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup_or_label :: union[str, object]
    r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: None
L0:
    r0 = self._strategies
    if is_error(r0) goto L3 (error at unregister_strategy:54) else goto L1
L1:
    r1 = '_unregister'
    r2 = [self, r0, lookup_or_label]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L4 (error at unregister_strategy:54) else goto L5
L2:
    dec_ref r0
    return 1
L3:
    r5 = <error> :: None
    return r5
L4:
    dec_ref r0
    goto L3
L5:
    dec_ref r4
    goto L2

def StrategyRegistry.get_strategy(self, type_str):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    type_str :: str
    r0 :: object
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = self._strategies
    if is_error(r0) goto L14 (error at get_strategy:66) else goto L1
L1:
    r1 = '_get_registration'
    r2 = [self, r0, type_str]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L15 (error at get_strategy:66) else goto L2
L2:
    dec_ref r0
    r5 = faster_eth_abi.tools._strategies.globals :: static
    r6 = 'st'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L16 (error at get_strategy:68) else goto L3
L3:
    r8 = 'SearchStrategy'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L16 (error at get_strategy:68) else goto L4
L4:
    r10 = PyObject_IsInstance(r4, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L16 (error at get_strategy:68) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L7 :: bool
L6:
    return r4
L7:
    r13 = faster_eth_abi.tools._strategies.globals :: static
    r14 = 'normalize'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at get_strategy:74) else goto L8
L8:
    r16 = [type_str]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L16 (error at get_strategy:74) else goto L9
L9:
    r19 = cast(str, r18)
    if is_error(r19) goto L16 (error at get_strategy:74) else goto L10
L10:
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = 'parse'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L17 (error at get_strategy:75) else goto L11
L11:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L17 (error at get_strategy:75) else goto L12
L12:
    dec_ref r19
    r26 = [r25, self]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r4, r27, 2, 0)
    dec_ref r4
    if is_error(r28) goto L18 (error at get_strategy:76) else goto L13
L13:
    dec_ref r25
    return r28
L14:
    r29 = <error> :: object
    return r29
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r4
    goto L14
L17:
    dec_ref r4
    dec_ref r19
    goto L14
L18:
    dec_ref r25
    goto L14

def get_uint_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[3]
    r12 :: object_ptr
    r13, r14, r15 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L6 (error at get_uint_strategy:84) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L7 (error at get_uint_strategy:86) else goto L2
L2:
    r5 = object 2
    r6 = CPyNumber_Power(r5, r1)
    dec_ref r1
    if is_error(r6) goto L8 (error at get_uint_strategy:88) else goto L3
L3:
    r7 = object 1
    r8 = PyNumber_Subtract(r6, r7)
    dec_ref r6
    if is_error(r8) goto L8 (error at get_uint_strategy:88) else goto L4
L4:
    r9 = 'integers'
    r10 = object 0
    r11 = [r4, r10, r8]
    r12 = load_address r11
    r13 = ('min_value', 'max_value')
    r14 = PyObject_VectorcallMethod(r9, r12, 9223372036854775809, r13)
    if is_error(r14) goto L9 (error at get_uint_strategy:86) else goto L5
L5:
    dec_ref r4
    dec_ref r8
    return r14
L6:
    r15 = <error> :: object
    return r15
L7:
    dec_ref r1
    goto L6
L8:
    dec_ref r4
    goto L6
L9:
    dec_ref r4
    dec_ref r8
    goto L6

def get_int_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L10 (error at get_int_strategy:95) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L11 (error at get_int_strategy:97) else goto L2
L2:
    r5 = object 1
    r6 = PyNumber_Subtract(r1, r5)
    if is_error(r6) goto L12 (error at get_int_strategy:98) else goto L3
L3:
    r7 = object 2
    r8 = CPyNumber_Power(r7, r6)
    dec_ref r6
    if is_error(r8) goto L12 (error at get_int_strategy:98) else goto L4
L4:
    r9 = PyNumber_Negative(r8)
    dec_ref r8
    if is_error(r9) goto L12 (error at get_int_strategy:98) else goto L5
L5:
    r10 = object 1
    r11 = PyNumber_Subtract(r1, r10)
    dec_ref r1
    if is_error(r11) goto L13 (error at get_int_strategy:99) else goto L6
L6:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r11)
    dec_ref r11
    if is_error(r13) goto L13 (error at get_int_strategy:99) else goto L7
L7:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L13 (error at get_int_strategy:99) else goto L8
L8:
    r16 = 'integers'
    r17 = [r4, r9, r15]
    r18 = load_address r17
    r19 = ('min_value', 'max_value')
    r20 = PyObject_VectorcallMethod(r16, r18, 9223372036854775809, r19)
    if is_error(r20) goto L14 (error at get_int_strategy:97) else goto L9
L9:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    return r20
L10:
    r21 = <error> :: object
    return r21
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r4
    goto L10
L13:
    dec_ref r4
    dec_ref r9
    goto L10
L14:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    goto L10

def get_ufixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17, r18 :: object
    r19 :: object[4]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: int
    r24 :: object
    r25 :: str
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L19 (error at get_ufixed_strategy:110) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L19 (error at get_ufixed_strategy:110) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L20 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L19 (error at get_ufixed_strategy:110) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L21 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L19 (error at get_ufixed_strategy:110) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L22
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L19 (error at get_ufixed_strategy:110) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L23 (error at get_ufixed_strategy:112) else goto L12
L12:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r3)
    dec_ref r3
    if is_error(r13) goto L24 (error at get_ufixed_strategy:114) else goto L13
L13:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L24 (error at get_ufixed_strategy:114) else goto L14
L14:
    r16 = 'decimals'
    r17 = object 0
    r18 = object 0
    r19 = [r11, r17, r15, r18]
    r20 = load_address r19
    r21 = ('min_value', 'max_value', 'places')
    r22 = PyObject_VectorcallMethod(r16, r20, 9223372036854775809, r21)
    if is_error(r22) goto L25 (error at get_ufixed_strategy:112) else goto L15
L15:
    dec_ref r11
    dec_ref r15
    r23 = unbox(int, r5)
    dec_ref r5
    if is_error(r23) goto L26 (error at get_ufixed_strategy:116) else goto L16
L16:
    r24 = scale_places(r23)
    dec_ref r23 :: int
    if is_error(r24) goto L26 (error at get_ufixed_strategy:116) else goto L17
L17:
    r25 = 'map'
    r26 = [r22, r24]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r25, r27, 9223372036854775810, 0)
    if is_error(r28) goto L27 (error at get_ufixed_strategy:112) else goto L18
L18:
    dec_ref r22
    dec_ref r24
    return r28
L19:
    r29 = <error> :: object
    return r29
L20:
    dec_ref r2
    goto L3
L21:
    dec_ref r2
    dec_ref r3
    goto L6
L22:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L23:
    dec_ref r3
    dec_ref r5
    goto L19
L24:
    dec_ref r5
    dec_ref r11
    goto L19
L25:
    dec_ref r5
    dec_ref r11
    dec_ref r15
    goto L19
L26:
    dec_ref r22
    goto L19
L27:
    dec_ref r22
    dec_ref r24
    goto L19

def get_fixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[4]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: int
    r30 :: object
    r31 :: str
    r32 :: object[2]
    r33 :: object_ptr
    r34, r35 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L23 (error at get_fixed_strategy:122) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L23 (error at get_fixed_strategy:122) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L24 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L23 (error at get_fixed_strategy:122) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L25 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L23 (error at get_fixed_strategy:122) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L26
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L23 (error at get_fixed_strategy:122) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L27 (error at get_fixed_strategy:124) else goto L12
L12:
    r12 = object 1
    r13 = PyNumber_Subtract(r3, r12)
    if is_error(r13) goto L28 (error at get_fixed_strategy:125) else goto L13
L13:
    r14 = object 2
    r15 = CPyNumber_Power(r14, r13)
    dec_ref r13
    if is_error(r15) goto L28 (error at get_fixed_strategy:125) else goto L14
L14:
    r16 = PyNumber_Negative(r15)
    dec_ref r15
    if is_error(r16) goto L28 (error at get_fixed_strategy:125) else goto L15
L15:
    r17 = object 1
    r18 = PyNumber_Subtract(r3, r17)
    dec_ref r3
    if is_error(r18) goto L29 (error at get_fixed_strategy:126) else goto L16
L16:
    r19 = object 2
    r20 = CPyNumber_Power(r19, r18)
    dec_ref r18
    if is_error(r20) goto L29 (error at get_fixed_strategy:126) else goto L17
L17:
    r21 = object 1
    r22 = PyNumber_Subtract(r20, r21)
    dec_ref r20
    if is_error(r22) goto L29 (error at get_fixed_strategy:126) else goto L18
L18:
    r23 = 'decimals'
    r24 = object 0
    r25 = [r11, r16, r22, r24]
    r26 = load_address r25
    r27 = ('min_value', 'max_value', 'places')
    r28 = PyObject_VectorcallMethod(r23, r26, 9223372036854775809, r27)
    if is_error(r28) goto L30 (error at get_fixed_strategy:124) else goto L19
L19:
    dec_ref r11
    dec_ref r16
    dec_ref r22
    r29 = unbox(int, r5)
    dec_ref r5
    if is_error(r29) goto L31 (error at get_fixed_strategy:128) else goto L20
L20:
    r30 = scale_places(r29)
    dec_ref r29 :: int
    if is_error(r30) goto L31 (error at get_fixed_strategy:128) else goto L21
L21:
    r31 = 'map'
    r32 = [r28, r30]
    r33 = load_address r32
    r34 = PyObject_VectorcallMethod(r31, r33, 9223372036854775810, 0)
    if is_error(r34) goto L32 (error at get_fixed_strategy:124) else goto L22
L22:
    dec_ref r28
    dec_ref r30
    return r34
L23:
    r35 = <error> :: object
    return r35
L24:
    dec_ref r2
    goto L3
L25:
    dec_ref r2
    dec_ref r3
    goto L6
L26:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L27:
    dec_ref r3
    dec_ref r5
    goto L23
L28:
    dec_ref r3
    dec_ref r5
    dec_ref r11
    goto L23
L29:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    goto L23
L30:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    dec_ref r22
    goto L23
L31:
    dec_ref r28
    goto L23
L32:
    dec_ref r28
    dec_ref r30
    goto L23

def get_bytes_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8, r9, r10 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L4 (error at get_bytes_strategy:134) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L5 (error at get_bytes_strategy:136) else goto L2
L2:
    r5 = 'binary'
    r6 = [r4, r1, r1]
    r7 = load_address r6
    r8 = ('min_size', 'max_size')
    r9 = PyObject_VectorcallMethod(r5, r7, 9223372036854775809, r8)
    if is_error(r9) goto L6 (error at get_bytes_strategy:136) else goto L3
L3:
    dec_ref r4
    dec_ref r1
    return r9
L4:
    r10 = <error> :: object
    return r10
L5:
    dec_ref r1
    goto L4
L6:
    dec_ref r1
    dec_ref r4
    goto L4

def get_array_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9, r10, r11 :: object
    r12 :: int
    r13 :: bit
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object[2]
    r19 :: object_ptr
    r20, r21, r22 :: object
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object[4]
    r28 :: object_ptr
    r29, r30, r31 :: object
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L15 (error at get_array_strategy:149) else goto L1
L1:
    r2 = 'to_type_str'
    r3 = [r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L16 (error at get_array_strategy:150) else goto L2
L2:
    dec_ref r1
    r6 = cast(str, r5)
    if is_error(r6) goto L15 (error at get_array_strategy:150) else goto L3
L3:
    r7 = registry.get_strategy(r6)
    dec_ref r6
    if is_error(r7) goto L15 (error at get_array_strategy:151) else goto L4
L4:
    r8 = 'arrlist'
    r9 = CPyObject_GetAttr(abi_type, r8)
    if is_error(r9) goto L17 (error at get_array_strategy:153) else goto L5
L5:
    r10 = object -1
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L17 (error at get_array_strategy:153) else goto L6
L6:
    r12 = CPyObject_Size(r11)
    if is_error(r12) goto L18 (error at get_array_strategy:154) else goto L7
L7:
    r13 = r12 == 0
    dec_ref r12 :: int
    if r13 goto L19 else goto L11 :: bool
L8:
    r14 = faster_eth_abi.tools._strategies.globals :: static
    r15 = 'st'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L17 (error at get_array_strategy:156) else goto L9
L9:
    r17 = 'lists'
    r18 = [r16, r7]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775810, 0)
    if is_error(r20) goto L20 (error at get_array_strategy:156) else goto L10
L10:
    dec_ref r16
    dec_ref r7
    return r20
L11:
    r21 = object 0
    r22 = PyObject_GetItem(r11, r21)
    dec_ref r11
    if is_error(r22) goto L17 (error at get_array_strategy:159) else goto L12
L12:
    r23 = faster_eth_abi.tools._strategies.globals :: static
    r24 = 'st'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L21 (error at get_array_strategy:160) else goto L13
L13:
    r26 = 'lists'
    r27 = [r25, r7, r22, r22]
    r28 = load_address r27
    r29 = ('min_size', 'max_size')
    r30 = PyObject_VectorcallMethod(r26, r28, 9223372036854775810, r29)
    if is_error(r30) goto L22 (error at get_array_strategy:160) else goto L14
L14:
    dec_ref r25
    dec_ref r7
    dec_ref r22
    return r30
L15:
    r31 = <error> :: object
    return r31
L16:
    dec_ref r1
    goto L15
L17:
    dec_ref r7
    goto L15
L18:
    dec_ref r7
    dec_ref r11
    goto L15
L19:
    dec_ref r11
    goto L8
L20:
    dec_ref r7
    dec_ref r16
    goto L15
L21:
    dec_ref r7
    dec_ref r22
    goto L15
L22:
    dec_ref r7
    dec_ref r22
    dec_ref r25
    goto L15

def get_tuple_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: tuple
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: short_int
    r7 :: ptr
    r8 :: native_int
    r9 :: short_int
    r10 :: bit
    r11 :: object
    r12 :: str
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: bit
    r19 :: short_int
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: list
    r26 :: object
    r27 :: tuple
    r28 :: dict
    r29, r30 :: object
L0:
    r0 = 'components'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L19 (error at get_tuple_strategy:168) else goto L1
L1:
    r2 = cast(tuple, r1)
    if is_error(r2) goto L19 (error at get_tuple_strategy:168) else goto L2
L2:
    r3 = get_element_ptr r2 ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L20 (error at get_tuple_strategy:166) else goto L3
L3:
    r6 = 0
L4:
    r7 = get_element_ptr r2 ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = r8 << 1
    r10 = r6 < r9 :: signed
    if r10 goto L5 else goto L21 :: bool
L5:
    r11 = CPySequenceTuple_GetItem(r2, r6)
    if is_error(r11) goto L22 (error at get_tuple_strategy:166) else goto L6
L6:
    r12 = 'to_type_str'
    r13 = [r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775809, 0)
    if is_error(r15) goto L23 (error at get_tuple_strategy:167) else goto L7
L7:
    dec_ref r11
    r16 = cast(str, r15)
    if is_error(r16) goto L22 (error at get_tuple_strategy:167) else goto L8
L8:
    r17 = registry.get_strategy(r16)
    dec_ref r16
    if is_error(r17) goto L22 (error at get_tuple_strategy:167) else goto L9
L9:
    r18 = CPyList_SetItemUnsafe(r5, r6, r17)
    if not r18 goto L22 (error at get_tuple_strategy:166) else goto L10 :: bool
L10:
    r19 = r6 + 2
    r6 = r19
    goto L4
L11:
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = 'st'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L24 (error at get_tuple_strategy:171) else goto L12
L12:
    r23 = 'tuples'
    r24 = CPyObject_GetAttr(r22, r23)
    dec_ref r22
    if is_error(r24) goto L24 (error at get_tuple_strategy:171) else goto L13
L13:
    r25 = PyList_New(0)
    if is_error(r25) goto L25 (error at get_tuple_strategy:171) else goto L14
L14:
    r26 = CPyList_Extend(r25, r5)
    dec_ref r5
    if is_error(r26) goto L26 (error at get_tuple_strategy:171) else goto L27
L15:
    r27 = PyList_AsTuple(r25)
    dec_ref r25
    if is_error(r27) goto L28 (error at get_tuple_strategy:171) else goto L16
L16:
    r28 = PyDict_New()
    if is_error(r28) goto L29 (error at get_tuple_strategy:171) else goto L17
L17:
    r29 = PyObject_Call(r24, r27, r28)
    dec_ref r24
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L19 (error at get_tuple_strategy:171) else goto L18
L18:
    return r29
L19:
    r30 = <error> :: object
    return r30
L20:
    dec_ref r2
    goto L19
L21:
    dec_ref r2
    goto L11
L22:
    dec_ref r2
    dec_ref r5
    goto L19
L23:
    dec_ref r2
    dec_ref r5
    dec_ref r11
    goto L19
L24:
    dec_ref r5
    goto L19
L25:
    dec_ref r5
    dec_ref r24
    goto L19
L26:
    dec_ref r24
    dec_ref r25
    goto L19
L27:
    dec_ref r26
    goto L15
L28:
    dec_ref r24
    goto L19
L29:
    dec_ref r24
    dec_ref r27
    goto L19

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17, r18 :: object
    r19 :: str
    r20 :: dict
    r21, r22 :: object
    r23 :: str
    r24 :: dict
    r25, r26 :: object
    r27 :: str
    r28 :: dict
    r29, r30 :: object
    r31 :: str
    r32 :: dict
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: tuple[list, object]
    r51, r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58 :: str
    r59 :: object
    r60 :: dict
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: tuple[object, object]
    r69, r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: tuple
    r79 :: str
    r80, r81 :: object
    r82 :: bool
    r83, r84, r85 :: str
    r86 :: tuple
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: str
    r97, r98 :: object
    r99 :: object[3]
    r100 :: object_ptr
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: str
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: str
    r118 :: object[1]
    r119 :: object_ptr
    r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: str
    r129, r130 :: object
    r131 :: object[3]
    r132 :: object_ptr
    r133, r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: i32
    r138 :: bit
    r139 :: dict
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: object[1]
    r144 :: object_ptr
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: i32
    r149 :: bit
    r150 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r151 :: dict
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r156 :: bool
    r157 :: str
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: object[1]
    r162 :: object_ptr
    r163 :: object
    r164 :: dict
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: None
    r169 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r170 :: bool
    r171 :: str
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: object[1]
    r176 :: object_ptr
    r177 :: object
    r178 :: dict
    r179 :: str
    r180 :: object
    r181 :: str
    r182 :: None
    r183 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r184 :: bool
    r185 :: str
    r186 :: dict
    r187 :: str
    r188, r189 :: object
    r190 :: object[2]
    r191 :: object_ptr
    r192, r193, r194 :: object
    r195 :: bool
    r196 :: str
    r197 :: None
    r198 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r199 :: bool
    r200 :: str
    r201 :: dict
    r202 :: str
    r203, r204 :: object
    r205 :: object[2]
    r206 :: object_ptr
    r207, r208, r209 :: object
    r210 :: bool
    r211 :: str
    r212 :: None
    r213 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r214 :: bool
    r215 :: str
    r216 :: dict
    r217 :: str
    r218 :: object
    r219 :: object[1]
    r220 :: object_ptr
    r221 :: object
    r222 :: dict
    r223 :: str
    r224 :: object
    r225 :: str
    r226 :: None
    r227 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r228 :: bool
    r229 :: str
    r230 :: dict
    r231 :: str
    r232 :: object
    r233 :: object[1]
    r234 :: object_ptr
    r235 :: object
    r236 :: dict
    r237 :: str
    r238 :: object
    r239 :: str
    r240 :: None
    r241 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r242 :: bool
    r243 :: str
    r244 :: dict
    r245 :: str
    r246, r247 :: object
    r248 :: object[2]
    r249 :: object_ptr
    r250, r251 :: object
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: str
    r256 :: None
    r257 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r258 :: bool
    r259 :: str
    r260 :: dict
    r261 :: str
    r262, r263 :: object
    r264 :: object[2]
    r265 :: object_ptr
    r266, r267, r268 :: object
    r269 :: bool
    r270 :: str
    r271 :: None
    r272 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r273 :: bool
    r274 :: str
    r275 :: dict
    r276 :: str
    r277, r278 :: object
    r279 :: object[2]
    r280 :: object_ptr
    r281, r282 :: object
    r283 :: dict
    r284 :: str
    r285 :: object
    r286 :: str
    r287 :: None
    r288 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r289 :: bool
    r290 :: str
    r291 :: dict
    r292 :: str
    r293, r294 :: object
    r295 :: object[2]
    r296 :: object_ptr
    r297, r298, r299 :: object
    r300 :: bool
    r301 :: str
    r302 :: None
    r303 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r304 :: bool
    r305 :: dict
    r306 :: str
    r307 :: object
    r308 :: dict
    r309 :: str
    r310 :: object
    r311 :: str
    r312 :: None
    r313 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r314 :: bool
    r315 :: dict
    r316 :: str
    r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: object
    r321 :: str
    r322 :: None
    r323 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r324 :: bool
    r325 :: str
    r326 :: object
    r327 :: dict
    r328 :: str
    r329 :: i32
    r330 :: bit
    r331 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L142 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Callable', 'Final', 'Optional', 'Union')
    r6 = 'typing'
    r7 = faster_eth_abi.tools._strategies.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L142 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('to_checksum_address',)
    r10 = 'cchecksum'
    r11 = faster_eth_abi.tools._strategies.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L142 (error at <module>:8) else goto L5
L5:
    cchecksum = r12 :: module
    dec_ref r12
    r13 = ('TypeStr',)
    r14 = 'eth_typing.abi'
    r15 = faster_eth_abi.tools._strategies.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L142 (error at <module>:11) else goto L6
L6:
    eth_typing.abi = r16 :: module
    dec_ref r16
    r17 = ('strategies',)
    r18 = ('st',)
    r19 = 'hypothesis'
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = CPyImport_ImportFromMany(r19, r17, r18, r20)
    if is_error(r21) goto L142 (error at <module>:14) else goto L7
L7:
    hypothesis = r21 :: module
    dec_ref r21
    r22 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r23 = 'faster_eth_abi.grammar'
    r24 = faster_eth_abi.tools._strategies.globals :: static
    r25 = CPyImport_ImportFromMany(r23, r22, r22, r24)
    if is_error(r25) goto L142 (error at <module>:18) else goto L8
L8:
    faster_eth_abi.grammar = r25 :: module
    dec_ref r25
    r26 = ('BaseEquals', 'BaseRegistry', 'Lookup', 'PredicateMapping', 'has_arrlist', 'is_base_tuple')
    r27 = 'faster_eth_abi.registry'
    r28 = faster_eth_abi.tools._strategies.globals :: static
    r29 = CPyImport_ImportFromMany(r27, r26, r26, r28)
    if is_error(r29) goto L142 (error at <module>:25) else goto L9
L9:
    faster_eth_abi.registry = r29 :: module
    dec_ref r29
    r30 = ('scale_places',)
    r31 = 'faster_eth_abi.utils.numeric'
    r32 = faster_eth_abi.tools._strategies.globals :: static
    r33 = CPyImport_ImportFromMany(r31, r30, r30, r32)
    if is_error(r33) goto L142 (error at <module>:33) else goto L10
L10:
    faster_eth_abi.utils.numeric = r33 :: module
    dec_ref r33
    r34 = faster_eth_abi.tools._strategies.globals :: static
    r35 = 'Callable'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L142 (error at <module>:37) else goto L11
L11:
    r37 = faster_eth_abi.tools._strategies.globals :: static
    r38 = 'ABIType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L143 (error at <module>:37) else goto L12
L12:
    r40 = 'StrategyRegistry'
    r41 = PyList_New(2)
    if is_error(r41) goto L144 (error at <module>:37) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = faster_eth_abi.tools._strategies.globals :: static
    r46 = 'st'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L145 (error at <module>:37) else goto L14
L14:
    r48 = 'SearchStrategy'
    r49 = CPyObject_GetAttr(r47, r48)
    dec_ref r47
    if is_error(r49) goto L145 (error at <module>:37) else goto L15
L15:
    r50 = (r41, r49)
    r51 = box(tuple[list, object], r50)
    r52 = PyObject_GetItem(r36, r51)
    dec_ref r36
    dec_ref r51
    if is_error(r52) goto L142 (error at <module>:37) else goto L16
L16:
    r53 = faster_eth_abi.tools._strategies.globals :: static
    r54 = 'StrategyFactory'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L142 (error at <module>:37) else goto L17 :: bool
L17:
    r57 = faster_eth_abi.tools._strategies.globals :: static
    r58 = 'Union'
    r59 = CPyDict_GetItem(r57, r58)
    if is_error(r59) goto L142 (error at <module>:38) else goto L18
L18:
    r60 = faster_eth_abi.tools._strategies.globals :: static
    r61 = 'st'
    r62 = CPyDict_GetItem(r60, r61)
    if is_error(r62) goto L146 (error at <module>:38) else goto L19
L19:
    r63 = 'SearchStrategy'
    r64 = CPyObject_GetAttr(r62, r63)
    dec_ref r62
    if is_error(r64) goto L146 (error at <module>:38) else goto L20
L20:
    r65 = faster_eth_abi.tools._strategies.globals :: static
    r66 = 'StrategyFactory'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L147 (error at <module>:38) else goto L21
L21:
    r68 = (r64, r67)
    r69 = box(tuple[object, object], r68)
    r70 = PyObject_GetItem(r59, r69)
    dec_ref r59
    dec_ref r69
    if is_error(r70) goto L142 (error at <module>:38) else goto L22
L22:
    r71 = faster_eth_abi.tools._strategies.globals :: static
    r72 = 'StrategyRegistration'
    r73 = CPyDict_SetItem(r71, r72, r70)
    dec_ref r70
    r74 = r73 >= 0 :: signed
    if not r74 goto L142 (error at <module>:38) else goto L23 :: bool
L23:
    r75 = faster_eth_abi.tools._strategies.globals :: static
    r76 = 'BaseRegistry'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L142 (error at <module>:41) else goto L24
L24:
    r78 = PyTuple_Pack(1, r77)
    dec_ref r77
    if is_error(r78) goto L142 (error at <module>:41) else goto L25
L25:
    r79 = 'faster_eth_abi.tools._strategies'
    r80 = faster_eth_abi.tools._strategies.StrategyRegistry_template :: type
    r81 = CPyType_FromTemplate(r80, r78, r79)
    dec_ref r78
    if is_error(r81) goto L142 (error at <module>:41) else goto L26
L26:
    r82 = StrategyRegistry_trait_vtable_setup()
    if is_error(r82) goto L148 (error at <module>:-1) else goto L27
L27:
    r83 = '__mypyc_attrs__'
    r84 = '_strategies'
    r85 = '__dict__'
    r86 = PyTuple_Pack(2, r84, r85)
    if is_error(r86) goto L148 (error at <module>:41) else goto L28
L28:
    r87 = PyObject_SetAttr(r81, r83, r86)
    dec_ref r86
    r88 = r87 >= 0 :: signed
    if not r88 goto L148 (error at <module>:41) else goto L29 :: bool
L29:
    faster_eth_abi.tools._strategies.StrategyRegistry = r81 :: type
    r89 = faster_eth_abi.tools._strategies.globals :: static
    r90 = 'StrategyRegistry'
    r91 = CPyDict_SetItem(r89, r90, r81)
    dec_ref r81
    r92 = r91 >= 0 :: signed
    if not r92 goto L142 (error at <module>:41) else goto L30 :: bool
L30:
    r93 = faster_eth_abi.tools._strategies.globals :: static
    r94 = 'st'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L142 (error at <module>:103) else goto L31
L31:
    r96 = 'binary'
    r97 = object 20
    r98 = object 20
    r99 = [r95, r97, r98]
    r100 = load_address r99
    r101 = ('min_size', 'max_size')
    r102 = PyObject_VectorcallMethod(r96, r100, 9223372036854775809, r101)
    if is_error(r102) goto L149 (error at <module>:103) else goto L32
L32:
    dec_ref r95
    r103 = faster_eth_abi.tools._strategies.globals :: static
    r104 = 'to_checksum_address'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L150 (error at <module>:103) else goto L33
L33:
    r106 = 'map'
    r107 = [r102, r105]
    r108 = load_address r107
    r109 = PyObject_VectorcallMethod(r106, r108, 9223372036854775810, 0)
    if is_error(r109) goto L151 (error at <module>:103) else goto L34
L34:
    dec_ref r102
    dec_ref r105
    faster_eth_abi.tools._strategies.address_strategy = r109 :: static
    r110 = faster_eth_abi.tools._strategies.globals :: static
    r111 = 'address_strategy'
    r112 = CPyDict_SetItem(r110, r111, r109)
    dec_ref r109
    r113 = r112 >= 0 :: signed
    if not r113 goto L142 (error at <module>:103) else goto L35 :: bool
L35:
    r114 = faster_eth_abi.tools._strategies.globals :: static
    r115 = 'st'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L142 (error at <module>:104) else goto L36
L36:
    r117 = 'booleans'
    r118 = [r116]
    r119 = load_address r118
    r120 = PyObject_VectorcallMethod(r117, r119, 9223372036854775809, 0)
    if is_error(r120) goto L152 (error at <module>:104) else goto L37
L37:
    dec_ref r116
    faster_eth_abi.tools._strategies.bool_strategy = r120 :: static
    r121 = faster_eth_abi.tools._strategies.globals :: static
    r122 = 'bool_strategy'
    r123 = CPyDict_SetItem(r121, r122, r120)
    dec_ref r120
    r124 = r123 >= 0 :: signed
    if not r124 goto L142 (error at <module>:104) else goto L38 :: bool
L38:
    r125 = faster_eth_abi.tools._strategies.globals :: static
    r126 = 'st'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L142 (error at <module>:142) else goto L39
L39:
    r128 = 'binary'
    r129 = object 0
    r130 = object 4096
    r131 = [r127, r129, r130]
    r132 = load_address r131
    r133 = ('min_size', 'max_size')
    r134 = PyObject_VectorcallMethod(r128, r132, 9223372036854775809, r133)
    if is_error(r134) goto L153 (error at <module>:142) else goto L40
L40:
    dec_ref r127
    faster_eth_abi.tools._strategies.bytes_strategy = r134 :: static
    r135 = faster_eth_abi.tools._strategies.globals :: static
    r136 = 'bytes_strategy'
    r137 = CPyDict_SetItem(r135, r136, r134)
    dec_ref r134
    r138 = r137 >= 0 :: signed
    if not r138 goto L142 (error at <module>:142) else goto L41 :: bool
L41:
    r139 = faster_eth_abi.tools._strategies.globals :: static
    r140 = 'st'
    r141 = CPyDict_GetItem(r139, r140)
    if is_error(r141) goto L142 (error at <module>:143) else goto L42
L42:
    r142 = 'text'
    r143 = [r141]
    r144 = load_address r143
    r145 = PyObject_VectorcallMethod(r142, r144, 9223372036854775809, 0)
    if is_error(r145) goto L154 (error at <module>:143) else goto L43
L43:
    dec_ref r141
    faster_eth_abi.tools._strategies.string_strategy = r145 :: static
    r146 = faster_eth_abi.tools._strategies.globals :: static
    r147 = 'string_strategy'
    r148 = CPyDict_SetItem(r146, r147, r145)
    dec_ref r145
    r149 = r148 >= 0 :: signed
    if not r149 goto L142 (error at <module>:143) else goto L44 :: bool
L44:
    r150 = StrategyRegistry()
    if is_error(r150) goto L142 (error at <module>:174) else goto L45
L45:
    faster_eth_abi.tools._strategies.strategy_registry = r150 :: static
    r151 = faster_eth_abi.tools._strategies.globals :: static
    r152 = 'strategy_registry'
    r153 = CPyDict_SetItem(r151, r152, r150)
    dec_ref r150
    r154 = r153 >= 0 :: signed
    if not r154 goto L142 (error at <module>:174) else goto L46 :: bool
L46:
    r155 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r155) goto L47 else goto L49
L47:
    r156 = raise NameError('value for final name "strategy_registry" was not set')
    if not r156 goto L142 (error at <module>:176) else goto L48 :: bool
L48:
    unreachable
L49:
    r157 = 'uint'
    r158 = faster_eth_abi.tools._strategies.globals :: static
    r159 = 'BaseEquals'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L142 (error at <module>:177) else goto L50
L50:
    r161 = [r157]
    r162 = load_address r161
    r163 = PyObject_Vectorcall(r160, r162, 1, 0)
    dec_ref r160
    if is_error(r163) goto L142 (error at <module>:177) else goto L51
L51:
    r164 = faster_eth_abi.tools._strategies.globals :: static
    r165 = 'get_uint_strategy'
    r166 = CPyDict_GetItem(r164, r165)
    if is_error(r166) goto L155 (error at <module>:178) else goto L52
L52:
    r167 = 'uint'
    r168 = r155.register_strategy(r163, r166, r167)
    dec_ref r163
    dec_ref r166
    if is_error(r168) goto L142 (error at <module>:176) else goto L53
L53:
    r169 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r169) goto L54 else goto L56
L54:
    r170 = raise NameError('value for final name "strategy_registry" was not set')
    if not r170 goto L142 (error at <module>:181) else goto L55 :: bool
L55:
    unreachable
L56:
    r171 = 'int'
    r172 = faster_eth_abi.tools._strategies.globals :: static
    r173 = 'BaseEquals'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L142 (error at <module>:182) else goto L57
L57:
    r175 = [r171]
    r176 = load_address r175
    r177 = PyObject_Vectorcall(r174, r176, 1, 0)
    dec_ref r174
    if is_error(r177) goto L142 (error at <module>:182) else goto L58
L58:
    r178 = faster_eth_abi.tools._strategies.globals :: static
    r179 = 'get_int_strategy'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L156 (error at <module>:183) else goto L59
L59:
    r181 = 'int'
    r182 = r169.register_strategy(r177, r180, r181)
    dec_ref r177
    dec_ref r180
    if is_error(r182) goto L142 (error at <module>:181) else goto L60
L60:
    r183 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r183) goto L61 else goto L63
L61:
    r184 = raise NameError('value for final name "strategy_registry" was not set')
    if not r184 goto L142 (error at <module>:186) else goto L62 :: bool
L62:
    unreachable
L63:
    r185 = 'address'
    r186 = faster_eth_abi.tools._strategies.globals :: static
    r187 = 'BaseEquals'
    r188 = CPyDict_GetItem(r186, r187)
    if is_error(r188) goto L142 (error at <module>:187) else goto L64
L64:
    r189 = box(bool, 0)
    r190 = [r185, r189]
    r191 = load_address r190
    r192 = ('with_sub',)
    r193 = PyObject_Vectorcall(r188, r191, 1, r192)
    dec_ref r188
    if is_error(r193) goto L142 (error at <module>:187) else goto L65
L65:
    r194 = faster_eth_abi.tools._strategies.address_strategy :: static
    if is_error(r194) goto L157 else goto L68
L66:
    r195 = raise NameError('value for final name "address_strategy" was not set')
    if not r195 goto L142 (error at <module>:188) else goto L67 :: bool
L67:
    unreachable
L68:
    r196 = 'address'
    r197 = r183.register_strategy(r193, r194, r196)
    dec_ref r193
    if is_error(r197) goto L142 (error at <module>:186) else goto L69
L69:
    r198 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r198) goto L70 else goto L72
L70:
    r199 = raise NameError('value for final name "strategy_registry" was not set')
    if not r199 goto L142 (error at <module>:191) else goto L71 :: bool
L71:
    unreachable
L72:
    r200 = 'bool'
    r201 = faster_eth_abi.tools._strategies.globals :: static
    r202 = 'BaseEquals'
    r203 = CPyDict_GetItem(r201, r202)
    if is_error(r203) goto L142 (error at <module>:192) else goto L73
L73:
    r204 = box(bool, 0)
    r205 = [r200, r204]
    r206 = load_address r205
    r207 = ('with_sub',)
    r208 = PyObject_Vectorcall(r203, r206, 1, r207)
    dec_ref r203
    if is_error(r208) goto L142 (error at <module>:192) else goto L74
L74:
    r209 = faster_eth_abi.tools._strategies.bool_strategy :: static
    if is_error(r209) goto L158 else goto L77
L75:
    r210 = raise NameError('value for final name "bool_strategy" was not set')
    if not r210 goto L142 (error at <module>:193) else goto L76 :: bool
L76:
    unreachable
L77:
    r211 = 'bool'
    r212 = r198.register_strategy(r208, r209, r211)
    dec_ref r208
    if is_error(r212) goto L142 (error at <module>:191) else goto L78
L78:
    r213 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r213) goto L79 else goto L81
L79:
    r214 = raise NameError('value for final name "strategy_registry" was not set')
    if not r214 goto L142 (error at <module>:196) else goto L80 :: bool
L80:
    unreachable
L81:
    r215 = 'ufixed'
    r216 = faster_eth_abi.tools._strategies.globals :: static
    r217 = 'BaseEquals'
    r218 = CPyDict_GetItem(r216, r217)
    if is_error(r218) goto L142 (error at <module>:197) else goto L82
L82:
    r219 = [r215]
    r220 = load_address r219
    r221 = PyObject_Vectorcall(r218, r220, 1, 0)
    dec_ref r218
    if is_error(r221) goto L142 (error at <module>:197) else goto L83
L83:
    r222 = faster_eth_abi.tools._strategies.globals :: static
    r223 = 'get_ufixed_strategy'
    r224 = CPyDict_GetItem(r222, r223)
    if is_error(r224) goto L159 (error at <module>:198) else goto L84
L84:
    r225 = 'ufixed'
    r226 = r213.register_strategy(r221, r224, r225)
    dec_ref r221
    dec_ref r224
    if is_error(r226) goto L142 (error at <module>:196) else goto L85
L85:
    r227 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r227) goto L86 else goto L88
L86:
    r228 = raise NameError('value for final name "strategy_registry" was not set')
    if not r228 goto L142 (error at <module>:201) else goto L87 :: bool
L87:
    unreachable
L88:
    r229 = 'fixed'
    r230 = faster_eth_abi.tools._strategies.globals :: static
    r231 = 'BaseEquals'
    r232 = CPyDict_GetItem(r230, r231)
    if is_error(r232) goto L142 (error at <module>:202) else goto L89
L89:
    r233 = [r229]
    r234 = load_address r233
    r235 = PyObject_Vectorcall(r232, r234, 1, 0)
    dec_ref r232
    if is_error(r235) goto L142 (error at <module>:202) else goto L90
L90:
    r236 = faster_eth_abi.tools._strategies.globals :: static
    r237 = 'get_fixed_strategy'
    r238 = CPyDict_GetItem(r236, r237)
    if is_error(r238) goto L160 (error at <module>:203) else goto L91
L91:
    r239 = 'fixed'
    r240 = r227.register_strategy(r235, r238, r239)
    dec_ref r235
    dec_ref r238
    if is_error(r240) goto L142 (error at <module>:201) else goto L92
L92:
    r241 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r241) goto L93 else goto L95
L93:
    r242 = raise NameError('value for final name "strategy_registry" was not set')
    if not r242 goto L142 (error at <module>:206) else goto L94 :: bool
L94:
    unreachable
L95:
    r243 = 'bytes'
    r244 = faster_eth_abi.tools._strategies.globals :: static
    r245 = 'BaseEquals'
    r246 = CPyDict_GetItem(r244, r245)
    if is_error(r246) goto L142 (error at <module>:207) else goto L96
L96:
    r247 = box(bool, 1)
    r248 = [r243, r247]
    r249 = load_address r248
    r250 = ('with_sub',)
    r251 = PyObject_Vectorcall(r246, r249, 1, r250)
    dec_ref r246
    if is_error(r251) goto L142 (error at <module>:207) else goto L97
L97:
    r252 = faster_eth_abi.tools._strategies.globals :: static
    r253 = 'get_bytes_strategy'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L161 (error at <module>:208) else goto L98
L98:
    r255 = 'bytes<M>'
    r256 = r241.register_strategy(r251, r254, r255)
    dec_ref r251
    dec_ref r254
    if is_error(r256) goto L142 (error at <module>:206) else goto L99
L99:
    r257 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r257) goto L100 else goto L102
L100:
    r258 = raise NameError('value for final name "strategy_registry" was not set')
    if not r258 goto L142 (error at <module>:211) else goto L101 :: bool
L101:
    unreachable
L102:
    r259 = 'bytes'
    r260 = faster_eth_abi.tools._strategies.globals :: static
    r261 = 'BaseEquals'
    r262 = CPyDict_GetItem(r260, r261)
    if is_error(r262) goto L142 (error at <module>:212) else goto L103
L103:
    r263 = box(bool, 0)
    r264 = [r259, r263]
    r265 = load_address r264
    r266 = ('with_sub',)
    r267 = PyObject_Vectorcall(r262, r265, 1, r266)
    dec_ref r262
    if is_error(r267) goto L142 (error at <module>:212) else goto L104
L104:
    r268 = faster_eth_abi.tools._strategies.bytes_strategy :: static
    if is_error(r268) goto L162 else goto L107
L105:
    r269 = raise NameError('value for final name "bytes_strategy" was not set')
    if not r269 goto L142 (error at <module>:213) else goto L106 :: bool
L106:
    unreachable
L107:
    r270 = 'bytes'
    r271 = r257.register_strategy(r267, r268, r270)
    dec_ref r267
    if is_error(r271) goto L142 (error at <module>:211) else goto L108
L108:
    r272 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r272) goto L109 else goto L111
L109:
    r273 = raise NameError('value for final name "strategy_registry" was not set')
    if not r273 goto L142 (error at <module>:216) else goto L110 :: bool
L110:
    unreachable
L111:
    r274 = 'function'
    r275 = faster_eth_abi.tools._strategies.globals :: static
    r276 = 'BaseEquals'
    r277 = CPyDict_GetItem(r275, r276)
    if is_error(r277) goto L142 (error at <module>:217) else goto L112
L112:
    r278 = box(bool, 0)
    r279 = [r274, r278]
    r280 = load_address r279
    r281 = ('with_sub',)
    r282 = PyObject_Vectorcall(r277, r280, 1, r281)
    dec_ref r277
    if is_error(r282) goto L142 (error at <module>:217) else goto L113
L113:
    r283 = faster_eth_abi.tools._strategies.globals :: static
    r284 = 'get_bytes_strategy'
    r285 = CPyDict_GetItem(r283, r284)
    if is_error(r285) goto L163 (error at <module>:218) else goto L114
L114:
    r286 = 'function'
    r287 = r272.register_strategy(r282, r285, r286)
    dec_ref r282
    dec_ref r285
    if is_error(r287) goto L142 (error at <module>:216) else goto L115
L115:
    r288 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r288) goto L116 else goto L118
L116:
    r289 = raise NameError('value for final name "strategy_registry" was not set')
    if not r289 goto L142 (error at <module>:221) else goto L117 :: bool
L117:
    unreachable
L118:
    r290 = 'string'
    r291 = faster_eth_abi.tools._strategies.globals :: static
    r292 = 'BaseEquals'
    r293 = CPyDict_GetItem(r291, r292)
    if is_error(r293) goto L142 (error at <module>:222) else goto L119
L119:
    r294 = box(bool, 0)
    r295 = [r290, r294]
    r296 = load_address r295
    r297 = ('with_sub',)
    r298 = PyObject_Vectorcall(r293, r296, 1, r297)
    dec_ref r293
    if is_error(r298) goto L142 (error at <module>:222) else goto L120
L120:
    r299 = faster_eth_abi.tools._strategies.string_strategy :: static
    if is_error(r299) goto L164 else goto L123
L121:
    r300 = raise NameError('value for final name "string_strategy" was not set')
    if not r300 goto L142 (error at <module>:223) else goto L122 :: bool
L122:
    unreachable
L123:
    r301 = 'string'
    r302 = r288.register_strategy(r298, r299, r301)
    dec_ref r298
    if is_error(r302) goto L142 (error at <module>:221) else goto L124
L124:
    r303 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r303) goto L125 else goto L127
L125:
    r304 = raise NameError('value for final name "strategy_registry" was not set')
    if not r304 goto L142 (error at <module>:226) else goto L126 :: bool
L126:
    unreachable
L127:
    r305 = faster_eth_abi.tools._strategies.globals :: static
    r306 = 'has_arrlist'
    r307 = CPyDict_GetItem(r305, r306)
    if is_error(r307) goto L142 (error at <module>:227) else goto L128
L128:
    r308 = faster_eth_abi.tools._strategies.globals :: static
    r309 = 'get_array_strategy'
    r310 = CPyDict_GetItem(r308, r309)
    if is_error(r310) goto L165 (error at <module>:228) else goto L129
L129:
    r311 = 'has_arrlist'
    r312 = r303.register_strategy(r307, r310, r311)
    dec_ref r307
    dec_ref r310
    if is_error(r312) goto L142 (error at <module>:226) else goto L130
L130:
    r313 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r313) goto L131 else goto L133
L131:
    r314 = raise NameError('value for final name "strategy_registry" was not set')
    if not r314 goto L142 (error at <module>:231) else goto L132 :: bool
L132:
    unreachable
L133:
    r315 = faster_eth_abi.tools._strategies.globals :: static
    r316 = 'is_base_tuple'
    r317 = CPyDict_GetItem(r315, r316)
    if is_error(r317) goto L142 (error at <module>:232) else goto L134
L134:
    r318 = faster_eth_abi.tools._strategies.globals :: static
    r319 = 'get_tuple_strategy'
    r320 = CPyDict_GetItem(r318, r319)
    if is_error(r320) goto L166 (error at <module>:233) else goto L135
L135:
    r321 = 'is_base_tuple'
    r322 = r313.register_strategy(r317, r320, r321)
    dec_ref r317
    dec_ref r320
    if is_error(r322) goto L142 (error at <module>:231) else goto L136
L136:
    r323 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r323) goto L137 else goto L139
L137:
    r324 = raise NameError('value for final name "strategy_registry" was not set')
    if not r324 goto L142 (error at <module>:237) else goto L138 :: bool
L138:
    unreachable
L139:
    r325 = 'get_strategy'
    r326 = CPyObject_GetAttr(r323, r325)
    if is_error(r326) goto L142 (error at <module>:237) else goto L140
L140:
    faster_eth_abi.tools._strategies.get_abi_strategy = r326 :: static
    r327 = faster_eth_abi.tools._strategies.globals :: static
    r328 = 'get_abi_strategy'
    r329 = CPyDict_SetItem(r327, r328, r326)
    dec_ref r326
    r330 = r329 >= 0 :: signed
    if not r330 goto L142 (error at <module>:237) else goto L141 :: bool
L141:
    return 1
L142:
    r331 = <error> :: None
    return r331
L143:
    dec_ref r36
    goto L142
L144:
    dec_ref r36
    dec_ref r39
    goto L142
L145:
    dec_ref r36
    dec_ref r41
    goto L142
L146:
    dec_ref r59
    goto L142
L147:
    dec_ref r59
    dec_ref r64
    goto L142
L148:
    dec_ref r81
    goto L142
L149:
    dec_ref r95
    goto L142
L150:
    dec_ref r102
    goto L142
L151:
    dec_ref r102
    dec_ref r105
    goto L142
L152:
    dec_ref r116
    goto L142
L153:
    dec_ref r127
    goto L142
L154:
    dec_ref r141
    goto L142
L155:
    dec_ref r163
    goto L142
L156:
    dec_ref r177
    goto L142
L157:
    dec_ref r193
    goto L66
L158:
    dec_ref r208
    goto L75
L159:
    dec_ref r221
    goto L142
L160:
    dec_ref r235
    goto L142
L161:
    dec_ref r251
    goto L142
L162:
    dec_ref r267
    goto L105
L163:
    dec_ref r282
    goto L142
L164:
    dec_ref r298
    goto L121
L165:
    dec_ref r307
    goto L142
L166:
    dec_ref r317
    goto L142

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def zpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad:2) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad:2) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad(value, 64)
    if is_error(r0) goto L2 (error at zpad32:6) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def zpad_right(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'ljust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad_right:10) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad_right:10) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32_right(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad_right(value, 64)
    if is_error(r0) goto L2 (error at zpad32_right:14) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def fpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\xff'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at fpad:18) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at fpad:18) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def fpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = fpad(value, 64)
    if is_error(r0) goto L2 (error at fpad32:22) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def encode_c(self, types, args):
    self, types, args :: object
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: None
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: list
    r9 :: object
    r10 :: tuple
    r11 :: dict
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16, r17 :: bytes
L0:
    r0 = 'types'
    r1 = validate_list_like_param(types, r0)
    if is_error(r1) goto L12 (error at encode_c:44) else goto L1
L1:
    r2 = 'args'
    r3 = validate_list_like_param(args, r2)
    if is_error(r3) goto L12 (error at encode_c:45) else goto L2
L2:
    r4 = '_registry'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L12 (error at encode_c:47) else goto L3
L3:
    r6 = 'get_tuple_encoder'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L12 (error at encode_c:47) else goto L4
L4:
    r8 = PyList_New(0)
    if is_error(r8) goto L13 (error at encode_c:47) else goto L5
L5:
    r9 = CPyList_Extend(r8, types)
    if is_error(r9) goto L14 (error at encode_c:47) else goto L15
L6:
    r10 = PyList_AsTuple(r8)
    dec_ref r8
    if is_error(r10) goto L13 (error at encode_c:47) else goto L7
L7:
    r11 = PyDict_New()
    if is_error(r11) goto L16 (error at encode_c:47) else goto L8
L8:
    r12 = PyObject_Call(r7, r10, r11)
    dec_ref r7
    dec_ref r10
    dec_ref r11
    if is_error(r12) goto L12 (error at encode_c:47) else goto L9
L9:
    r13 = [args]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L12 (error at encode_c:49) else goto L10
L10:
    r16 = cast(bytes, r15)
    if is_error(r16) goto L12 (error at encode_c:49) else goto L11
L11:
    return r16
L12:
    r17 = <error> :: bytes
    return r17
L13:
    dec_ref r7
    goto L12
L14:
    dec_ref r7
    dec_ref r8
    goto L12
L15:
    dec_ref r9
    goto L6
L16:
    dec_ref r7
    dec_ref r10
    goto L12

def decode_c(self, types, data, strict):
    self, types :: object
    data :: union[bytes, object]
    strict :: bool
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: None
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: list
    r9 :: object
    r10 :: str
    r11 :: tuple
    r12 :: object
    r13 :: dict
    r14 :: object
    r15 :: str
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22, r23 :: tuple
L0:
    if is_error(strict) goto L1 else goto L2
L1:
    strict = 1
L2:
    r0 = 'types'
    r1 = validate_list_like_param(types, r0)
    if is_error(r1) goto L15 (error at decode_c:76) else goto L3
L3:
    r2 = 'data'
    r3 = validate_bytes_param(data, r2)
    if is_error(r3) goto L15 (error at decode_c:77) else goto L4
L4:
    r4 = '_registry'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L15 (error at decode_c:79) else goto L5
L5:
    r6 = 'get_tuple_decoder'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L15 (error at decode_c:79) else goto L6
L6:
    r8 = PyList_New(0)
    if is_error(r8) goto L16 (error at decode_c:79) else goto L7
L7:
    r9 = CPyList_Extend(r8, types)
    if is_error(r9) goto L17 (error at decode_c:79) else goto L18
L8:
    r10 = 'strict'
    r11 = PyList_AsTuple(r8)
    dec_ref r8
    if is_error(r11) goto L16 (error at decode_c:79) else goto L9
L9:
    r12 = box(bool, strict)
    r13 = CPyDict_Build(1, r10, r12)
    if is_error(r13) goto L19 (error at decode_c:79) else goto L10
L10:
    r14 = PyObject_Call(r7, r11, r13)
    dec_ref r7
    dec_ref r11
    dec_ref r13
    if is_error(r14) goto L15 (error at decode_c:79) else goto L11
L11:
    r15 = 'stream_class'
    r16 = [self, data]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775810, 0)
    if is_error(r18) goto L20 (error at decode_c:80) else goto L12
L12:
    r19 = [r18]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r14, r20, 1, 0)
    dec_ref r14
    if is_error(r21) goto L21 (error at decode_c:82) else goto L13
L13:
    dec_ref r18
    r22 = cast(tuple, r21)
    if is_error(r22) goto L15 (error at decode_c:82) else goto L14
L14:
    return r22
L15:
    r23 = <error> :: tuple
    return r23
L16:
    dec_ref r7
    goto L15
L17:
    dec_ref r7
    dec_ref r8
    goto L15
L18:
    dec_ref r9
    goto L8
L19:
    dec_ref r7
    dec_ref r11
    goto L15
L20:
    dec_ref r14
    goto L15
L21:
    dec_ref r18
    goto L15

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Iterable', 'Tuple', 'cast')
    r6 = 'typing'
    r7 = faster_eth_abi._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('Decodable', 'TypeStr')
    r10 = 'eth_typing'
    r11 = faster_eth_abi._codec.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L8 (error at <module>:9) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('validate_bytes_param', 'validate_list_like_param')
    r14 = 'faster_eth_abi.utils.validation'
    r15 = faster_eth_abi._codec.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L8 (error at <module>:14) else goto L6
L6:
    faster_eth_abi.utils.validation = r16 :: module
    dec_ref r16
    if 0 goto L7 else goto L7 :: bool
L7:
    return 1
L8:
    r17 = <error> :: None
    return r17

def ceil32(x):
    x, r0 :: int
    r1 :: bit
    r2, r3, r4, r5, r6 :: int
L0:
    r0 = CPyTagged_Remainder(x, 64)
    if is_error(r0) goto L6 (error at ceil32:19) else goto L1
L1:
    r1 = r0 == 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L3 :: bool
L2:
    inc_ref x :: int
    r2 = x
    goto L5
L3:
    r3 = CPyTagged_Add(x, 64)
    r4 = CPyTagged_Remainder(x, 64)
    if is_error(r4) goto L7 (error at ceil32:19) else goto L4
L4:
    r5 = CPyTagged_Subtract(r3, r4)
    dec_ref r3 :: int
    dec_ref r4 :: int
    r2 = r5
L5:
    return r2
L6:
    r6 = <error> :: int
    return r6
L7:
    dec_ref r3 :: int
    goto L6

def compute_unsigned_integer_bounds(num_bits):
    num_bits :: int
    r0, r1, r2, r3, r4 :: object
    r5 :: tuple[int, object]
    r6 :: int
    r7, r8 :: tuple[int, int]
L0:
    r0 = object 2
    inc_ref num_bits :: int
    r1 = box(int, num_bits)
    r2 = CPyNumber_Power(r0, r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at compute_unsigned_integer_bounds:25) else goto L1
L1:
    r3 = object 1
    r4 = PyNumber_Subtract(r2, r3)
    dec_ref r2
    if is_error(r4) goto L4 (error at compute_unsigned_integer_bounds:25) else goto L2
L2:
    inc_ref r4
    r5 = (0, r4)
    dec_ref r5
    r6 = unbox(int, r4)
    dec_ref r4
    if is_error(r6) goto L4 (error at compute_unsigned_integer_bounds:23) else goto L3
L3:
    r7 = (0, r6)
    return r7
L4:
    r8 = <error> :: tuple[int, int]
    return r8

def compute_signed_integer_bounds(num_bits):
    num_bits, r0 :: int
    r1, r2, r3, r4, r5 :: object
    r6 :: int
    r7, r8, r9, r10, r11 :: object
    r12 :: tuple[object, object]
    r13, r14 :: int
    r15, r16 :: tuple[int, int]
L0:
    r0 = CPyTagged_Subtract(num_bits, 2)
    r1 = object 2
    r2 = box(int, r0)
    r3 = CPyNumber_Power(r1, r2)
    dec_ref r2
    if is_error(r3) goto L7 (error at compute_signed_integer_bounds:31) else goto L1
L1:
    r4 = object -1
    r5 = PyNumber_Multiply(r4, r3)
    dec_ref r3
    if is_error(r5) goto L7 (error at compute_signed_integer_bounds:31) else goto L2
L2:
    r6 = CPyTagged_Subtract(num_bits, 2)
    r7 = object 2
    r8 = box(int, r6)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L8 (error at compute_signed_integer_bounds:32) else goto L3
L3:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L8 (error at compute_signed_integer_bounds:32) else goto L4
L4:
    inc_ref r5
    inc_ref r11
    r12 = (r5, r11)
    dec_ref r12
    r13 = unbox(int, r5)
    dec_ref r5
    if is_error(r13) goto L9 (error at compute_signed_integer_bounds:30) else goto L5
L5:
    r14 = unbox(int, r11)
    dec_ref r11
    if is_error(r14) goto L10 (error at compute_signed_integer_bounds:30) else goto L6
L6:
    r15 = (r13, r14)
    return r15
L7:
    r16 = <error> :: tuple[int, int]
    return r16
L8:
    dec_ref r5
    goto L7
L9:
    dec_ref r11
    goto L7
L10:
    dec_ref r13 :: int
    goto L7

def compute_unsigned_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, upper :: object
    r1 :: tuple[int, int]
    r2 :: int
    r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: bool
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
    r27 :: bool
    r28 :: int
    r29, r30, r31 :: object
    r32, r33 :: tuple[object, object, object]
    r34, r35, r36 :: object
    r37 :: object[4]
    r38 :: object_ptr
    r39 :: object
    r40 :: i32
    r41 :: bit
    r42 :: bool
    r43 :: bit
    r44, r45, r46 :: tuple[object, object, object]
    r47 :: object
    r48 :: object[4]
    r49 :: object_ptr
    r50 :: object
    r51 :: bit
    r52 :: object
    r53, r54 :: bool
    r55, r56 :: tuple[object, object]
L0:
    r0 = <error> :: object
    upper = r0
    r1 = compute_unsigned_integer_bounds(num_bits)
    if is_error(r1) goto L48 (error at compute_unsigned_fixed_bounds:40) else goto L1
L1:
    r2 = r1[1]
    dec_ref r1
    r3 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r3) goto L49 else goto L4
L2:
    r4 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r4 goto L47 (error at compute_unsigned_fixed_bounds:42) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = decimal :: module
    r6 = 'localcontext'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L50 (error at compute_unsigned_fixed_bounds:42) else goto L5
L5:
    r8 = [r3]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L50 (error at compute_unsigned_fixed_bounds:42) else goto L6
L6:
    r11 = PyObject_Type(r10)
    r12 = '__exit__'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L51 (error at compute_unsigned_fixed_bounds:42) else goto L7
L7:
    r14 = '__enter__'
    r15 = CPyObject_GetAttr(r11, r14)
    dec_ref r11
    if is_error(r15) goto L52 (error at compute_unsigned_fixed_bounds:42) else goto L8
L8:
    r16 = [r10]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L52 (error at compute_unsigned_fixed_bounds:42) else goto L53
L9:
    r19 = 1
L10:
    r20 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r20) goto L54 else goto L13
L11:
    r21 = raise NameError('value for final name "Decimal" was not set')
    if not r21 goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L55 :: bool
L12:
    unreachable
L13:
    r22 = box(int, r2)
    r23 = [r22]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r20, r24, 1, 0)
    if is_error(r25) goto L56 (error at compute_unsigned_fixed_bounds:43) else goto L14
L14:
    dec_ref r22
    r26 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r26) goto L57 else goto L17
L15:
    r27 = raise NameError('value for final name "TEN" was not set')
    if not r27 goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L58 :: bool
L16:
    unreachable
L17:
    r28 = CPyTagged_Negate(frac_places)
    r29 = box(int, r28)
    r30 = CPyNumber_Power(r26, r29)
    dec_ref r29
    if is_error(r30) goto L59 (error at compute_unsigned_fixed_bounds:43) else goto L18
L18:
    r31 = PyNumber_Multiply(r25, r30)
    dec_ref r25
    dec_ref r30
    if is_error(r31) goto L20 (error at compute_unsigned_fixed_bounds:43) else goto L60
L19:
    upper = r31
    goto L28
L20:
    r32 = CPy_CatchError()
    r19 = 0
    r33 = CPy_GetExcInfo()
    r34 = r33[0]
    r35 = r33[1]
    r36 = r33[2]
    dec_ref r33
    r37 = [r10, r34, r35, r36]
    r38 = load_address r37
    r39 = PyObject_Vectorcall(r13, r38, 4, 0)
    if is_error(r39) goto L61 (error at compute_unsigned_fixed_bounds:42) else goto L21
L21:
    dec_ref r34
    dec_ref r35
    dec_ref r36
    r40 = PyObject_IsTrue(r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L26 (error at compute_unsigned_fixed_bounds:42) else goto L22 :: bool
L22:
    r42 = truncate r40: i32 to builtins.bool
    if r42 goto L25 else goto L23 :: bool
L23:
    CPy_Reraise()
    if not 0 goto L26 else goto L62 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    goto L28
L26:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    r43 = CPy_KeepPropagating()
    if not r43 goto L29 else goto L63 :: bool
L27:
    unreachable
L28:
    r44 = <error> :: tuple[object, object, object]
    r45 = r44
    goto L30
L29:
    r46 = CPy_CatchError()
    r45 = r46
L30:
    if r19 goto L31 else goto L64 :: bool
L31:
    r47 = load_address _Py_NoneStruct
    r48 = [r10, r47, r47, r47]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r13, r49, 4, 0)
    dec_ref r13
    if is_error(r50) goto L65 (error at compute_unsigned_fixed_bounds:42) else goto L66
L32:
    dec_ref r10
L33:
    if is_error(r45) goto L40 else goto L67
L34:
    CPy_Reraise()
    if not 0 goto L36 else goto L68 :: bool
L35:
    unreachable
L36:
    if is_error(r45) goto L38 else goto L37
L37:
    CPy_RestoreExcInfo(r45)
    xdec_ref r45
L38:
    r51 = CPy_KeepPropagating()
    if not r51 goto L47 else goto L39 :: bool
L39:
    unreachable
L40:
    r52 = faster_eth_abi.utils.numeric.ZERO :: static
    if is_error(r52) goto L69 else goto L43
L41:
    r53 = raise NameError('value for final name "ZERO" was not set')
    if not r53 goto L47 (error at compute_unsigned_fixed_bounds:45) else goto L42 :: bool
L42:
    unreachable
L43:
    if is_error(upper) goto L44 else goto L46
L44:
    r54 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r54 goto L47 (error at compute_unsigned_fixed_bounds:45) else goto L45 :: bool
L45:
    unreachable
L46:
    inc_ref r52
    r55 = (r52, upper)
    return r55
L47:
    r56 = <error> :: tuple[object, object]
    return r56
L48:
    xdec_ref upper
    goto L47
L49:
    xdec_ref upper
    dec_ref r2 :: int
    goto L2
L50:
    xdec_ref upper
    dec_ref r2 :: int
    goto L47
L51:
    xdec_ref upper
    dec_ref r2 :: int
    dec_ref r10
    dec_ref r11
    goto L47
L52:
    xdec_ref upper
    dec_ref r2 :: int
    dec_ref r10
    dec_ref r13
    goto L47
L53:
    dec_ref r18
    goto L9
L54:
    dec_ref r2 :: int
    goto L11
L55:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L12
L56:
    dec_ref r22
    goto L20
L57:
    dec_ref r25
    goto L15
L58:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L16
L59:
    dec_ref r25
    goto L20
L60:
    xdec_ref upper
    goto L19
L61:
    dec_ref r34
    dec_ref r35
    dec_ref r36
    goto L26
L62:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    dec_ref r32
    goto L24
L63:
    xdec_ref upper
    dec_ref r10
    dec_ref r13
    goto L27
L64:
    dec_ref r10
    dec_ref r13
    goto L33
L65:
    xdec_ref upper
    dec_ref r10
    goto L36
L66:
    dec_ref r50
    goto L32
L67:
    xdec_ref upper
    goto L34
L68:
    xdec_ref r45
    goto L35
L69:
    xdec_ref upper
    goto L41

def compute_signed_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, lower, r1, upper :: object
    r2 :: tuple[int, int]
    r3, r4, r5, r6 :: int
    r7 :: object
    r8 :: bool
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14, r15 :: object
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: bool
    r26 :: int
    r27, r28, r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34, r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42 :: object
    r43, r44 :: tuple[object, object, object]
    r45, r46, r47 :: object
    r48 :: object[4]
    r49 :: object_ptr
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: bool
    r54 :: bit
    r55, r56, r57 :: tuple[object, object, object]
    r58 :: object
    r59 :: object[4]
    r60 :: object_ptr
    r61 :: object
    r62 :: bit
    r63, r64 :: bool
    r65, r66 :: tuple[object, object]
L0:
    r0 = <error> :: object
    lower = r0
    r1 = <error> :: object
    upper = r1
    r2 = compute_signed_integer_bounds(num_bits)
    if is_error(r2) goto L53 (error at compute_signed_fixed_bounds:52) else goto L1
L1:
    r3 = borrow r2[0]
    r4 = borrow r2[1]
    r5 = unborrow r3
    r6 = unborrow r4
    r7 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r7) goto L54 else goto L4
L2:
    r8 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r8 goto L52 (error at compute_signed_fixed_bounds:54) else goto L3 :: bool
L3:
    unreachable
L4:
    r9 = decimal :: module
    r10 = 'localcontext'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L55 (error at compute_signed_fixed_bounds:54) else goto L5
L5:
    r12 = [r7]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 1, 0)
    dec_ref r11
    if is_error(r14) goto L55 (error at compute_signed_fixed_bounds:54) else goto L6
L6:
    r15 = PyObject_Type(r14)
    r16 = '__exit__'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L56 (error at compute_signed_fixed_bounds:54) else goto L7
L7:
    r18 = '__enter__'
    r19 = CPyObject_GetAttr(r15, r18)
    dec_ref r15
    if is_error(r19) goto L57 (error at compute_signed_fixed_bounds:54) else goto L8
L8:
    r20 = [r14]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L57 (error at compute_signed_fixed_bounds:54) else goto L58
L9:
    r23 = 1
L10:
    r24 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r24) goto L59 else goto L13
L11:
    r25 = raise NameError('value for final name "TEN" was not set')
    if not r25 goto L25 (error at compute_signed_fixed_bounds:55) else goto L60 :: bool
L12:
    unreachable
L13:
    r26 = CPyTagged_Negate(frac_places)
    r27 = box(int, r26)
    r28 = CPyNumber_Power(r24, r27)
    dec_ref r27
    if is_error(r28) goto L61 (error at compute_signed_fixed_bounds:55) else goto L14
L14:
    r29 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r29) goto L62 else goto L17
L15:
    r30 = raise NameError('value for final name "Decimal" was not set')
    if not r30 goto L25 (error at compute_signed_fixed_bounds:56) else goto L63 :: bool
L16:
    unreachable
L17:
    r31 = box(int, r5)
    r32 = [r31]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r29, r33, 1, 0)
    if is_error(r34) goto L64 (error at compute_signed_fixed_bounds:56) else goto L18
L18:
    dec_ref r31
    r35 = PyNumber_Multiply(r34, r28)
    dec_ref r34
    if is_error(r35) goto L65 (error at compute_signed_fixed_bounds:56) else goto L66
L19:
    lower = r35
    r36 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r36) goto L67 else goto L22
L20:
    r37 = raise NameError('value for final name "Decimal" was not set')
    if not r37 goto L25 (error at compute_signed_fixed_bounds:57) else goto L68 :: bool
L21:
    unreachable
L22:
    r38 = box(int, r6)
    r39 = [r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r36, r40, 1, 0)
    if is_error(r41) goto L69 (error at compute_signed_fixed_bounds:57) else goto L23
L23:
    dec_ref r38
    r42 = PyNumber_Multiply(r41, r28)
    dec_ref r41
    dec_ref r28
    if is_error(r42) goto L25 (error at compute_signed_fixed_bounds:57) else goto L70
L24:
    upper = r42
    goto L33
L25:
    r43 = CPy_CatchError()
    r23 = 0
    r44 = CPy_GetExcInfo()
    r45 = r44[0]
    r46 = r44[1]
    r47 = r44[2]
    dec_ref r44
    r48 = [r14, r45, r46, r47]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r17, r49, 4, 0)
    if is_error(r50) goto L71 (error at compute_signed_fixed_bounds:54) else goto L26
L26:
    dec_ref r45
    dec_ref r46
    dec_ref r47
    r51 = PyObject_IsTrue(r50)
    dec_ref r50
    r52 = r51 >= 0 :: signed
    if not r52 goto L31 (error at compute_signed_fixed_bounds:54) else goto L27 :: bool
L27:
    r53 = truncate r51: i32 to builtins.bool
    if r53 goto L30 else goto L28 :: bool
L28:
    CPy_Reraise()
    if not 0 goto L31 else goto L72 :: bool
L29:
    unreachable
L30:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    goto L33
L31:
    CPy_RestoreExcInfo(r43)
    dec_ref r43
    r54 = CPy_KeepPropagating()
    if not r54 goto L34 else goto L73 :: bool
L32:
    unreachable
L33:
    r55 = <error> :: tuple[object, object, object]
    r56 = r55
    goto L35
L34:
    r57 = CPy_CatchError()
    r56 = r57
L35:
    if r23 goto L36 else goto L74 :: bool
L36:
    r58 = load_address _Py_NoneStruct
    r59 = [r14, r58, r58, r58]
    r60 = load_address r59
    r61 = PyObject_Vectorcall(r17, r60, 4, 0)
    dec_ref r17
    if is_error(r61) goto L75 (error at compute_signed_fixed_bounds:54) else goto L76
L37:
    dec_ref r14
L38:
    if is_error(r56) goto L45 else goto L77
L39:
    CPy_Reraise()
    if not 0 goto L41 else goto L78 :: bool
L40:
    unreachable
L41:
    if is_error(r56) goto L43 else goto L42
L42:
    CPy_RestoreExcInfo(r56)
    xdec_ref r56
L43:
    r62 = CPy_KeepPropagating()
    if not r62 goto L52 else goto L44 :: bool
L44:
    unreachable
L45:
    if is_error(lower) goto L79 else goto L48
L46:
    r63 = raise UnboundLocalError('local variable "lower" referenced before assignment')
    if not r63 goto L52 (error at compute_signed_fixed_bounds:59) else goto L47 :: bool
L47:
    unreachable
L48:
    if is_error(upper) goto L80 else goto L51
L49:
    r64 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r64 goto L52 (error at compute_signed_fixed_bounds:59) else goto L50 :: bool
L50:
    unreachable
L51:
    r65 = (lower, upper)
    return r65
L52:
    r66 = <error> :: tuple[object, object]
    return r66
L53:
    xdec_ref lower
    xdec_ref upper
    goto L52
L54:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L2
L55:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L52
L56:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r14
    dec_ref r15
    goto L52
L57:
    xdec_ref lower
    xdec_ref upper
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r14
    dec_ref r17
    goto L52
L58:
    dec_ref r22
    goto L9
L59:
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L11
L60:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L12
L61:
    dec_ref r5 :: int
    dec_ref r6 :: int
    goto L25
L62:
    dec_ref r5 :: int
    dec_ref r6 :: int
    dec_ref r28
    goto L15
L63:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L16
L64:
    dec_ref r6 :: int
    dec_ref r28
    dec_ref r31
    goto L25
L65:
    dec_ref r6 :: int
    dec_ref r28
    goto L25
L66:
    xdec_ref lower
    goto L19
L67:
    dec_ref r6 :: int
    dec_ref r28
    goto L20
L68:
    dec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L21
L69:
    dec_ref r28
    dec_ref r38
    goto L25
L70:
    xdec_ref upper
    goto L24
L71:
    dec_ref r45
    dec_ref r46
    dec_ref r47
    goto L31
L72:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    dec_ref r43
    goto L29
L73:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    dec_ref r17
    goto L32
L74:
    dec_ref r14
    dec_ref r17
    goto L38
L75:
    xdec_ref lower
    xdec_ref upper
    dec_ref r14
    goto L41
L76:
    dec_ref r61
    goto L37
L77:
    xdec_ref lower
    xdec_ref upper
    goto L39
L78:
    xdec_ref r56
    goto L40
L79:
    xdec_ref upper
    goto L46
L80:
    xdec_ref lower
    goto L49

def f_scale_places_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def f_scale_places_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: faster_eth_abi.utils.numeric.f_scale_places_obj
    x :: object
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: bool
    r18, r19, r20 :: object
    r21, r22 :: tuple[object, object, object]
    r23, r24, r25 :: object
    r26 :: object[4]
    r27 :: object_ptr
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: bool
    r32 :: bit
    r33 :: object
    r34, r35 :: tuple[object, object, object]
    r36 :: object
    r37 :: tuple[object, object, object]
    r38 :: object
    r39 :: object[4]
    r40 :: object_ptr
    r41 :: object
    r42 :: bit
    r43, r44 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L37 (error at f:76) else goto L1
L1:
    r1 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r1) goto L38 else goto L4
L2:
    r2 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r2 goto L37 (error at f:77) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = decimal :: module
    r4 = 'localcontext'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L39 (error at f:77) else goto L5
L5:
    r6 = [r1]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L39 (error at f:77) else goto L6
L6:
    r9 = PyObject_Type(r8)
    r10 = '__exit__'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L40 (error at f:77) else goto L7
L7:
    r12 = '__enter__'
    r13 = CPyObject_GetAttr(r9, r12)
    dec_ref r9
    if is_error(r13) goto L41 (error at f:77) else goto L8
L8:
    r14 = [r8]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L41 (error at f:77) else goto L42
L9:
    r17 = 1
L10:
    r18 = r0.scaling_factor
    dec_ref r0
    if is_error(r18) goto L13 (error at f:78) else goto L11
L11:
    r19 = PyNumber_Multiply(x, r18)
    dec_ref r18
    if is_error(r19) goto L13 (error at f:78) else goto L12
L12:
    r20 = r19
    goto L22
L13:
    r21 = CPy_CatchError()
    r17 = 0
    r22 = CPy_GetExcInfo()
    r23 = r22[0]
    r24 = r22[1]
    r25 = r22[2]
    dec_ref r22
    r26 = [r8, r23, r24, r25]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r11, r27, 4, 0)
    if is_error(r28) goto L43 (error at f:77) else goto L14
L14:
    dec_ref r23
    dec_ref r24
    dec_ref r25
    r29 = PyObject_IsTrue(r28)
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L19 (error at f:77) else goto L15 :: bool
L15:
    r31 = truncate r29: i32 to builtins.bool
    if r31 goto L18 else goto L16 :: bool
L16:
    CPy_Reraise()
    if not 0 goto L19 else goto L44 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    goto L21
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r32 = CPy_KeepPropagating()
    if not r32 goto L23 else goto L45 :: bool
L20:
    unreachable
L21:
    r33 = <error> :: object
    r20 = r33
L22:
    r34 = <error> :: tuple[object, object, object]
    r35 = r34
    goto L24
L23:
    r36 = <error> :: object
    r20 = r36
    r37 = CPy_CatchError()
    r35 = r37
L24:
    if r17 goto L25 else goto L46 :: bool
L25:
    r38 = load_address _Py_NoneStruct
    r39 = [r8, r38, r38, r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r11, r40, 4, 0)
    dec_ref r11
    if is_error(r41) goto L47 (error at f:77) else goto L48
L26:
    dec_ref r8
L27:
    if is_error(r35) goto L30 else goto L49
L28:
    CPy_Reraise()
    if not 0 goto L32 else goto L50 :: bool
L29:
    unreachable
L30:
    if is_error(r20) goto L36 else goto L31
L31:
    return r20
L32:
    if is_error(r35) goto L34 else goto L33
L33:
    CPy_RestoreExcInfo(r35)
    xdec_ref r35
L34:
    r42 = CPy_KeepPropagating()
    if not r42 goto L37 else goto L35 :: bool
L35:
    unreachable
L36:
    r43 = box(None, 1)
    inc_ref r43
    return r43
L37:
    r44 = <error> :: object
    return r44
L38:
    dec_ref r0
    goto L2
L39:
    dec_ref r0
    goto L37
L40:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L37
L41:
    dec_ref r0
    dec_ref r8
    dec_ref r11
    goto L37
L42:
    dec_ref r16
    goto L9
L43:
    dec_ref r23
    dec_ref r24
    dec_ref r25
    goto L19
L44:
    dec_ref r8
    dec_ref r11
    dec_ref r21
    goto L17
L45:
    dec_ref r8
    dec_ref r11
    goto L20
L46:
    dec_ref r8
    dec_ref r11
    goto L27
L47:
    dec_ref r8
    xdec_ref r20
    goto L32
L48:
    dec_ref r41
    goto L26
L49:
    xdec_ref r20
    goto L28
L50:
    xdec_ref r35
    goto L29

def scale_places(places):
    places :: int
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1, r2 :: object
    r3 :: i32
    r4 :: bit
    r5 :: bool
    r6, r7, r8 :: str
    r9 :: object
    r10, r11 :: str
    r12 :: object[3]
    r13 :: object_ptr
    r14 :: object
    r15, r16 :: str
    r17, r18 :: object
    r19, r20 :: str
    r21 :: object[3]
    r22 :: object_ptr
    r23 :: object
    r24 :: str
    r25 :: list
    r26, r27, r28, r29, r30, r31 :: ptr
    r32 :: str
    r33 :: object
    r34 :: str
    r35 :: object
    r36 :: object[1]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: bool
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: object[1]
    r45 :: object_ptr
    r46, r47 :: object
    r48 :: str
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55 :: bool
    r56 :: object
    r57 :: bool
    r58 :: int
    r59, r60 :: object
    r61 :: bool
    r62, r63 :: tuple[object, object, object]
    r64, r65, r66 :: object
    r67 :: object[4]
    r68 :: object_ptr
    r69 :: object
    r70 :: i32
    r71 :: bit
    r72 :: bool
    r73 :: bit
    r74, r75, r76 :: tuple[object, object, object]
    r77 :: object
    r78 :: object[4]
    r79 :: object_ptr
    r80 :: object
    r81 :: bit
    r82 :: faster_eth_abi.utils.numeric.f_scale_places_obj
    r83 :: bool
    f :: object
    r84 :: native_int
    r85 :: bit
    r86 :: native_int
    r87, r88, r89 :: bit
    r90, r91, r92, r93, r94 :: str
    r95 :: int
    r96, r97, places_repr, r98, r99, r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: str
    r104 :: i32
    r105 :: bit
    r106 :: object
L0:
    r0 = scale_places_env()
    if is_error(r0) goto L61 (error at scale_places:62) else goto L1
L1:
    inc_ref places :: int
    r1 = box(int, places)
    r2 = load_address PyLong_Type
    r3 = PyObject_IsInstance(r1, r2)
    dec_ref r1
    r4 = r3 >= 0 :: signed
    if not r4 goto L62 (error at scale_places:67) else goto L2 :: bool
L2:
    r5 = truncate r3: i32 to builtins.bool
    if r5 goto L11 else goto L63 :: bool
L3:
    r6 = ''
    r7 = 'Argument `places` must be int.  Got value '
    r8 = '{:{}}'
    inc_ref places :: int
    r9 = box(int, places)
    r10 = ''
    r11 = 'format'
    r12 = [r8, r9, r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775811, 0)
    if is_error(r14) goto L64 (error at scale_places:69) else goto L4
L4:
    dec_ref r9
    r15 = ' of type '
    r16 = '{:{}}'
    inc_ref places :: int
    r17 = box(int, places)
    r18 = PyObject_Type(r17)
    dec_ref r17
    r19 = ''
    r20 = 'format'
    r21 = [r16, r18, r19]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775811, 0)
    if is_error(r23) goto L65 (error at scale_places:70) else goto L5
L5:
    dec_ref r18
    r24 = '.'
    r25 = PyList_New(5)
    if is_error(r25) goto L66 (error at scale_places:69) else goto L6
L6:
    r26 = get_element_ptr r25 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    inc_ref r7
    set_mem r27, r7 :: builtins.object*
    r28 = r27 + 8
    set_mem r28, r14 :: builtins.object*
    inc_ref r15
    r29 = r27 + 16
    set_mem r29, r15 :: builtins.object*
    r30 = r27 + 24
    set_mem r30, r23 :: builtins.object*
    inc_ref r24
    r31 = r27 + 32
    set_mem r31, r24 :: builtins.object*
    r32 = PyUnicode_Join(r6, r25)
    dec_ref r25
    if is_error(r32) goto L61 (error at scale_places:69) else goto L7
L7:
    r33 = builtins :: module
    r34 = 'ValueError'
    r35 = CPyObject_GetAttr(r33, r34)
    if is_error(r35) goto L67 (error at scale_places:68) else goto L8
L8:
    r36 = [r32]
    r37 = load_address r36
    r38 = PyObject_Vectorcall(r35, r37, 1, 0)
    dec_ref r35
    if is_error(r38) goto L67 (error at scale_places:68) else goto L9
L9:
    dec_ref r32
    CPy_Raise(r38)
    dec_ref r38
    if not 0 goto L61 (error at scale_places:68) else goto L10 :: bool
L10:
    unreachable
L11:
    r39 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r39) goto L68 else goto L14
L12:
    r40 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r40 goto L61 (error at scale_places:73) else goto L13 :: bool
L13:
    unreachable
L14:
    r41 = decimal :: module
    r42 = 'localcontext'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L62 (error at scale_places:73) else goto L15
L15:
    r44 = [r39]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r43, r45, 1, 0)
    dec_ref r43
    if is_error(r46) goto L62 (error at scale_places:73) else goto L16
L16:
    r47 = PyObject_Type(r46)
    r48 = '__exit__'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L69 (error at scale_places:73) else goto L17
L17:
    r50 = '__enter__'
    r51 = CPyObject_GetAttr(r47, r50)
    dec_ref r47
    if is_error(r51) goto L70 (error at scale_places:73) else goto L18
L18:
    r52 = [r46]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r51, r53, 1, 0)
    dec_ref r51
    if is_error(r54) goto L70 (error at scale_places:73) else goto L71
L19:
    r55 = 1
L20:
    r56 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r56) goto L21 else goto L23
L21:
    r57 = raise NameError('value for final name "TEN" was not set')
    if not r57 goto L25 (error at scale_places:74) else goto L72 :: bool
L22:
    unreachable
L23:
    r58 = CPyTagged_Negate(places)
    r59 = box(int, r58)
    r60 = CPyNumber_Power(r56, r59)
    dec_ref r59
    if is_error(r60) goto L25 (error at scale_places:74) else goto L24
L24:
    r0.scaling_factor = r60; r61 = is_error
    if not r61 goto L25 (error at scale_places:74) else goto L33 :: bool
L25:
    r62 = CPy_CatchError()
    r55 = 0
    r63 = CPy_GetExcInfo()
    r64 = r63[0]
    r65 = r63[1]
    r66 = r63[2]
    dec_ref r63
    r67 = [r46, r64, r65, r66]
    r68 = load_address r67
    r69 = PyObject_Vectorcall(r49, r68, 4, 0)
    if is_error(r69) goto L73 (error at scale_places:73) else goto L26
L26:
    dec_ref r64
    dec_ref r65
    dec_ref r66
    r70 = PyObject_IsTrue(r69)
    dec_ref r69
    r71 = r70 >= 0 :: signed
    if not r71 goto L31 (error at scale_places:73) else goto L27 :: bool
L27:
    r72 = truncate r70: i32 to builtins.bool
    if r72 goto L30 else goto L28 :: bool
L28:
    CPy_Reraise()
    if not 0 goto L31 else goto L74 :: bool
L29:
    unreachable
L30:
    CPy_RestoreExcInfo(r62)
    dec_ref r62
    goto L33
L31:
    CPy_RestoreExcInfo(r62)
    dec_ref r62
    r73 = CPy_KeepPropagating()
    if not r73 goto L34 else goto L75 :: bool
L32:
    unreachable
L33:
    r74 = <error> :: tuple[object, object, object]
    r75 = r74
    goto L35
L34:
    r76 = CPy_CatchError()
    r75 = r76
L35:
    if r55 goto L36 else goto L76 :: bool
L36:
    r77 = load_address _Py_NoneStruct
    r78 = [r46, r77, r77, r77]
    r79 = load_address r78
    r80 = PyObject_Vectorcall(r49, r79, 4, 0)
    dec_ref r49
    if is_error(r80) goto L77 (error at scale_places:73) else goto L78
L37:
    dec_ref r46
L38:
    if is_error(r75) goto L45 else goto L79
L39:
    CPy_Reraise()
    if not 0 goto L41 else goto L80 :: bool
L40:
    unreachable
L41:
    if is_error(r75) goto L43 else goto L42
L42:
    CPy_RestoreExcInfo(r75)
    xdec_ref r75
L43:
    r81 = CPy_KeepPropagating()
    if not r81 goto L61 else goto L44 :: bool
L44:
    unreachable
L45:
    r82 = f_scale_places_obj()
    if is_error(r82) goto L62 (error at scale_places:76) else goto L46
L46:
    r82.__mypyc_env__ = r0; r83 = is_error
    if not r83 goto L81 (error at scale_places:76) else goto L47 :: bool
L47:
    f = r82
    r84 = places & 1
    r85 = r84 != 0
    if r85 goto L49 else goto L48 :: bool
L48:
    r86 = 0 & 1
    r87 = r86 != 0
    if r87 goto L49 else goto L50 :: bool
L49:
    r88 = CPyTagged_IsLt_(0, places)
    if r88 goto L51 else goto L54 :: bool
L50:
    r89 = places > 0 :: signed
    if r89 goto L51 else goto L54 :: bool
L51:
    r90 = 'Eneg'
    r91 = CPyTagged_Str(places)
    if is_error(r91) goto L82 (error at scale_places:80) else goto L52
L52:
    r92 = CPyStr_Build(2, r90, r91)
    dec_ref r91
    if is_error(r92) goto L82 (error at scale_places:80) else goto L53
L53:
    r93 = r92
    goto L57
L54:
    r94 = 'Epos'
    r95 = CPyTagged_Negate(places)
    r96 = CPyTagged_Str(r95)
    dec_ref r95 :: int
    if is_error(r96) goto L82 (error at scale_places:80) else goto L55
L55:
    r97 = CPyStr_Build(2, r94, r96)
    dec_ref r96
    if is_error(r97) goto L82 (error at scale_places:80) else goto L56
L56:
    r93 = r97
L57:
    places_repr = r93
    r98 = 'scale_by_'
    r99 = CPyStr_Build(2, r98, places_repr)
    dec_ref places_repr
    if is_error(r99) goto L82 (error at scale_places:81) else goto L58
L58:
    r100 = '__name__'
    r101 = PyObject_SetAttr(f, r100, r99)
    r102 = r101 >= 0 :: signed
    if not r102 goto L83 (error at scale_places:83) else goto L59 :: bool
L59:
    r103 = '__qualname__'
    r104 = PyObject_SetAttr(f, r103, r99)
    dec_ref r99
    r105 = r104 >= 0 :: signed
    if not r105 goto L82 (error at scale_places:84) else goto L60 :: bool
L60:
    return f
L61:
    r106 = <error> :: object
    return r106
L62:
    dec_ref r0
    goto L61
L63:
    dec_ref r0
    goto L3
L64:
    dec_ref r9
    goto L61
L65:
    dec_ref r14
    dec_ref r18
    goto L61
L66:
    dec_ref r14
    dec_ref r23
    goto L61
L67:
    dec_ref r32
    goto L61
L68:
    dec_ref r0
    goto L12
L69:
    dec_ref r0
    dec_ref r46
    dec_ref r47
    goto L61
L70:
    dec_ref r0
    dec_ref r46
    dec_ref r49
    goto L61
L71:
    dec_ref r54
    goto L19
L72:
    dec_ref r0
    dec_ref r46
    dec_ref r49
    goto L22
L73:
    dec_ref r64
    dec_ref r65
    dec_ref r66
    goto L31
L74:
    dec_ref r0
    dec_ref r46
    dec_ref r49
    dec_ref r62
    goto L29
L75:
    dec_ref r0
    dec_ref r46
    dec_ref r49
    goto L32
L76:
    dec_ref r46
    dec_ref r49
    goto L38
L77:
    dec_ref r0
    dec_ref r46
    goto L41
L78:
    dec_ref r80
    goto L37
L79:
    dec_ref r0
    goto L39
L80:
    xdec_ref r75
    goto L40
L81:
    dec_ref r82
    goto L61
L82:
    dec_ref f
    goto L61
L83:
    dec_ref f
    dec_ref r99
    goto L61

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: str
    r26, r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37 :: str
    r38, r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: i32
    r46 :: bit
    r47 :: object
    r48 :: str
    r49, r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L18 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = faster_eth_abi.utils.numeric.globals :: static
    r12 = 'faster_eth_abi/utils/numeric.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L18 else goto L4 :: bool
L4:
    r15 = ('Callable', 'Final', 'Tuple')
    r16 = 'typing'
    r17 = faster_eth_abi.utils.numeric.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L18 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = faster_eth_abi.utils.numeric.globals :: static
    r20 = 'ABI_DECIMAL_PREC'
    r21 = object 999
    r22 = CPyDict_SetItem(r19, r20, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L18 (error at <module>:8) else goto L6 :: bool
L6:
    r24 = decimal :: module
    r25 = 'Context'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L18 (error at <module>:10) else goto L7
L7:
    r27 = object 999
    r28 = [r27]
    r29 = load_address r28
    r30 = ('prec',)
    r31 = PyObject_Vectorcall(r26, r29, 0, r30)
    dec_ref r26
    if is_error(r31) goto L18 (error at <module>:10) else goto L8
L8:
    faster_eth_abi.utils.numeric.abi_decimal_context = r31 :: static
    r32 = faster_eth_abi.utils.numeric.globals :: static
    r33 = 'abi_decimal_context'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L18 (error at <module>:10) else goto L9 :: bool
L9:
    r36 = decimal :: module
    r37 = 'Decimal'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L18 (error at <module>:12) else goto L10
L10:
    r39 = object 0
    r40 = [r39]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r38, r41, 1, 0)
    dec_ref r38
    if is_error(r42) goto L18 (error at <module>:12) else goto L11
L11:
    faster_eth_abi.utils.numeric.ZERO = r42 :: static
    r43 = faster_eth_abi.utils.numeric.globals :: static
    r44 = 'ZERO'
    r45 = CPyDict_SetItem(r43, r44, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L18 (error at <module>:12) else goto L12 :: bool
L12:
    r47 = decimal :: module
    r48 = 'Decimal'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L18 (error at <module>:13) else goto L13
L13:
    r50 = object 10
    r51 = [r50]
    r52 = load_address r51
    r53 = PyObject_Vectorcall(r49, r52, 1, 0)
    dec_ref r49
    if is_error(r53) goto L18 (error at <module>:13) else goto L14
L14:
    faster_eth_abi.utils.numeric.TEN = r53 :: static
    r54 = faster_eth_abi.utils.numeric.globals :: static
    r55 = 'TEN'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L18 (error at <module>:13) else goto L15 :: bool
L15:
    r58 = decimal :: module
    r59 = 'Decimal'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L18 (error at <module>:15) else goto L16
L16:
    faster_eth_abi.utils.numeric.Decimal = r60 :: static
    r61 = faster_eth_abi.utils.numeric.globals :: static
    r62 = 'Decimal'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L18 (error at <module>:15) else goto L17 :: bool
L17:
    return 1
L18:
    r65 = <error> :: None
    return r65

def new_from_type_str_parse_type_str_decorator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_type_str_decorator_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: str
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15, type_str_repr :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19, r20, r21 :: bit
    r22, r23, r24, r25 :: str
    r26 :: object[3]
    r27 :: object_ptr
    r28 :: object
    r29, r30, r31, r32, r33 :: str
    r34 :: object[3]
    r35 :: object_ptr
    r36 :: object
    r37, r38 :: str
    r39 :: list
    r40, r41, r42, r43, r44 :: ptr
    r45 :: str
    r46 :: union[str, None]
    r47 :: object
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: i32
    r53 :: bit
    r54 :: bool
    r55 :: str
    r56 :: object
    r57, r58, r59, r60 :: str
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: str
    r68 :: object
    r69 :: str
    r70 :: union[str, None]
    r71 :: str
    r72 :: i32
    r73 :: bit
    r74 :: object
    r75, r76, r77 :: bit
    r78 :: str
    r79 :: object
    r80 :: str
    r81 :: union[str, None]
    r82, r83, r84, r85, r86, r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: object[1]
    r92 :: object_ptr
    r93 :: object
    r94 :: bool
    r95 :: str
    r96, r97 :: object
    r98 :: bit
    r99 :: str
    r100 :: object
    r101, r102, r103, r104, r105 :: str
    r106 :: object
    r107 :: str
    r108 :: object
    r109 :: object[1]
    r110 :: object_ptr
    r111 :: object
    r112 :: bool
    r113 :: str
    r114, r115 :: object
    r116 :: bit
    r117 :: str
    r118 :: object
    r119, r120, r121, r122, r123 :: str
    r124 :: object
    r125 :: str
    r126 :: object
    r127 :: object[1]
    r128 :: object_ptr
    r129 :: object
    r130 :: str
    r131 :: object[1]
    r132 :: object_ptr
    r133, r134 :: object
    r135 :: object[3]
    r136 :: object_ptr
    r137, r138 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L74 (error at new_from_type_str:48) else goto L1
L1:
    r1 = r0.__mypyc_env__
    if is_error(r1) goto L75 (error at new_from_type_str:48) else goto L2
L2:
    r2 = faster_eth_abi.from_type_str.globals :: static
    r3 = 'normalize'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L76 (error at new_from_type_str:49) else goto L3
L3:
    r5 = [type_str]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L76 (error at new_from_type_str:49) else goto L4
L4:
    r8 = cast(str, r7)
    if is_error(r8) goto L76 (error at new_from_type_str:49) else goto L5
L5:
    r9 = faster_eth_abi.from_type_str.globals :: static
    r10 = 'parse'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L77 (error at new_from_type_str:50) else goto L6
L6:
    r12 = [r8]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 1, 0)
    dec_ref r11
    if is_error(r14) goto L77 (error at new_from_type_str:50) else goto L7
L7:
    r15 = PyObject_Repr(type_str)
    if is_error(r15) goto L78 (error at new_from_type_str:52) else goto L8
L8:
    type_str_repr = r15
    r16 = PyUnicode_Compare(type_str, r8)
    r17 = r16 == -1
    if r17 goto L9 else goto L11 :: bool
L9:
    r18 = PyErr_Occurred()
    r19 = r18 != 0
    if r19 goto L10 else goto L11 :: bool
L10:
    r20 = CPy_KeepPropagating()
    if not r20 goto L79 (error at new_from_type_str:53) else goto L11 :: bool
L11:
    r21 = r16 != 0
    if r21 goto L12 else goto L80 :: bool
L12:
    r22 = ''
    r23 = '{:{}}'
    r24 = ''
    r25 = 'format'
    r26 = [r23, type_str_repr, r24]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r25, r27, 9223372036854775811, 0)
    if is_error(r28) goto L79 (error at new_from_type_str:55) else goto L13
L13:
    dec_ref type_str_repr
    r29 = cast(str, r28)
    if is_error(r29) goto L78 (error at new_from_type_str:55) else goto L14
L14:
    r30 = ' (normalized to '
    r31 = '{!r:{}}'
    r32 = ''
    r33 = 'format'
    r34 = [r31, r8, r32]
    r35 = load_address r34
    r36 = PyObject_VectorcallMethod(r33, r35, 9223372036854775811, 0)
    if is_error(r36) goto L81 (error at new_from_type_str:55) else goto L15
L15:
    dec_ref r8
    r37 = cast(str, r36)
    if is_error(r37) goto L82 (error at new_from_type_str:55) else goto L16
L16:
    r38 = ')'
    r39 = PyList_New(4)
    if is_error(r39) goto L83 (error at new_from_type_str:55) else goto L17
L17:
    r40 = get_element_ptr r39 ob_item :: PyListObject
    r41 = load_mem r40 :: ptr*
    set_mem r41, r29 :: builtins.object*
    inc_ref r30
    r42 = r41 + 8
    set_mem r42, r30 :: builtins.object*
    r43 = r41 + 16
    set_mem r43, r37 :: builtins.object*
    inc_ref r38
    r44 = r41 + 24
    set_mem r44, r38 :: builtins.object*
    r45 = PyUnicode_Join(r22, r39)
    dec_ref r39
    if is_error(r45) goto L84 (error at new_from_type_str:55) else goto L18
L18:
    type_str_repr = r45
L19:
    r46 = r1.expected_base
    if is_error(r46) goto L85 (error at new_from_type_str:58) else goto L20
L20:
    r47 = load_address _Py_NoneStruct
    r48 = r46 != r47
    dec_ref r46
    if r48 goto L21 else goto L48 :: bool
L21:
    r49 = faster_eth_abi.from_type_str.globals :: static
    r50 = 'BasicType'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L85 (error at new_from_type_str:59) else goto L22
L22:
    r52 = PyObject_IsInstance(r14, r51)
    dec_ref r51
    r53 = r52 >= 0 :: signed
    if not r53 goto L85 (error at new_from_type_str:59) else goto L23 :: bool
L23:
    r54 = truncate r52: i32 to builtins.bool
    if r54 goto L31 else goto L86 :: bool
L24:
    r55 = '__name__'
    r56 = CPyObject_GetAttr(cls, r55)
    if is_error(r56) goto L87 (error at new_from_type_str:62) else goto L25
L25:
    r57 = cast(str, r56)
    if is_error(r57) goto L87 (error at new_from_type_str:62) else goto L26
L26:
    r58 = 'Cannot create '
    r59 = ' for non-basic type '
    r60 = CPyStr_Build(4, r58, r57, r59, type_str_repr)
    dec_ref r57
    dec_ref type_str_repr
    if is_error(r60) goto L74 (error at new_from_type_str:61) else goto L27
L27:
    r61 = builtins :: module
    r62 = 'ValueError'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L88 (error at new_from_type_str:60) else goto L28
L28:
    r64 = [r60]
    r65 = load_address r64
    r66 = PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L88 (error at new_from_type_str:60) else goto L29
L29:
    dec_ref r60
    CPy_Raise(r66)
    dec_ref r66
    if not 0 goto L74 (error at new_from_type_str:60) else goto L30 :: bool
L30:
    unreachable
L31:
    r67 = 'base'
    r68 = CPyObject_GetAttr(r14, r67)
    if is_error(r68) goto L85 (error at new_from_type_str:66) else goto L32
L32:
    r69 = cast(str, r68)
    if is_error(r69) goto L85 (error at new_from_type_str:66) else goto L33
L33:
    r70 = r1.expected_base
    if is_error(r70) goto L89 (error at new_from_type_str:66) else goto L34
L34:
    r71 = cast(str, r70)
    if is_error(r71) goto L89 (error at new_from_type_str:66) else goto L35
L35:
    r72 = PyUnicode_Compare(r69, r71)
    dec_ref r69
    dec_ref r71
    r73 = r72 == -1
    if r73 goto L36 else goto L38 :: bool
L36:
    r74 = PyErr_Occurred()
    r75 = r74 != 0
    if r75 goto L37 else goto L38 :: bool
L37:
    r76 = CPy_KeepPropagating()
    if not r76 goto L85 (error at new_from_type_str:66) else goto L38 :: bool
L38:
    r77 = r72 != 0
    if r77 goto L90 else goto L48 :: bool
L39:
    r78 = '__name__'
    r79 = CPyObject_GetAttr(cls, r78)
    if is_error(r79) goto L91 (error at new_from_type_str:70) else goto L40
L40:
    r80 = cast(str, r79)
    if is_error(r80) goto L91 (error at new_from_type_str:70) else goto L41
L41:
    r81 = r1.expected_base
    dec_ref r1
    if is_error(r81) goto L92 (error at new_from_type_str:72) else goto L42
L42:
    r82 = cast(str, r81)
    if is_error(r82) goto L92 (error at new_from_type_str:72) else goto L43
L43:
    r83 = 'Cannot create '
    r84 = ' for type '
    r85 = ": expected type with base '"
    r86 = "'"
    r87 = CPyStr_Build(7, r83, r80, r84, type_str_repr, r85, r82, r86)
    dec_ref r80
    dec_ref type_str_repr
    dec_ref r82
    if is_error(r87) goto L74 (error at new_from_type_str:68) else goto L44
L44:
    r88 = builtins :: module
    r89 = 'ValueError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L93 (error at new_from_type_str:67) else goto L45
L45:
    r91 = [r87]
    r92 = load_address r91
    r93 = PyObject_Vectorcall(r90, r92, 1, 0)
    dec_ref r90
    if is_error(r93) goto L93 (error at new_from_type_str:67) else goto L46
L46:
    dec_ref r87
    CPy_Raise(r93)
    dec_ref r93
    if not 0 goto L74 (error at new_from_type_str:67) else goto L47 :: bool
L47:
    unreachable
L48:
    r94 = r1.with_arrlist
    if is_error(r94) goto L85 (error at new_from_type_str:76) else goto L49
L49:
    if r94 goto L59 else goto L50 :: bool
L50:
    r95 = 'arrlist'
    r96 = CPyObject_GetAttr(r14, r95)
    if is_error(r96) goto L85 (error at new_from_type_str:76) else goto L51
L51:
    r97 = load_address _Py_NoneStruct
    r98 = r96 != r97
    dec_ref r96
    if r98 goto L94 else goto L59 :: bool
L52:
    r99 = '__name__'
    r100 = CPyObject_GetAttr(cls, r99)
    if is_error(r100) goto L87 (error at new_from_type_str:80) else goto L53
L53:
    r101 = cast(str, r100)
    if is_error(r101) goto L87 (error at new_from_type_str:80) else goto L54
L54:
    r102 = 'Cannot create '
    r103 = ' for type '
    r104 = ': expected type with no array dimension list'
    r105 = CPyStr_Build(5, r102, r101, r103, type_str_repr, r104)
    dec_ref r101
    dec_ref type_str_repr
    if is_error(r105) goto L74 (error at new_from_type_str:78) else goto L55
L55:
    r106 = builtins :: module
    r107 = 'ValueError'
    r108 = CPyObject_GetAttr(r106, r107)
    if is_error(r108) goto L95 (error at new_from_type_str:77) else goto L56
L56:
    r109 = [r105]
    r110 = load_address r109
    r111 = PyObject_Vectorcall(r108, r110, 1, 0)
    dec_ref r108
    if is_error(r111) goto L95 (error at new_from_type_str:77) else goto L57
L57:
    dec_ref r105
    CPy_Raise(r111)
    dec_ref r111
    if not 0 goto L74 (error at new_from_type_str:77) else goto L58 :: bool
L58:
    unreachable
L59:
    r112 = r1.with_arrlist
    dec_ref r1
    if is_error(r112) goto L96 (error at new_from_type_str:84) else goto L60
L60:
    if r112 goto L61 else goto L97 :: bool
L61:
    r113 = 'arrlist'
    r114 = CPyObject_GetAttr(r14, r113)
    if is_error(r114) goto L96 (error at new_from_type_str:84) else goto L62
L62:
    r115 = load_address _Py_NoneStruct
    r116 = r114 == r115
    dec_ref r114
    if r116 goto L98 else goto L97 :: bool
L63:
    r117 = '__name__'
    r118 = CPyObject_GetAttr(cls, r117)
    if is_error(r118) goto L87 (error at new_from_type_str:88) else goto L64
L64:
    r119 = cast(str, r118)
    if is_error(r119) goto L87 (error at new_from_type_str:88) else goto L65
L65:
    r120 = 'Cannot create '
    r121 = ' for type '
    r122 = ': expected type with array dimension list'
    r123 = CPyStr_Build(5, r120, r119, r121, type_str_repr, r122)
    dec_ref r119
    dec_ref type_str_repr
    if is_error(r123) goto L74 (error at new_from_type_str:86) else goto L66
L66:
    r124 = builtins :: module
    r125 = 'ValueError'
    r126 = CPyObject_GetAttr(r124, r125)
    if is_error(r126) goto L99 (error at new_from_type_str:85) else goto L67
L67:
    r127 = [r123]
    r128 = load_address r127
    r129 = PyObject_Vectorcall(r126, r128, 1, 0)
    dec_ref r126
    if is_error(r129) goto L99 (error at new_from_type_str:85) else goto L68
L68:
    dec_ref r123
    CPy_Raise(r129)
    dec_ref r129
    if not 0 goto L74 (error at new_from_type_str:85) else goto L69 :: bool
L69:
    unreachable
L70:
    r130 = 'validate'
    r131 = [r14]
    r132 = load_address r131
    r133 = PyObject_VectorcallMethod(r130, r132, 9223372036854775809, 0)
    if is_error(r133) goto L100 (error at new_from_type_str:94) else goto L101
L71:
    r134 = r0.old_from_type_str
    dec_ref r0
    if is_error(r134) goto L102 (error at new_from_type_str:96) else goto L72
L72:
    r135 = [cls, r14, registry]
    r136 = load_address r135
    r137 = PyObject_Vectorcall(r134, r136, 3, 0)
    dec_ref r134
    if is_error(r137) goto L102 (error at new_from_type_str:96) else goto L73
L73:
    dec_ref r14
    return r137
L74:
    r138 = <error> :: object
    return r138
L75:
    dec_ref r0
    goto L74
L76:
    dec_ref r0
    dec_ref r1
    goto L74
L77:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L74
L78:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    goto L74
L79:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref type_str_repr
    goto L74
L80:
    dec_ref r8
    goto L19
L81:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref r29
    goto L74
L82:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r29
    goto L74
L83:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r29
    dec_ref r37
    goto L74
L84:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L74
L85:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    goto L74
L86:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L24
L87:
    dec_ref type_str_repr
    goto L74
L88:
    dec_ref r60
    goto L74
L89:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    dec_ref r69
    goto L74
L90:
    dec_ref r0
    dec_ref r14
    goto L39
L91:
    dec_ref r1
    dec_ref type_str_repr
    goto L74
L92:
    dec_ref type_str_repr
    dec_ref r80
    goto L74
L93:
    dec_ref r87
    goto L74
L94:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L52
L95:
    dec_ref r105
    goto L74
L96:
    dec_ref r0
    dec_ref r14
    dec_ref type_str_repr
    goto L74
L97:
    dec_ref type_str_repr
    goto L70
L98:
    dec_ref r0
    dec_ref r14
    goto L63
L99:
    dec_ref r123
    goto L74
L100:
    dec_ref r0
    dec_ref r14
    goto L74
L101:
    dec_ref r133
    goto L71
L102:
    dec_ref r14
    goto L74

def decorator_parse_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def decorator_parse_type_str_obj.__call__(__mypyc_self__, old_from_type_str):
    __mypyc_self__ :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    r5 :: bool
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L14 (error at decorator:46) else goto L1
L1:
    r1 = decorator_parse_type_str_env()
    if is_error(r1) goto L15 (error at decorator:46) else goto L2
L2:
    r1.__mypyc_env__ = r0; r2 = is_error
    if not r2 goto L16 (error at decorator:46) else goto L3 :: bool
L3:
    inc_ref old_from_type_str
    r1.old_from_type_str = old_from_type_str; r3 = is_error
    if not r3 goto L16 (error at decorator:46) else goto L4 :: bool
L4:
    r4 = new_from_type_str_parse_type_str_decorator_obj()
    if is_error(r4) goto L16 (error at decorator:48) else goto L5
L5:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L17 (error at decorator:48) else goto L6 :: bool
L6:
    r6 = r1.old_from_type_str
    dec_ref r1
    if is_error(r6) goto L18 (error at decorator:47) else goto L7
L7:
    r7 = functools :: module
    r8 = 'wraps'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L19 (error at decorator:47) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L19 (error at decorator:47) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L18 (error at decorator:48) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = faster_eth_abi.from_type_str.globals :: static
    r17 = 'new_from_type_str'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at decorator:48) else goto L11 :: bool
L11:
    r20 = builtins :: module
    r21 = 'classmethod'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L20 (error at decorator:98) else goto L12
L12:
    r23 = [r15]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L20 (error at decorator:98) else goto L13
L13:
    dec_ref r15
    return r25
L14:
    r26 = <error> :: object
    return r26
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r1
    goto L14
L17:
    dec_ref r1
    dec_ref r4
    goto L14
L18:
    dec_ref r4
    goto L14
L19:
    dec_ref r4
    dec_ref r6
    goto L14
L20:
    dec_ref r15
    goto L14

def parse_type_str(expected_base, with_arrlist):
    expected_base :: union[str, None]
    with_arrlist :: bool
    r0 :: object
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    r5 :: bool
    decorator, r6 :: object
L0:
    if is_error(expected_base) goto L1 else goto L11
L1:
    r0 = box(None, 1)
    inc_ref r0
    expected_base = r0
L2:
    if is_error(with_arrlist) goto L3 else goto L4
L3:
    with_arrlist = 0
L4:
    r1 = parse_type_str_env()
    if is_error(r1) goto L12 (error at parse_type_str:35) else goto L5
L5:
    r1.expected_base = expected_base; r2 = is_error
    if not r2 goto L13 (error at parse_type_str:35) else goto L6 :: bool
L6:
    r1.with_arrlist = with_arrlist; r3 = is_error
    if not r3 goto L13 (error at parse_type_str:35) else goto L7 :: bool
L7:
    r4 = decorator_parse_type_str_obj()
    if is_error(r4) goto L13 (error at parse_type_str:46) else goto L8
L8:
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at parse_type_str:46) else goto L9 :: bool
L9:
    decorator = r4
    return decorator
L10:
    r6 = <error> :: object
    return r6
L11:
    inc_ref expected_base
    goto L2
L12:
    dec_ref expected_base
    goto L10
L13:
    dec_ref r1
    goto L10
L14:
    dec_ref r4
    goto L10

def new_from_type_str_parse_tuple_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_tuple_type_str_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: dict
    r9 :: str
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, type_str_repr :: str
    r21 :: i32
    r22 :: bit
    r23 :: object
    r24, r25, r26 :: bit
    r27, r28, r29, r30, r31 :: str
    r32 :: object
    r33, r34, r35, r36 :: str
    r37 :: object
    r38 :: str
    r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: object[1]
    r45 :: object_ptr
    r46, r47 :: object
    r48 :: object[3]
    r49 :: object_ptr
    r50, r51 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L28 (error at new_from_type_str:113) else goto L1
L1:
    r1 = faster_eth_abi.from_type_str.globals :: static
    r2 = 'normalize'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L29 (error at new_from_type_str:114) else goto L2
L2:
    r4 = [type_str]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L29 (error at new_from_type_str:114) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L29 (error at new_from_type_str:114) else goto L4
L4:
    r8 = faster_eth_abi.from_type_str.globals :: static
    r9 = 'parse'
    r10 = CPyDict_GetItem(r8, r9)
    if is_error(r10) goto L30 (error at new_from_type_str:115) else goto L5
L5:
    r11 = [r7]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L30 (error at new_from_type_str:115) else goto L6
L6:
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'TupleType'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L31 (error at new_from_type_str:117) else goto L7
L7:
    r17 = PyObject_IsInstance(r13, r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L31 (error at new_from_type_str:117) else goto L8 :: bool
L8:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L32 else goto L33 :: bool
L9:
    r20 = PyObject_Repr(type_str)
    if is_error(r20) goto L34 (error at new_from_type_str:118) else goto L10
L10:
    type_str_repr = r20
    r21 = PyUnicode_Compare(type_str, r7)
    r22 = r21 == -1
    if r22 goto L11 else goto L13 :: bool
L11:
    r23 = PyErr_Occurred()
    r24 = r23 != 0
    if r24 goto L12 else goto L13 :: bool
L12:
    r25 = CPy_KeepPropagating()
    if not r25 goto L35 (error at new_from_type_str:119) else goto L13 :: bool
L13:
    r26 = r21 != 0
    if r26 goto L14 else goto L36 :: bool
L14:
    r27 = PyObject_Repr(r7)
    dec_ref r7
    if is_error(r27) goto L37 (error at new_from_type_str:122) else goto L15
L15:
    r28 = ' (normalized to '
    r29 = ')'
    r30 = CPyStr_Build(4, type_str_repr, r28, r27, r29)
    dec_ref type_str_repr
    dec_ref r27
    if is_error(r30) goto L28 (error at new_from_type_str:120) else goto L16
L16:
    type_str_repr = r30
L17:
    r31 = '__name__'
    r32 = CPyObject_GetAttr(cls, r31)
    if is_error(r32) goto L37 (error at new_from_type_str:126) else goto L18
L18:
    r33 = cast(str, r32)
    if is_error(r33) goto L37 (error at new_from_type_str:126) else goto L19
L19:
    r34 = 'Cannot create '
    r35 = ' for non-tuple type '
    r36 = CPyStr_Build(4, r34, r33, r35, type_str_repr)
    dec_ref r33
    dec_ref type_str_repr
    if is_error(r36) goto L28 (error at new_from_type_str:125) else goto L20
L20:
    r37 = builtins :: module
    r38 = 'ValueError'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L38 (error at new_from_type_str:124) else goto L21
L21:
    r40 = [r36]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r39, r41, 1, 0)
    dec_ref r39
    if is_error(r42) goto L38 (error at new_from_type_str:124) else goto L22
L22:
    dec_ref r36
    CPy_Raise(r42)
    dec_ref r42
    if not 0 goto L28 (error at new_from_type_str:124) else goto L23 :: bool
L23:
    unreachable
L24:
    r43 = 'validate'
    r44 = [r13]
    r45 = load_address r44
    r46 = PyObject_VectorcallMethod(r43, r45, 9223372036854775809, 0)
    if is_error(r46) goto L39 (error at new_from_type_str:131) else goto L40
L25:
    r47 = r0.old_from_type_str
    dec_ref r0
    if is_error(r47) goto L41 (error at new_from_type_str:133) else goto L26
L26:
    r48 = [cls, r13, registry]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r47, r49, 3, 0)
    dec_ref r47
    if is_error(r50) goto L41 (error at new_from_type_str:133) else goto L27
L27:
    dec_ref r13
    return r50
L28:
    r51 = <error> :: object
    return r51
L29:
    dec_ref r0
    goto L28
L30:
    dec_ref r0
    dec_ref r7
    goto L28
L31:
    dec_ref r0
    dec_ref r7
    dec_ref r13
    goto L28
L32:
    dec_ref r7
    goto L24
L33:
    dec_ref r0
    dec_ref r13
    goto L9
L34:
    dec_ref r7
    goto L28
L35:
    dec_ref r7
    dec_ref type_str_repr
    goto L28
L36:
    dec_ref r7
    goto L17
L37:
    dec_ref type_str_repr
    goto L28
L38:
    dec_ref r36
    goto L28
L39:
    dec_ref r0
    dec_ref r13
    goto L28
L40:
    dec_ref r46
    goto L25
L41:
    dec_ref r13
    goto L28

def parse_tuple_type_str(old_from_type_str):
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: bool
    r2 :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    r3 :: bool
    r4, r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = parse_tuple_type_str_env()
    if is_error(r0) goto L12 (error at parse_tuple_type_str:103) else goto L1
L1:
    inc_ref old_from_type_str
    r0.old_from_type_str = old_from_type_str; r1 = is_error
    if not r1 goto L13 (error at parse_tuple_type_str:103) else goto L2 :: bool
L2:
    r2 = new_from_type_str_parse_tuple_type_str_obj()
    if is_error(r2) goto L13 (error at parse_tuple_type_str:113) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L14 (error at parse_tuple_type_str:113) else goto L4 :: bool
L4:
    r4 = r0.old_from_type_str
    dec_ref r0
    if is_error(r4) goto L15 (error at parse_tuple_type_str:112) else goto L5
L5:
    r5 = functools :: module
    r6 = 'wraps'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L16 (error at parse_tuple_type_str:112) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L16 (error at parse_tuple_type_str:112) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L15 (error at parse_tuple_type_str:113) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'new_from_type_str'
    r16 = CPyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L17 (error at parse_tuple_type_str:113) else goto L9 :: bool
L9:
    r18 = builtins :: module
    r19 = 'classmethod'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L17 (error at parse_tuple_type_str:135) else goto L10
L10:
    r21 = [r13]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L17 (error at parse_tuple_type_str:135) else goto L11
L11:
    dec_ref r13
    return r23
L12:
    r24 = <error> :: object
    return r24
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref r0
    dec_ref r2
    goto L12
L15:
    dec_ref r2
    goto L12
L16:
    dec_ref r2
    dec_ref r4
    goto L12
L17:
    dec_ref r13
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: object
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44 :: dict
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: list
    r55, r56, r57, r58 :: ptr
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: tuple[list, object]
    r63, r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: i32
    r68 :: bit
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: list
    r82, r83, r84 :: ptr
    r85 :: dict
    r86 :: str
    r87 :: object
    r88 :: tuple[object, list, object]
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = faster_eth_abi.from_type_str.globals :: static
    r12 = 'faster_eth_abi/from_type_str.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('TYPE_CHECKING', 'Any', 'Callable', 'Optional', 'Type', 'TypeVar')
    r16 = 'typing'
    r17 = faster_eth_abi.from_type_str.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('TypeStr',)
    r20 = 'eth_typing'
    r21 = faster_eth_abi.from_type_str.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L30 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r24 = 'faster_eth_abi.grammar'
    r25 = faster_eth_abi.from_type_str.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L30 (error at <module>:15) else goto L7
L7:
    faster_eth_abi.grammar = r26 :: module
    dec_ref r26
    if 0 goto L8 else goto L8 :: bool
L8:
    r27 = 'TType'
    r28 = faster_eth_abi.from_type_str.globals :: static
    r29 = 'Type'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L30 (error at <module>:29) else goto L9
L9:
    r31 = 'BaseCoder'
    r32 = PyObject_GetItem(r30, r31)
    dec_ref r30
    if is_error(r32) goto L30 (error at <module>:29) else goto L10
L10:
    r33 = faster_eth_abi.from_type_str.globals :: static
    r34 = 'TypeVar'
    r35 = CPyDict_GetItem(r33, r34)
    if is_error(r35) goto L31 (error at <module>:29) else goto L11
L11:
    r36 = [r27, r32]
    r37 = load_address r36
    r38 = ('bound',)
    r39 = PyObject_Vectorcall(r35, r37, 1, r38)
    dec_ref r35
    if is_error(r39) goto L31 (error at <module>:29) else goto L12
L12:
    dec_ref r32
    r40 = faster_eth_abi.from_type_str.globals :: static
    r41 = 'TType'
    r42 = CPyDict_SetItem(r40, r41, r39)
    dec_ref r39
    r43 = r42 >= 0 :: signed
    if not r43 goto L30 (error at <module>:29) else goto L13 :: bool
L13:
    r44 = faster_eth_abi.from_type_str.globals :: static
    r45 = 'Callable'
    r46 = CPyDict_GetItem(r44, r45)
    if is_error(r46) goto L30 (error at <module>:30) else goto L14
L14:
    r47 = 'BaseCoder'
    r48 = faster_eth_abi.from_type_str.globals :: static
    r49 = 'ABIType'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L32 (error at <module>:30) else goto L15
L15:
    r51 = faster_eth_abi.from_type_str.globals :: static
    r52 = 'Any'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L33 (error at <module>:30) else goto L16
L16:
    r54 = PyList_New(3)
    if is_error(r54) goto L34 (error at <module>:30) else goto L17
L17:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    inc_ref r47
    set_mem r56, r47 :: builtins.object*
    r57 = r56 + 8
    set_mem r57, r50 :: builtins.object*
    r58 = r56 + 16
    set_mem r58, r53 :: builtins.object*
    r59 = faster_eth_abi.from_type_str.globals :: static
    r60 = 'TType'
    r61 = CPyDict_GetItem(r59, r60)
    if is_error(r61) goto L35 (error at <module>:30) else goto L18
L18:
    r62 = (r54, r61)
    r63 = box(tuple[list, object], r62)
    r64 = PyObject_GetItem(r46, r63)
    dec_ref r46
    dec_ref r63
    if is_error(r64) goto L30 (error at <module>:30) else goto L19
L19:
    r65 = faster_eth_abi.from_type_str.globals :: static
    r66 = 'OldFromTypeStr'
    r67 = CPyDict_SetItem(r65, r66, r64)
    dec_ref r64
    r68 = r67 >= 0 :: signed
    if not r68 goto L30 (error at <module>:30) else goto L20 :: bool
L20:
    if 0 goto L21 else goto L29 :: bool
L21:
    r69 = builtins :: module
    r70 = 'classmethod'
    r71 = CPyObject_GetAttr(r69, r70)
    if is_error(r71) goto L30 (error at <module>:32) else goto L22
L22:
    r72 = faster_eth_abi.from_type_str.globals :: static
    r73 = 'TType'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L36 (error at <module>:32) else goto L23
L23:
    r75 = faster_eth_abi.from_type_str.globals :: static
    r76 = 'TypeStr'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L37 (error at <module>:32) else goto L24
L24:
    r78 = faster_eth_abi.from_type_str.globals :: static
    r79 = 'Any'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L38 (error at <module>:32) else goto L25
L25:
    r81 = PyList_New(2)
    if is_error(r81) goto L39 (error at <module>:32) else goto L26
L26:
    r82 = get_element_ptr r81 ob_item :: PyListObject
    r83 = load_mem r82 :: ptr*
    set_mem r83, r77 :: builtins.object*
    r84 = r83 + 8
    set_mem r84, r80 :: builtins.object*
    r85 = faster_eth_abi.from_type_str.globals :: static
    r86 = 'TType'
    r87 = CPyDict_GetItem(r85, r86)
    if is_error(r87) goto L40 (error at <module>:32) else goto L27
L27:
    r88 = (r74, r81, r87)
    r89 = box(tuple[object, list, object], r88)
    r90 = PyObject_GetItem(r71, r89)
    dec_ref r71
    dec_ref r89
    if is_error(r90) goto L30 (error at <module>:32) else goto L28
L28:
    r91 = faster_eth_abi.from_type_str.globals :: static
    r92 = 'NewFromTypeStr'
    r93 = CPyDict_SetItem(r91, r92, r90)
    dec_ref r90
    r94 = r93 >= 0 :: signed
    if not r94 goto L30 (error at <module>:32) else goto L29 :: bool
L29:
    return 1
L30:
    r95 = <error> :: None
    return r95
L31:
    dec_ref r32
    goto L30
L32:
    dec_ref r46
    goto L30
L33:
    dec_ref r46
    dec_ref r50
    goto L30
L34:
    dec_ref r46
    dec_ref r50
    dec_ref r53
    goto L30
L35:
    dec_ref r46
    dec_ref r54
    goto L30
L36:
    dec_ref r71
    goto L30
L37:
    dec_ref r71
    dec_ref r74
    goto L30
L38:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    goto L30
L39:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    dec_ref r80
    goto L30
L40:
    dec_ref r71
    dec_ref r74
    dec_ref r81
    goto L30

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: bool
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: bool
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L31 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L31 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABICodec',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L31 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L31 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.abi.globals :: static
    r18 = 'registry'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L31 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.abi.globals :: static
    r21 = 'ABICodec'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L32 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L32 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.abi.default_codec = r25 :: static
    r26 = faster_eth_abi.abi.globals :: static
    r27 = 'default_codec'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L31 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.abi.default_codec :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_codec" was not set')
    if not r31 goto L31 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L31 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.abi.encode = r33 :: static
    r34 = faster_eth_abi.abi.globals :: static
    r35 = 'encode'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L31 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.abi.default_codec :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_codec" was not set')
    if not r39 goto L31 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'decode'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L31 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.abi.decode = r41 :: static
    r42 = faster_eth_abi.abi.globals :: static
    r43 = 'decode'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L31 (error at <module>:15) else goto L20 :: bool
L20:
    r46 = faster_eth_abi.abi.default_codec :: static
    if is_error(r46) goto L21 else goto L23
L21:
    r47 = raise NameError('value for final name "default_codec" was not set')
    if not r47 goto L31 (error at <module>:16) else goto L22 :: bool
L22:
    unreachable
L23:
    r48 = 'is_encodable'
    r49 = CPyObject_GetAttr(r46, r48)
    if is_error(r49) goto L31 (error at <module>:16) else goto L24
L24:
    faster_eth_abi.abi.is_encodable = r49 :: static
    r50 = faster_eth_abi.abi.globals :: static
    r51 = 'is_encodable'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L31 (error at <module>:16) else goto L25 :: bool
L25:
    r54 = faster_eth_abi.abi.default_codec :: static
    if is_error(r54) goto L26 else goto L28
L26:
    r55 = raise NameError('value for final name "default_codec" was not set')
    if not r55 goto L31 (error at <module>:17) else goto L27 :: bool
L27:
    unreachable
L28:
    r56 = 'is_encodable_type'
    r57 = CPyObject_GetAttr(r54, r56)
    if is_error(r57) goto L31 (error at <module>:17) else goto L29
L29:
    faster_eth_abi.abi.is_encodable_type = r57 :: static
    r58 = faster_eth_abi.abi.globals :: static
    r59 = 'is_encodable_type'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L31 (error at <module>:17) else goto L30 :: bool
L30:
    return 1
L31:
    r62 = <error> :: None
    return r62
L32:
    dec_ref r19
    goto L31

def abbr(value, limit):
    value :: object
    limit :: int
    r0, rep :: str
    r1 :: native_int
    r2 :: bit
    r3 :: short_int
    r4 :: native_int
    r5 :: bit
    r6 :: native_int
    r7, r8, r9 :: bit
    r10 :: native_int
    r11 :: bit
    r12 :: native_int
    r13, r14, r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: int
    r24 :: object
    r25, r26, r27, r28 :: str
L0:
    if is_error(limit) goto L1 else goto L22
L1:
    limit = 158
L2:
    r0 = PyObject_Repr(value)
    if is_error(r0) goto L23 (error at abbr:11) else goto L3
L3:
    rep = r0
    r1 = CPyStr_Size_size_t(rep)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at abbr:13) else goto L4 :: bool
L4:
    r3 = r1 << 1
    r4 = r3 & 1
    r5 = r4 != 0
    if r5 goto L6 else goto L5 :: bool
L5:
    r6 = limit & 1
    r7 = r6 != 0
    if r7 goto L6 else goto L7 :: bool
L6:
    r8 = CPyTagged_IsLt_(limit, r3)
    if r8 goto L8 else goto L25 :: bool
L7:
    r9 = r3 > limit :: signed
    if r9 goto L8 else goto L25 :: bool
L8:
    r10 = limit & 1
    r11 = r10 != 0
    if r11 goto L10 else goto L9 :: bool
L9:
    r12 = 6 & 1
    r13 = r12 != 0
    if r13 goto L10 else goto L11 :: bool
L10:
    r14 = CPyTagged_IsLt_(limit, 6)
    if r14 goto L26 else goto L16 :: bool
L11:
    r15 = limit < 6 :: signed
    if r15 goto L26 else goto L16 :: bool
L12:
    r16 = 'Abbreviation limit may not be less than 3'
    r17 = builtins :: module
    r18 = 'ValueError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L21 (error at abbr:15) else goto L13
L13:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L21 (error at abbr:15) else goto L14
L14:
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L21 (error at abbr:15) else goto L15 :: bool
L15:
    unreachable
L16:
    r23 = CPyTagged_Subtract(limit, 6)
    dec_ref limit :: int
    r24 = CPyStr_GetSlice(rep, 0, r23)
    dec_ref rep
    dec_ref r23 :: int
    if is_error(r24) goto L21 (error at abbr:17) else goto L17
L17:
    r25 = cast(str, r24)
    if is_error(r25) goto L21 (error at abbr:17) else goto L18
L18:
    r26 = '...'
    r27 = PyUnicode_Concat(r25, r26)
    dec_ref r25
    if is_error(r27) goto L21 (error at abbr:17) else goto L19
L19:
    rep = r27
L20:
    return rep
L21:
    r28 = <error> :: str
    return r28
L22:
    inc_ref limit :: int
    goto L2
L23:
    dec_ref limit :: int
    goto L21
L24:
    dec_ref limit :: int
    dec_ref rep
    goto L21
L25:
    dec_ref limit :: int
    goto L20
L26:
    dec_ref limit :: int
    dec_ref rep
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.string.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: int
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: int
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: int
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = object 115792089237316195423570985008687907853269984665640564039457584007913129639936
    r10 = faster_eth_abi.constants.globals :: static
    r11 = 'TT256'
    inc_ref r9 :: int
    r12 = box(int, r9)
    r13 = CPyDict_SetItem(r10, r11, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L8 (error at <module>:5) else goto L5 :: bool
L5:
    r15 = object 115792089237316195423570985008687907853269984665640564039457584007913129639935
    r16 = faster_eth_abi.constants.globals :: static
    r17 = 'TT256M1'
    inc_ref r15 :: int
    r18 = box(int, r15)
    r19 = CPyDict_SetItem(r16, r17, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L8 (error at <module>:6) else goto L6 :: bool
L6:
    r21 = object 57896044618658097711785492504343953926634992332820282019728792003956564819968
    r22 = faster_eth_abi.constants.globals :: static
    r23 = 'TT255'
    inc_ref r21 :: int
    r24 = box(int, r21)
    r25 = CPyDict_SetItem(r22, r23, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L8 (error at <module>:7) else goto L7 :: bool
L7:
    return 1
L8:
    r27 = <error> :: None
    return r27

def validate_bytes_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: str
    r11 :: object
    r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: None
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L10 (error at validate_bytes_param:7) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(param, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L10 (error at validate_bytes_param:7) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L9 else goto L3 :: bool
L3:
    r9 = 'The `'
    r10 = '` value must be of bytes type. Got '
    r11 = PyObject_Type(param)
    r12 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r12) goto L10 (error at validate_bytes_param:9) else goto L4
L4:
    r13 = CPyStr_Build(4, r9, param_name, r10, r12)
    dec_ref r12
    if is_error(r13) goto L10 (error at validate_bytes_param:9) else goto L5
L5:
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L11 (error at validate_bytes_param:8) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L11 (error at validate_bytes_param:8) else goto L7
L7:
    dec_ref r13
    CPy_Raise(r19)
    dec_ref r19
    if not 0 goto L10 (error at validate_bytes_param:8) else goto L8 :: bool
L8:
    unreachable
L9:
    return 1
L10:
    r20 = <error> :: None
    return r20
L11:
    dec_ref r13
    goto L10

def validate_list_like_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: tuple[object, object]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7, r8 :: str
    r9 :: object
    r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: None
L0:
    r0 = load_address PyList_Type
    r1 = load_address PyTuple_Type
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[object, object], r2)
    r4 = PyObject_IsInstance(param, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L9 (error at validate_list_like_param:14) else goto L1 :: bool
L1:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L8 else goto L2 :: bool
L2:
    r7 = 'The `'
    r8 = '` value type must be one of list or tuple. Got '
    r9 = PyObject_Type(param)
    r10 = PyObject_Str(r9)
    dec_ref r9
    if is_error(r10) goto L9 (error at validate_list_like_param:16) else goto L3
L3:
    r11 = CPyStr_Build(4, r7, param_name, r8, r10)
    dec_ref r10
    if is_error(r11) goto L9 (error at validate_list_like_param:16) else goto L4
L4:
    r12 = builtins :: module
    r13 = 'TypeError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L10 (error at validate_list_like_param:15) else goto L5
L5:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L10 (error at validate_list_like_param:15) else goto L6
L6:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L9 (error at validate_list_like_param:15) else goto L7 :: bool
L7:
    unreachable
L8:
    return 1
L9:
    r18 = <error> :: None
    return r18
L10:
    dec_ref r11
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.validation.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9
