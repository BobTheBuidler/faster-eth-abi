def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L21 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.packed.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L21 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABIEncoder',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.packed.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L21 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry_packed',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.packed.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L21 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.packed.globals :: static
    r18 = 'registry_packed'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L21 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.packed.globals :: static
    r21 = 'ABIEncoder'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L22 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L22 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.packed.default_encoder_packed = r25 :: static
    r26 = faster_eth_abi.packed.globals :: static
    r27 = 'default_encoder_packed'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r31 goto L21 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L21 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.packed.encode_packed = r33 :: static
    r34 = faster_eth_abi.packed.globals :: static
    r35 = 'encode_packed'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L21 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.packed.default_encoder_packed :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_encoder_packed" was not set')
    if not r39 goto L21 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'is_encodable'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L21 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.packed.is_encodable_packed = r41 :: static
    r42 = faster_eth_abi.packed.globals :: static
    r43 = 'is_encodable_packed'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L21 (error at <module>:15) else goto L20 :: bool
L20:
    return 1
L21:
    r46 = <error> :: None
    return r46
L22:
    dec_ref r19
    goto L21

def zpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad:2) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad:2) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad(value, 64)
    if is_error(r0) goto L2 (error at zpad32:6) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def zpad_right(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\x00'
    r1 = 'ljust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at zpad_right:10) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at zpad_right:10) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def zpad32_right(value):
    value, r0, r1 :: bytes
L0:
    r0 = zpad_right(value, 64)
    if is_error(r0) goto L2 (error at zpad32_right:14) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def fpad(value, length):
    value :: bytes
    length :: int
    r0 :: bytes
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bytes
L0:
    r0 = b'\xff'
    r1 = 'rjust'
    inc_ref length :: int
    r2 = box(int, length)
    r3 = [value, r2, r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L4 (error at fpad:18) else goto L1
L1:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L3 (error at fpad:18) else goto L2
L2:
    return r6
L3:
    r7 = <error> :: bytes
    return r7
L4:
    dec_ref r2
    goto L3

def fpad32(value):
    value, r0, r1 :: bytes
L0:
    r0 = fpad(value, 64)
    if is_error(r0) goto L2 (error at fpad32:22) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bytes
    return r1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def validate_bytes_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: str
    r11 :: object
    r12, r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: None
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L10 (error at validate_bytes_param:7) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(param, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L10 (error at validate_bytes_param:7) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L9 else goto L3 :: bool
L3:
    r9 = 'The `'
    r10 = '` value must be of bytes type. Got '
    r11 = CPy_TYPE(param)
    r12 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r12) goto L10 (error at validate_bytes_param:9) else goto L4
L4:
    r13 = CPyStr_Build(4, r9, param_name, r10, r12)
    dec_ref r12
    if is_error(r13) goto L10 (error at validate_bytes_param:9) else goto L5
L5:
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L11 (error at validate_bytes_param:8) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L11 (error at validate_bytes_param:8) else goto L7
L7:
    dec_ref r13
    CPy_Raise(r19)
    dec_ref r19
    if not 0 goto L10 (error at validate_bytes_param:8) else goto L8 :: bool
L8:
    unreachable
L9:
    return 1
L10:
    r20 = <error> :: None
    return r20
L11:
    dec_ref r13
    goto L10

def validate_list_like_param(param, param_name):
    param :: object
    param_name :: str
    r0, r1 :: object
    r2 :: tuple[object, object]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7, r8 :: str
    r9 :: object
    r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: None
L0:
    r0 = load_address PyList_Type
    r1 = load_address PyTuple_Type
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[object, object], r2)
    r4 = PyObject_IsInstance(param, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L9 (error at validate_list_like_param:14) else goto L1 :: bool
L1:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L8 else goto L2 :: bool
L2:
    r7 = 'The `'
    r8 = '` value type must be one of list or tuple. Got '
    r9 = CPy_TYPE(param)
    r10 = PyObject_Str(r9)
    dec_ref r9
    if is_error(r10) goto L9 (error at validate_list_like_param:16) else goto L3
L3:
    r11 = CPyStr_Build(4, r7, param_name, r8, r10)
    dec_ref r10
    if is_error(r11) goto L9 (error at validate_list_like_param:16) else goto L4
L4:
    r12 = builtins :: module
    r13 = 'TypeError'
    r14 = CPyObject_GetAttr(r12, r13)
    if is_error(r14) goto L10 (error at validate_list_like_param:15) else goto L5
L5:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L10 (error at validate_list_like_param:15) else goto L6
L6:
    dec_ref r11
    CPy_Raise(r17)
    dec_ref r17
    if not 0 goto L9 (error at validate_list_like_param:15) else goto L7 :: bool
L7:
    unreachable
L8:
    return 1
L9:
    r18 = <error> :: None
    return r18
L10:
    dec_ref r11
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.validation.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def encode_tuple(values, encoders):
    values, encoders :: object
    r0, r1 :: list
    r2, r3, r4, r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: bytes
    r19 :: i32
    r20 :: bit
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: bytes
    r25 :: i32
    r26 :: bit
    r27 :: bytes
    r28 :: i32
    r29, r30, r31 :: bit
    r32 :: int
    r33 :: native_int
    r34 :: ptr
    r35 :: native_int
    r36 :: bit
    r37, r38 :: ptr
    r39 :: native_int
    r40 :: ptr
    r41 :: object
    r42 :: union[bytes, None]
    r43 :: object
    r44 :: bit
    r45 :: int
    r46 :: bytes
    r47 :: ptr
    r48 :: native_int
    r49 :: short_int
    r50 :: int
    r51 :: native_int
    head_length :: int
    r52 :: list
    r53 :: object
    r54, r55 :: ptr
    total_offset :: int
    r56 :: object
    r57 :: list
    r58 :: native_int
    r59 :: ptr
    r60 :: native_int
    r61 :: bit
    r62, r63 :: ptr
    r64 :: native_int
    r65 :: ptr
    r66 :: object
    r67 :: bytes
    r68 :: ptr
    r69 :: native_int
    r70 :: short_int
    r71 :: int
    r72 :: object
    r73 :: i32
    r74 :: bit
    r75 :: native_int
    r76 :: list
    r77, r78 :: native_int
    r79 :: ptr
    r80 :: native_int
    r81 :: bit
    r82 :: ptr
    r83 :: native_int
    r84 :: bit
    r85, r86 :: ptr
    r87 :: native_int
    r88 :: ptr
    r89 :: object
    r90 :: union[bytes, None]
    r91, r92 :: ptr
    r93 :: native_int
    r94 :: ptr
    r95 :: object
    r96 :: int
    r97 :: object
    r98 :: bit
    r99 :: int
    r100, r101, r102 :: bytes
    r103 :: i32
    r104 :: bit
    r105, r106 :: native_int
    r107 :: tuple
    r108, r109, r110, r111, r112, r113 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L54 (error at encode_tuple:24) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L55 (error at encode_tuple:25) else goto L2
L2:
    r2 = PyObject_GetIter(values)
    if is_error(r2) goto L56 (error at encode_tuple:26) else goto L3
L3:
    r3 = PyObject_GetIter(encoders)
    if is_error(r3) goto L57 (error at encode_tuple:26) else goto L4
L4:
    r4 = PyIter_Next(r2)
    if is_error(r4) goto L58 else goto L5
L5:
    r5 = PyIter_Next(r3)
    if is_error(r5) goto L59 else goto L6
L6:
    r6 = 'is_dynamic'
    r7 = box(bool, 0)
    r8 = CPyObject_GetAttr3(r5, r6, r7)
    if is_error(r8) goto L60 (error at encode_tuple:27) else goto L7
L7:
    r9 = PyObject_IsTrue(r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L60 (error at encode_tuple:27) else goto L8 :: bool
L8:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L9 else goto L13 :: bool
L9:
    r12 = box(None, 1)
    r13 = PyList_Append(r0, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L60 (error at encode_tuple:28) else goto L10 :: bool
L10:
    r15 = [r4]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r5, r16, 1, 0)
    dec_ref r5
    if is_error(r17) goto L61 (error at encode_tuple:29) else goto L11
L11:
    dec_ref r4
    r18 = cast(bytes, r17)
    if is_error(r18) goto L62 (error at encode_tuple:29) else goto L12
L12:
    r19 = PyList_Append(r1, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L62 (error at encode_tuple:29) else goto L4 :: bool
L13:
    r21 = [r4]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r5, r22, 1, 0)
    dec_ref r5
    if is_error(r23) goto L61 (error at encode_tuple:31) else goto L14
L14:
    dec_ref r4
    r24 = cast(bytes, r23)
    if is_error(r24) goto L62 (error at encode_tuple:31) else goto L15
L15:
    r25 = PyList_Append(r0, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L62 (error at encode_tuple:31) else goto L16 :: bool
L16:
    r27 = b''
    r28 = PyList_Append(r1, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L62 (error at encode_tuple:32) else goto L4 :: bool
L17:
    r30 = CPy_NoErrOccurred()
    if not r30 goto L56 (error at encode_tuple:26) else goto L18 :: bool
L18:
    r31 = CPy_NoErrOccurred()
    if not r31 goto L56 (error at encode_tuple:26) else goto L19 :: bool
L19:
    r32 = 0
    r33 = 0
L20:
    r34 = get_element_ptr r0 ob_size :: PyVarObject
    r35 = load_mem r34 :: native_int*
    r36 = r33 < r35 :: signed
    if r36 goto L21 else goto L28 :: bool
L21:
    r37 = get_element_ptr r0 ob_item :: PyListObject
    r38 = load_mem r37 :: ptr*
    r39 = r33 * 8
    r40 = r38 + r39
    r41 = load_mem r40 :: builtins.object*
    r42 = cast(union[bytes, None], r41)
    if is_error(r42) goto L63 (error at encode_tuple:34) else goto L22
L22:
    r43 = load_address _Py_NoneStruct
    r44 = r42 == r43
    if r44 goto L64 else goto L24 :: bool
L23:
    r45 = 64
    goto L26
L24:
    r46 = cast(bytes, r42)
    if is_error(r46) goto L63 (error at encode_tuple:34) else goto L25
L25:
    r47 = get_element_ptr r46 ob_size :: PyVarObject
    r48 = load_mem r47 :: native_int*
    dec_ref r46
    r49 = r48 << 1
    r45 = r49
L26:
    r50 = CPyTagged_Add(r32, r45)
    dec_ref r32 :: int
    dec_ref r45 :: int
    r32 = r50
L27:
    r51 = r33 + 1
    r33 = r51
    goto L20
L28:
    head_length = r32
    r52 = PyList_New(1)
    if is_error(r52) goto L65 (error at encode_tuple:35) else goto L29
L29:
    r53 = object 0
    r54 = get_element_ptr r52 ob_item :: PyListObject
    r55 = load_mem r54 :: ptr*
    inc_ref r53
    set_mem r55, r53 :: builtins.object*
    total_offset = 0
    r56 = CPyList_GetSlice(r1, 0, -2)
    if is_error(r56) goto L66 (error at encode_tuple:37) else goto L30
L30:
    r57 = cast(list, r56)
    if is_error(r57) goto L66 (error at encode_tuple:37) else goto L31
L31:
    r58 = 0
L32:
    r59 = get_element_ptr r57 ob_size :: PyVarObject
    r60 = load_mem r59 :: native_int*
    r61 = r58 < r60 :: signed
    if r61 goto L33 else goto L67 :: bool
L33:
    r62 = get_element_ptr r57 ob_item :: PyListObject
    r63 = load_mem r62 :: ptr*
    r64 = r58 * 8
    r65 = r63 + r64
    r66 = load_mem r65 :: builtins.object*
    r67 = cast(bytes, r66)
    if is_error(r67) goto L68 (error at encode_tuple:37) else goto L34
L34:
    r68 = get_element_ptr r67 ob_size :: PyVarObject
    r69 = load_mem r68 :: native_int*
    dec_ref r67
    r70 = r69 << 1
    r71 = CPyTagged_Add(total_offset, r70)
    dec_ref total_offset :: int
    total_offset = r71
    inc_ref total_offset :: int
    r72 = box(int, total_offset)
    r73 = PyList_Append(r52, r72)
    dec_ref r72
    r74 = r73 >= 0 :: signed
    if not r74 goto L68 (error at encode_tuple:39) else goto L35 :: bool
L35:
    r75 = r58 + 1
    r58 = r75
    goto L32
L36:
    r76 = PyList_New(0)
    if is_error(r76) goto L69 (error at encode_tuple:41) else goto L37
L37:
    r77 = 0
    r78 = 0
L38:
    r79 = get_element_ptr r0 ob_size :: PyVarObject
    r80 = load_mem r79 :: native_int*
    r81 = r77 < r80 :: signed
    if r81 goto L39 else goto L70 :: bool
L39:
    r82 = get_element_ptr r52 ob_size :: PyVarObject
    r83 = load_mem r82 :: native_int*
    r84 = r78 < r83 :: signed
    if r84 goto L40 else goto L70 :: bool
L40:
    r85 = get_element_ptr r0 ob_item :: PyListObject
    r86 = load_mem r85 :: ptr*
    r87 = r77 * 8
    r88 = r86 + r87
    r89 = load_mem r88 :: builtins.object*
    r90 = cast(union[bytes, None], r89)
    if is_error(r90) goto L71 (error at encode_tuple:41) else goto L41
L41:
    r91 = get_element_ptr r52 ob_item :: PyListObject
    r92 = load_mem r91 :: ptr*
    r93 = r78 * 8
    r94 = r92 + r93
    r95 = load_mem r94 :: builtins.object*
    r96 = unbox(int, r95)
    dec_ref r95
    if is_error(r96) goto L72 (error at encode_tuple:41) else goto L42
L42:
    r97 = load_address _Py_NoneStruct
    r98 = r90 == r97
    if r98 goto L73 else goto L74 :: bool
L43:
    r99 = CPyTagged_Add(head_length, r96)
    dec_ref r96 :: int
    r100 = encode_uint_256(r99)
    dec_ref r99 :: int
    if is_error(r100) goto L71 (error at encode_tuple:42) else goto L44
L44:
    r101 = r100
    goto L47
L45:
    r102 = cast(bytes, r90)
    if is_error(r102) goto L71 (error at encode_tuple:42) else goto L46
L46:
    r101 = r102
L47:
    r103 = PyList_Append(r76, r101)
    dec_ref r101
    r104 = r103 >= 0 :: signed
    if not r104 goto L71 (error at encode_tuple:41) else goto L48 :: bool
L48:
    r105 = r77 + 1
    r77 = r105
    r106 = r78 + 1
    r78 = r106
    goto L38
L49:
    r107 = PyList_AsTuple(r76)
    dec_ref r76
    if is_error(r107) goto L75 (error at encode_tuple:41) else goto L50
L50:
    r108 = b''
    r109 = CPyBytes_Join(r108, r107)
    dec_ref r107
    if is_error(r109) goto L75 (error at encode_tuple:46) else goto L51
L51:
    r110 = b''
    r111 = CPyBytes_Join(r110, r1)
    dec_ref r1
    if is_error(r111) goto L76 (error at encode_tuple:46) else goto L52
L52:
    r112 = CPyBytes_Concat(r109, r111)
    dec_ref r111
    if is_error(r112) goto L54 (error at encode_tuple:46) else goto L53
L53:
    return r112
L54:
    r113 = <error> :: bytes
    return r113
L55:
    dec_ref r0
    goto L54
L56:
    dec_ref r0
    dec_ref r1
    goto L54
L57:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L54
L58:
    dec_ref r2
    dec_ref r3
    goto L17
L59:
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L17
L60:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    goto L54
L61:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L54
L62:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L54
L63:
    dec_ref r0
    dec_ref r1
    dec_ref r32 :: int
    goto L54
L64:
    dec_ref r42
    goto L23
L65:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    goto L54
L66:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref total_offset :: int
    goto L54
L67:
    dec_ref total_offset :: int
    dec_ref r57
    goto L36
L68:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref total_offset :: int
    dec_ref r57
    goto L54
L69:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    goto L54
L70:
    dec_ref r0
    dec_ref head_length :: int
    dec_ref r52
    goto L49
L71:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref r76
    goto L54
L72:
    dec_ref r0
    dec_ref r1
    dec_ref head_length :: int
    dec_ref r52
    dec_ref r76
    dec_ref r90
    goto L54
L73:
    dec_ref r90
    goto L43
L74:
    dec_ref r96 :: int
    goto L45
L75:
    dec_ref r1
    goto L54
L76:
    dec_ref r109
    goto L54

def encode_fixed(value, encode_fn, is_big_endian, data_byte_size):
    value, encode_fn :: object
    is_big_endian :: bool
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3, r4 :: bytes
    r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10, r11 :: bytes
    r12 :: str
    r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L9 (error at encode_fixed:55) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L9 (error at encode_fixed:55) else goto L2
L2:
    if is_big_endian goto L3 else goto L6 :: bool
L3:
    r4 = b'\x00'
    r5 = 'rjust'
    inc_ref data_byte_size :: int
    r6 = box(int, data_byte_size)
    r7 = [r3, r6, r4]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r5, r8, 9223372036854775811, 0)
    if is_error(r9) goto L10 (error at encode_fixed:57) else goto L4
L4:
    dec_ref r3
    dec_ref r6
    r10 = cast(bytes, r9)
    if is_error(r10) goto L9 (error at encode_fixed:57) else goto L5
L5:
    return r10
L6:
    r11 = b'\x00'
    r12 = 'ljust'
    inc_ref data_byte_size :: int
    r13 = box(int, data_byte_size)
    r14 = [r3, r13, r11]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r12, r15, 9223372036854775811, 0)
    if is_error(r16) goto L11 (error at encode_fixed:59) else goto L7
L7:
    dec_ref r3
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at encode_fixed:59) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r3
    dec_ref r6
    goto L9
L11:
    dec_ref r3
    dec_ref r13
    goto L9

def encode_signed(value, encode_fn, data_byte_size):
    value, encode_fn :: object
    data_byte_size :: int
    r0 :: object[1]
    r1 :: object_ptr
    r2 :: object
    r3 :: bytes
    r4, r5 :: object
    r6 :: bool
    r7 :: bytes
    r8 :: str
    r9 :: object
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: bytes
L0:
    r0 = [value]
    r1 = load_address r0
    r2 = PyObject_Vectorcall(encode_fn, r1, 1, 0)
    if is_error(r2) goto L11 (error at encode_signed:67) else goto L1
L1:
    r3 = cast(bytes, r2)
    if is_error(r3) goto L11 (error at encode_signed:67) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(value, r4, 5)
    if is_error(r5) goto L12 (error at encode_signed:68) else goto L3
L3:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L12 (error at encode_signed:68) else goto L4
L4:
    if r6 goto L5 else goto L8 :: bool
L5:
    r7 = b'\x00'
    r8 = 'rjust'
    inc_ref data_byte_size :: int
    r9 = box(int, data_byte_size)
    r10 = [r3, r9, r7]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r8, r11, 9223372036854775811, 0)
    if is_error(r12) goto L13 (error at encode_signed:69) else goto L6
L6:
    dec_ref r3
    dec_ref r9
    r13 = cast(bytes, r12)
    if is_error(r13) goto L11 (error at encode_signed:69) else goto L7
L7:
    return r13
L8:
    r14 = b'\xff'
    r15 = 'rjust'
    inc_ref data_byte_size :: int
    r16 = box(int, data_byte_size)
    r17 = [r3, r16, r14]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r15, r18, 9223372036854775811, 0)
    if is_error(r19) goto L14 (error at encode_signed:71) else goto L9
L9:
    dec_ref r3
    dec_ref r16
    r20 = cast(bytes, r19)
    if is_error(r20) goto L11 (error at encode_signed:71) else goto L10
L10:
    return r20
L11:
    r21 = <error> :: bytes
    return r21
L12:
    dec_ref r3
    goto L11
L13:
    dec_ref r3
    dec_ref r9
    goto L11
L14:
    dec_ref r3
    dec_ref r16
    goto L11

def encode_elements(item_encoder, value):
    item_encoder, value :: object
    r0 :: list
    r1, r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bytes
    r7 :: i32
    r8, r9 :: bit
    r10 :: tuple
    r11 :: str
    r12, r13 :: object
    r14 :: bool
    r15 :: int
    r16 :: bit
    r17, r18 :: bytes
    r19, r20 :: int
    r21 :: list
    r22 :: object
    r23, r24 :: ptr
    total_offset :: int
    r25 :: object
    r26 :: tuple
    r27 :: ptr
    r28, r29 :: native_int
    r30 :: bit
    r31 :: object
    r32 :: bytes
    r33 :: ptr
    r34 :: native_int
    r35 :: short_int
    r36 :: int
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: native_int
    r41 :: ptr
    r42 :: native_int
    r43 :: tuple
    r44 :: native_int
    r45 :: ptr
    r46 :: native_int
    r47 :: bit
    r48, r49 :: ptr
    r50 :: native_int
    r51 :: ptr
    r52 :: object
    r53, r54 :: int
    r55 :: bytes
    r56 :: native_int
    r57, r58, r59, r60, r61, r62 :: bytes
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L35 (error at encode_elements:75) else goto L1
L1:
    r1 = PyObject_GetIter(value)
    if is_error(r1) goto L36 (error at encode_elements:75) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L37 else goto L3
L3:
    r3 = [r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(item_encoder, r4, 1, 0)
    if is_error(r5) goto L38 (error at encode_elements:75) else goto L4
L4:
    dec_ref r2
    r6 = cast(bytes, r5)
    if is_error(r6) goto L39 (error at encode_elements:75) else goto L5
L5:
    r7 = PyList_Append(r0, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L39 (error at encode_elements:75) else goto L2 :: bool
L6:
    r9 = CPy_NoErrOccurred()
    if not r9 goto L36 (error at encode_elements:75) else goto L7 :: bool
L7:
    r10 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r10) goto L35 (error at encode_elements:75) else goto L8
L8:
    r11 = 'is_dynamic'
    r12 = box(bool, 0)
    r13 = CPyObject_GetAttr3(item_encoder, r11, r12)
    if is_error(r13) goto L40 (error at encode_elements:77) else goto L9
L9:
    r14 = unbox(bool, r13)
    dec_ref r13
    if is_error(r14) goto L40 (error at encode_elements:77) else goto L10
L10:
    if r14 goto L11 else goto L13 :: bool
L11:
    r15 = CPyObject_Size(value)
    if is_error(r15) goto L40 (error at encode_elements:78) else goto L12
L12:
    r16 = r15 == 0
    dec_ref r15 :: int
    if r16 goto L13 else goto L15 :: bool
L13:
    r17 = b''
    r18 = CPyBytes_Join(r17, r10)
    dec_ref r10
    if is_error(r18) goto L35 (error at encode_elements:79) else goto L14
L14:
    return r18
L15:
    r19 = CPyObject_Size(value)
    if is_error(r19) goto L40 (error at encode_elements:81) else goto L16
L16:
    r20 = CPyTagged_Multiply(64, r19)
    dec_ref r19 :: int
    r21 = PyList_New(1)
    if is_error(r21) goto L41 (error at encode_elements:82) else goto L17
L17:
    r22 = object 0
    r23 = get_element_ptr r21 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    inc_ref r22
    set_mem r24, r22 :: builtins.object*
    total_offset = 0
    r25 = CPySequenceTuple_GetSlice(r10, 0, -2)
    if is_error(r25) goto L42 (error at encode_elements:84) else goto L18
L18:
    r26 = cast(tuple, r25)
    if is_error(r26) goto L42 (error at encode_elements:84) else goto L19
L19:
    r27 = get_element_ptr r26 ob_size :: PyVarObject
    r28 = load_mem r27 :: native_int*
    r29 = 0
L20:
    r30 = r29 < r28 :: signed
    if r30 goto L21 else goto L43 :: bool
L21:
    r31 = CPySequenceTuple_GetItemUnsafe(r26, r29)
    r32 = cast(bytes, r31)
    if is_error(r32) goto L44 (error at encode_elements:84) else goto L22
L22:
    r33 = get_element_ptr r32 ob_size :: PyVarObject
    r34 = load_mem r33 :: native_int*
    dec_ref r32
    r35 = r34 << 1
    r36 = CPyTagged_Add(total_offset, r35)
    dec_ref total_offset :: int
    total_offset = r36
    inc_ref total_offset :: int
    r37 = box(int, total_offset)
    r38 = PyList_Append(r21, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L44 (error at encode_elements:86) else goto L23 :: bool
L23:
    r40 = r29 + 1
    r29 = r40
    goto L20
L24:
    r41 = get_element_ptr r21 ob_size :: PyVarObject
    r42 = load_mem r41 :: native_int*
    r43 = PyTuple_New(r42)
    if is_error(r43) goto L45 (error at encode_elements:88) else goto L25
L25:
    r44 = 0
L26:
    r45 = get_element_ptr r21 ob_size :: PyVarObject
    r46 = load_mem r45 :: native_int*
    r47 = r44 < r46 :: signed
    if r47 goto L27 else goto L46 :: bool
L27:
    r48 = get_element_ptr r21 ob_item :: PyListObject
    r49 = load_mem r48 :: ptr*
    r50 = r44 * 8
    r51 = r49 + r50
    r52 = load_mem r51 :: builtins.object*
    r53 = unbox(int, r52)
    dec_ref r52
    if is_error(r53) goto L47 (error at encode_elements:88) else goto L28
L28:
    r54 = CPyTagged_Add(r20, r53)
    dec_ref r53 :: int
    r55 = encode_uint_256(r54)
    dec_ref r54 :: int
    if is_error(r55) goto L47 (error at encode_elements:89) else goto L29
L29:
    CPySequenceTuple_SetItemUnsafe(r43, r44, r55)
L30:
    r56 = r44 + 1
    r44 = r56
    goto L26
L31:
    r57 = b''
    r58 = CPyBytes_Join(r57, r43)
    dec_ref r43
    if is_error(r58) goto L40 (error at encode_elements:91) else goto L32
L32:
    r59 = b''
    r60 = CPyBytes_Join(r59, r10)
    dec_ref r10
    if is_error(r60) goto L48 (error at encode_elements:91) else goto L33
L33:
    r61 = CPyBytes_Concat(r58, r60)
    dec_ref r60
    if is_error(r61) goto L35 (error at encode_elements:91) else goto L34
L34:
    return r61
L35:
    r62 = <error> :: bytes
    return r62
L36:
    dec_ref r0
    goto L35
L37:
    dec_ref r1
    goto L6
L38:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L35
L39:
    dec_ref r0
    dec_ref r1
    goto L35
L40:
    dec_ref r10
    goto L35
L41:
    dec_ref r10
    dec_ref r20 :: int
    goto L35
L42:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref total_offset :: int
    goto L35
L43:
    dec_ref total_offset :: int
    dec_ref r26
    goto L24
L44:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref total_offset :: int
    dec_ref r26
    goto L35
L45:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    goto L35
L46:
    dec_ref r20 :: int
    dec_ref r21
    goto L31
L47:
    dec_ref r10
    dec_ref r20 :: int
    dec_ref r21
    dec_ref r43
    goto L35
L48:
    dec_ref r58
    goto L35

def encode_elements_dynamic(item_encoder, value):
    item_encoder, value :: object
    r0 :: int
    r1, r2, r3, r4 :: bytes
L0:
    r0 = CPyObject_Size(value)
    if is_error(r0) goto L5 (error at encode_elements_dynamic:95) else goto L1
L1:
    r1 = encode_uint_256(r0)
    dec_ref r0 :: int
    if is_error(r1) goto L5 (error at encode_elements_dynamic:95) else goto L2
L2:
    r2 = encode_elements(item_encoder, value)
    if is_error(r2) goto L6 (error at encode_elements_dynamic:96) else goto L3
L3:
    r3 = CPyBytes_Concat(r1, r2)
    dec_ref r2
    if is_error(r3) goto L5 (error at encode_elements_dynamic:97) else goto L4
L4:
    return r3
L5:
    r4 = <error> :: bytes
    return r4
L6:
    dec_ref r1
    goto L5

def encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = int_to_big_endian(i)
    if is_error(r0) goto L4 (error at encode_uint_256:104) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at encode_uint_256:105) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at encode_uint_256:105) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at int_to_big_endian:110) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at int_to_big_endian:110) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at int_to_big_endian:110) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at int_to_big_endian:110) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: str
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L9 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Callable', 'List', 'Optional', 'Sequence', 'TypeVar')
    r6 = 'typing'
    r7 = faster_eth_abi._encoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L9 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    if 0 goto L5 else goto L5 :: bool
L5:
    r9 = 'T'
    r10 = faster_eth_abi._encoding.globals :: static
    r11 = 'TypeVar'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L9 (error at <module>:17) else goto L6
L6:
    r13 = [r9]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L9 (error at <module>:17) else goto L7
L7:
    r16 = faster_eth_abi._encoding.globals :: static
    r17 = 'T'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L9 (error at <module>:17) else goto L8 :: bool
L8:
    return 1
L9:
    r20 = <error> :: None
    return r20

def new_from_type_str_parse_type_str_decorator_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_type_str_decorator_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: str
    r9 :: dict
    r10 :: str
    r11 :: object
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15, type_str_repr :: str
    r16 :: bool
    r17 :: bit
    r18, r19, r20, r21 :: str
    r22 :: object[3]
    r23 :: object_ptr
    r24 :: object
    r25, r26, r27, r28, r29 :: str
    r30 :: object[3]
    r31 :: object_ptr
    r32 :: object
    r33, r34 :: str
    r35 :: list
    r36, r37, r38, r39, r40 :: ptr
    r41 :: str
    r42 :: union[str, None]
    r43 :: object
    r44 :: bit
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: i32
    r49 :: bit
    r50 :: bool
    r51 :: object
    r52, r53, r54, r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: object[1]
    r60 :: object_ptr
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: str
    r65 :: union[str, None]
    r66 :: str
    r67 :: bool
    r68 :: bit
    r69 :: object
    r70 :: str
    r71 :: union[str, None]
    r72, r73, r74, r75, r76, r77 :: str
    r78 :: object
    r79 :: str
    r80 :: object
    r81 :: object[1]
    r82 :: object_ptr
    r83 :: object
    r84 :: bool
    r85 :: str
    r86, r87 :: object
    r88 :: bit
    r89 :: object
    r90, r91, r92, r93, r94 :: str
    r95 :: object
    r96 :: str
    r97 :: object
    r98 :: object[1]
    r99 :: object_ptr
    r100 :: object
    r101 :: bool
    r102 :: str
    r103, r104 :: object
    r105 :: bit
    r106 :: object
    r107, r108, r109, r110, r111 :: str
    r112 :: object
    r113 :: str
    r114 :: object
    r115 :: object[1]
    r116 :: object_ptr
    r117 :: object
    r118 :: str
    r119 :: object[1]
    r120 :: object_ptr
    r121, r122 :: object
    r123 :: object[3]
    r124 :: object_ptr
    r125, r126 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L68 (error at new_from_type_str:48) else goto L1
L1:
    r1 = r0.__mypyc_env__
    if is_error(r1) goto L69 (error at new_from_type_str:48) else goto L2
L2:
    r2 = faster_eth_abi.from_type_str.globals :: static
    r3 = 'normalize'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L70 (error at new_from_type_str:49) else goto L3
L3:
    r5 = [type_str]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L70 (error at new_from_type_str:49) else goto L4
L4:
    r8 = cast(str, r7)
    if is_error(r8) goto L70 (error at new_from_type_str:49) else goto L5
L5:
    r9 = faster_eth_abi.from_type_str.globals :: static
    r10 = 'parse'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L71 (error at new_from_type_str:50) else goto L6
L6:
    r12 = [r8]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 1, 0)
    dec_ref r11
    if is_error(r14) goto L71 (error at new_from_type_str:50) else goto L7
L7:
    r15 = PyObject_Repr(type_str)
    if is_error(r15) goto L72 (error at new_from_type_str:52) else goto L8
L8:
    type_str_repr = r15
    r16 = CPyStr_Equal(type_str, r8)
    r17 = r16 == 0
    if r17 goto L9 else goto L73 :: bool
L9:
    r18 = ''
    r19 = '{:{}}'
    r20 = ''
    r21 = 'format'
    r22 = [r19, type_str_repr, r20]
    r23 = load_address r22
    r24 = PyObject_VectorcallMethod(r21, r23, 9223372036854775811, 0)
    if is_error(r24) goto L74 (error at new_from_type_str:55) else goto L10
L10:
    dec_ref type_str_repr
    r25 = cast(str, r24)
    if is_error(r25) goto L72 (error at new_from_type_str:55) else goto L11
L11:
    r26 = ' (normalized to '
    r27 = '{!r:{}}'
    r28 = ''
    r29 = 'format'
    r30 = [r27, r8, r28]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r29, r31, 9223372036854775811, 0)
    if is_error(r32) goto L75 (error at new_from_type_str:55) else goto L12
L12:
    dec_ref r8
    r33 = cast(str, r32)
    if is_error(r33) goto L76 (error at new_from_type_str:55) else goto L13
L13:
    r34 = ')'
    r35 = PyList_New(4)
    if is_error(r35) goto L77 (error at new_from_type_str:55) else goto L14
L14:
    r36 = get_element_ptr r35 ob_item :: PyListObject
    r37 = load_mem r36 :: ptr*
    set_mem r37, r25 :: builtins.object*
    inc_ref r26
    r38 = r37 + 8
    set_mem r38, r26 :: builtins.object*
    r39 = r37 + 16
    set_mem r39, r33 :: builtins.object*
    inc_ref r34
    r40 = r37 + 24
    set_mem r40, r34 :: builtins.object*
    r41 = PyUnicode_Join(r18, r35)
    dec_ref r35
    if is_error(r41) goto L78 (error at new_from_type_str:55) else goto L15
L15:
    type_str_repr = r41
L16:
    r42 = r1.expected_base
    if is_error(r42) goto L79 (error at new_from_type_str:58) else goto L17
L17:
    r43 = load_address _Py_NoneStruct
    r44 = r42 != r43
    dec_ref r42
    if r44 goto L18 else goto L42 :: bool
L18:
    r45 = faster_eth_abi.from_type_str.globals :: static
    r46 = 'BasicType'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L79 (error at new_from_type_str:59) else goto L19
L19:
    r48 = PyObject_IsInstance(r14, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L79 (error at new_from_type_str:59) else goto L20 :: bool
L20:
    r50 = truncate r48: i32 to builtins.bool
    if r50 goto L28 else goto L80 :: bool
L21:
    r51 = CPy_GetName(cls)
    if is_error(r51) goto L81 (error at new_from_type_str:62) else goto L22
L22:
    r52 = cast(str, r51)
    if is_error(r52) goto L81 (error at new_from_type_str:62) else goto L23
L23:
    r53 = 'Cannot create '
    r54 = ' for non-basic type '
    r55 = CPyStr_Build(4, r53, r52, r54, type_str_repr)
    dec_ref r52
    dec_ref type_str_repr
    if is_error(r55) goto L68 (error at new_from_type_str:61) else goto L24
L24:
    r56 = builtins :: module
    r57 = 'ValueError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L82 (error at new_from_type_str:60) else goto L25
L25:
    r59 = [r55]
    r60 = load_address r59
    r61 = PyObject_Vectorcall(r58, r60, 1, 0)
    dec_ref r58
    if is_error(r61) goto L82 (error at new_from_type_str:60) else goto L26
L26:
    dec_ref r55
    CPy_Raise(r61)
    dec_ref r61
    if not 0 goto L68 (error at new_from_type_str:60) else goto L27 :: bool
L27:
    unreachable
L28:
    r62 = 'base'
    r63 = CPyObject_GetAttr(r14, r62)
    if is_error(r63) goto L79 (error at new_from_type_str:66) else goto L29
L29:
    r64 = cast(str, r63)
    if is_error(r64) goto L79 (error at new_from_type_str:66) else goto L30
L30:
    r65 = r1.expected_base
    if is_error(r65) goto L83 (error at new_from_type_str:66) else goto L31
L31:
    r66 = cast(str, r65)
    if is_error(r66) goto L83 (error at new_from_type_str:66) else goto L32
L32:
    r67 = CPyStr_Equal(r64, r66)
    dec_ref r64
    dec_ref r66
    r68 = r67 == 0
    if r68 goto L84 else goto L42 :: bool
L33:
    r69 = CPy_GetName(cls)
    if is_error(r69) goto L85 (error at new_from_type_str:70) else goto L34
L34:
    r70 = cast(str, r69)
    if is_error(r70) goto L85 (error at new_from_type_str:70) else goto L35
L35:
    r71 = r1.expected_base
    dec_ref r1
    if is_error(r71) goto L86 (error at new_from_type_str:72) else goto L36
L36:
    r72 = cast(str, r71)
    if is_error(r72) goto L86 (error at new_from_type_str:72) else goto L37
L37:
    r73 = 'Cannot create '
    r74 = ' for type '
    r75 = ": expected type with base '"
    r76 = "'"
    r77 = CPyStr_Build(7, r73, r70, r74, type_str_repr, r75, r72, r76)
    dec_ref r70
    dec_ref type_str_repr
    dec_ref r72
    if is_error(r77) goto L68 (error at new_from_type_str:68) else goto L38
L38:
    r78 = builtins :: module
    r79 = 'ValueError'
    r80 = CPyObject_GetAttr(r78, r79)
    if is_error(r80) goto L87 (error at new_from_type_str:67) else goto L39
L39:
    r81 = [r77]
    r82 = load_address r81
    r83 = PyObject_Vectorcall(r80, r82, 1, 0)
    dec_ref r80
    if is_error(r83) goto L87 (error at new_from_type_str:67) else goto L40
L40:
    dec_ref r77
    CPy_Raise(r83)
    dec_ref r83
    if not 0 goto L68 (error at new_from_type_str:67) else goto L41 :: bool
L41:
    unreachable
L42:
    r84 = r1.with_arrlist
    if is_error(r84) goto L79 (error at new_from_type_str:76) else goto L43
L43:
    if r84 goto L53 else goto L44 :: bool
L44:
    r85 = 'arrlist'
    r86 = CPyObject_GetAttr(r14, r85)
    if is_error(r86) goto L79 (error at new_from_type_str:76) else goto L45
L45:
    r87 = load_address _Py_NoneStruct
    r88 = r86 != r87
    dec_ref r86
    if r88 goto L88 else goto L53 :: bool
L46:
    r89 = CPy_GetName(cls)
    if is_error(r89) goto L81 (error at new_from_type_str:80) else goto L47
L47:
    r90 = cast(str, r89)
    if is_error(r90) goto L81 (error at new_from_type_str:80) else goto L48
L48:
    r91 = 'Cannot create '
    r92 = ' for type '
    r93 = ': expected type with no array dimension list'
    r94 = CPyStr_Build(5, r91, r90, r92, type_str_repr, r93)
    dec_ref r90
    dec_ref type_str_repr
    if is_error(r94) goto L68 (error at new_from_type_str:78) else goto L49
L49:
    r95 = builtins :: module
    r96 = 'ValueError'
    r97 = CPyObject_GetAttr(r95, r96)
    if is_error(r97) goto L89 (error at new_from_type_str:77) else goto L50
L50:
    r98 = [r94]
    r99 = load_address r98
    r100 = PyObject_Vectorcall(r97, r99, 1, 0)
    dec_ref r97
    if is_error(r100) goto L89 (error at new_from_type_str:77) else goto L51
L51:
    dec_ref r94
    CPy_Raise(r100)
    dec_ref r100
    if not 0 goto L68 (error at new_from_type_str:77) else goto L52 :: bool
L52:
    unreachable
L53:
    r101 = r1.with_arrlist
    dec_ref r1
    if is_error(r101) goto L90 (error at new_from_type_str:84) else goto L54
L54:
    if r101 goto L55 else goto L91 :: bool
L55:
    r102 = 'arrlist'
    r103 = CPyObject_GetAttr(r14, r102)
    if is_error(r103) goto L90 (error at new_from_type_str:84) else goto L56
L56:
    r104 = load_address _Py_NoneStruct
    r105 = r103 == r104
    dec_ref r103
    if r105 goto L92 else goto L91 :: bool
L57:
    r106 = CPy_GetName(cls)
    if is_error(r106) goto L81 (error at new_from_type_str:88) else goto L58
L58:
    r107 = cast(str, r106)
    if is_error(r107) goto L81 (error at new_from_type_str:88) else goto L59
L59:
    r108 = 'Cannot create '
    r109 = ' for type '
    r110 = ': expected type with array dimension list'
    r111 = CPyStr_Build(5, r108, r107, r109, type_str_repr, r110)
    dec_ref r107
    dec_ref type_str_repr
    if is_error(r111) goto L68 (error at new_from_type_str:86) else goto L60
L60:
    r112 = builtins :: module
    r113 = 'ValueError'
    r114 = CPyObject_GetAttr(r112, r113)
    if is_error(r114) goto L93 (error at new_from_type_str:85) else goto L61
L61:
    r115 = [r111]
    r116 = load_address r115
    r117 = PyObject_Vectorcall(r114, r116, 1, 0)
    dec_ref r114
    if is_error(r117) goto L93 (error at new_from_type_str:85) else goto L62
L62:
    dec_ref r111
    CPy_Raise(r117)
    dec_ref r117
    if not 0 goto L68 (error at new_from_type_str:85) else goto L63 :: bool
L63:
    unreachable
L64:
    r118 = 'validate'
    r119 = [r14]
    r120 = load_address r119
    r121 = PyObject_VectorcallMethod(r118, r120, 9223372036854775809, 0)
    if is_error(r121) goto L94 (error at new_from_type_str:94) else goto L95
L65:
    r122 = r0.old_from_type_str
    dec_ref r0
    if is_error(r122) goto L96 (error at new_from_type_str:96) else goto L66
L66:
    r123 = [cls, r14, registry]
    r124 = load_address r123
    r125 = PyObject_Vectorcall(r122, r124, 3, 0)
    dec_ref r122
    if is_error(r125) goto L96 (error at new_from_type_str:96) else goto L67
L67:
    dec_ref r14
    return r125
L68:
    r126 = <error> :: object
    return r126
L69:
    dec_ref r0
    goto L68
L70:
    dec_ref r0
    dec_ref r1
    goto L68
L71:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    goto L68
L72:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    goto L68
L73:
    dec_ref r8
    goto L16
L74:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L75:
    dec_ref r0
    dec_ref r1
    dec_ref r8
    dec_ref r14
    dec_ref r25
    goto L68
L76:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r25
    goto L68
L77:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref r25
    dec_ref r33
    goto L68
L78:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L68
L79:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L80:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L21
L81:
    dec_ref type_str_repr
    goto L68
L82:
    dec_ref r55
    goto L68
L83:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    dec_ref type_str_repr
    dec_ref r64
    goto L68
L84:
    dec_ref r0
    dec_ref r14
    goto L33
L85:
    dec_ref r1
    dec_ref type_str_repr
    goto L68
L86:
    dec_ref type_str_repr
    dec_ref r70
    goto L68
L87:
    dec_ref r77
    goto L68
L88:
    dec_ref r0
    dec_ref r1
    dec_ref r14
    goto L46
L89:
    dec_ref r94
    goto L68
L90:
    dec_ref r0
    dec_ref r14
    dec_ref type_str_repr
    goto L68
L91:
    dec_ref type_str_repr
    goto L64
L92:
    dec_ref r0
    dec_ref r14
    goto L57
L93:
    dec_ref r111
    goto L68
L94:
    dec_ref r0
    dec_ref r14
    goto L68
L95:
    dec_ref r121
    goto L65
L96:
    dec_ref r14
    goto L68

def decorator_parse_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def decorator_parse_type_str_obj.__call__(__mypyc_self__, old_from_type_str):
    __mypyc_self__ :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_type_str_env
    r1 :: faster_eth_abi.from_type_str.decorator_parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.new_from_type_str_parse_type_str_decorator_obj
    r5 :: bool
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L14 (error at decorator:46) else goto L1
L1:
    r1 = decorator_parse_type_str_env()
    if is_error(r1) goto L15 (error at decorator:46) else goto L2
L2:
    r1.__mypyc_env__ = r0; r2 = is_error
    if not r2 goto L16 (error at decorator:46) else goto L3 :: bool
L3:
    inc_ref old_from_type_str
    r1.old_from_type_str = old_from_type_str; r3 = is_error
    if not r3 goto L16 (error at decorator:46) else goto L4 :: bool
L4:
    r4 = new_from_type_str_parse_type_str_decorator_obj()
    if is_error(r4) goto L16 (error at decorator:48) else goto L5
L5:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L17 (error at decorator:48) else goto L6 :: bool
L6:
    r6 = r1.old_from_type_str
    dec_ref r1
    if is_error(r6) goto L18 (error at decorator:47) else goto L7
L7:
    r7 = functools :: module
    r8 = 'wraps'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L19 (error at decorator:47) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L19 (error at decorator:47) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L18 (error at decorator:48) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = faster_eth_abi.from_type_str.globals :: static
    r17 = 'new_from_type_str'
    r18 = PyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at decorator:48) else goto L11 :: bool
L11:
    r20 = builtins :: module
    r21 = 'classmethod'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L20 (error at decorator:98) else goto L12
L12:
    r23 = [r15]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L20 (error at decorator:98) else goto L13
L13:
    dec_ref r15
    return r25
L14:
    r26 = <error> :: object
    return r26
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r1
    goto L14
L17:
    dec_ref r1
    dec_ref r4
    goto L14
L18:
    dec_ref r4
    goto L14
L19:
    dec_ref r4
    dec_ref r6
    goto L14
L20:
    dec_ref r15
    goto L14

def parse_type_str(expected_base, with_arrlist):
    expected_base :: union[str, None]
    with_arrlist :: bool
    r0 :: object
    r1 :: faster_eth_abi.from_type_str.parse_type_str_env
    r2, r3 :: bool
    r4 :: faster_eth_abi.from_type_str.decorator_parse_type_str_obj
    r5 :: bool
    decorator, r6 :: object
L0:
    if is_error(expected_base) goto L1 else goto L11
L1:
    r0 = box(None, 1)
    inc_ref r0
    expected_base = r0
L2:
    if is_error(with_arrlist) goto L3 else goto L4
L3:
    with_arrlist = 0
L4:
    r1 = parse_type_str_env()
    if is_error(r1) goto L12 (error at parse_type_str:35) else goto L5
L5:
    r1.expected_base = expected_base; r2 = is_error
    if not r2 goto L13 (error at parse_type_str:35) else goto L6 :: bool
L6:
    r1.with_arrlist = with_arrlist; r3 = is_error
    if not r3 goto L13 (error at parse_type_str:35) else goto L7 :: bool
L7:
    r4 = decorator_parse_type_str_obj()
    if is_error(r4) goto L13 (error at parse_type_str:46) else goto L8
L8:
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at parse_type_str:46) else goto L9 :: bool
L9:
    decorator = r4
    return decorator
L10:
    r6 = <error> :: object
    return r6
L11:
    inc_ref expected_base
    goto L2
L12:
    dec_ref expected_base
    goto L10
L13:
    dec_ref r1
    goto L10
L14:
    dec_ref r4
    goto L10

def new_from_type_str_parse_tuple_type_str_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def new_from_type_str_parse_tuple_type_str_obj.__call__(__mypyc_self__, cls, type_str, registry):
    __mypyc_self__ :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    cls :: object
    type_str :: str
    registry :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: dict
    r9 :: str
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, type_str_repr :: str
    r21 :: bool
    r22 :: bit
    r23, r24, r25, r26 :: str
    r27 :: object
    r28, r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35 :: object[1]
    r36 :: object_ptr
    r37 :: object
    r38 :: str
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42 :: object
    r43 :: object[3]
    r44 :: object_ptr
    r45, r46 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L25 (error at new_from_type_str:113) else goto L1
L1:
    r1 = faster_eth_abi.from_type_str.globals :: static
    r2 = 'normalize'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L26 (error at new_from_type_str:114) else goto L2
L2:
    r4 = [type_str]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L26 (error at new_from_type_str:114) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L26 (error at new_from_type_str:114) else goto L4
L4:
    r8 = faster_eth_abi.from_type_str.globals :: static
    r9 = 'parse'
    r10 = CPyDict_GetItem(r8, r9)
    if is_error(r10) goto L27 (error at new_from_type_str:115) else goto L5
L5:
    r11 = [r7]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L27 (error at new_from_type_str:115) else goto L6
L6:
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'TupleType'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L28 (error at new_from_type_str:117) else goto L7
L7:
    r17 = PyObject_IsInstance(r13, r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L28 (error at new_from_type_str:117) else goto L8 :: bool
L8:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L29 else goto L30 :: bool
L9:
    r20 = PyObject_Repr(type_str)
    if is_error(r20) goto L31 (error at new_from_type_str:118) else goto L10
L10:
    type_str_repr = r20
    r21 = CPyStr_Equal(type_str, r7)
    r22 = r21 == 0
    if r22 goto L11 else goto L32 :: bool
L11:
    r23 = PyObject_Repr(r7)
    dec_ref r7
    if is_error(r23) goto L33 (error at new_from_type_str:122) else goto L12
L12:
    r24 = ' (normalized to '
    r25 = ')'
    r26 = CPyStr_Build(4, type_str_repr, r24, r23, r25)
    dec_ref type_str_repr
    dec_ref r23
    if is_error(r26) goto L25 (error at new_from_type_str:120) else goto L13
L13:
    type_str_repr = r26
L14:
    r27 = CPy_GetName(cls)
    if is_error(r27) goto L33 (error at new_from_type_str:126) else goto L15
L15:
    r28 = cast(str, r27)
    if is_error(r28) goto L33 (error at new_from_type_str:126) else goto L16
L16:
    r29 = 'Cannot create '
    r30 = ' for non-tuple type '
    r31 = CPyStr_Build(4, r29, r28, r30, type_str_repr)
    dec_ref r28
    dec_ref type_str_repr
    if is_error(r31) goto L25 (error at new_from_type_str:125) else goto L17
L17:
    r32 = builtins :: module
    r33 = 'ValueError'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L34 (error at new_from_type_str:124) else goto L18
L18:
    r35 = [r31]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r34, r36, 1, 0)
    dec_ref r34
    if is_error(r37) goto L34 (error at new_from_type_str:124) else goto L19
L19:
    dec_ref r31
    CPy_Raise(r37)
    dec_ref r37
    if not 0 goto L25 (error at new_from_type_str:124) else goto L20 :: bool
L20:
    unreachable
L21:
    r38 = 'validate'
    r39 = [r13]
    r40 = load_address r39
    r41 = PyObject_VectorcallMethod(r38, r40, 9223372036854775809, 0)
    if is_error(r41) goto L35 (error at new_from_type_str:131) else goto L36
L22:
    r42 = r0.old_from_type_str
    dec_ref r0
    if is_error(r42) goto L37 (error at new_from_type_str:133) else goto L23
L23:
    r43 = [cls, r13, registry]
    r44 = load_address r43
    r45 = PyObject_Vectorcall(r42, r44, 3, 0)
    dec_ref r42
    if is_error(r45) goto L37 (error at new_from_type_str:133) else goto L24
L24:
    dec_ref r13
    return r45
L25:
    r46 = <error> :: object
    return r46
L26:
    dec_ref r0
    goto L25
L27:
    dec_ref r0
    dec_ref r7
    goto L25
L28:
    dec_ref r0
    dec_ref r7
    dec_ref r13
    goto L25
L29:
    dec_ref r7
    goto L21
L30:
    dec_ref r0
    dec_ref r13
    goto L9
L31:
    dec_ref r7
    goto L25
L32:
    dec_ref r7
    goto L14
L33:
    dec_ref type_str_repr
    goto L25
L34:
    dec_ref r31
    goto L25
L35:
    dec_ref r0
    dec_ref r13
    goto L25
L36:
    dec_ref r41
    goto L22
L37:
    dec_ref r13
    goto L25

def parse_tuple_type_str(old_from_type_str):
    old_from_type_str :: object
    r0 :: faster_eth_abi.from_type_str.parse_tuple_type_str_env
    r1 :: bool
    r2 :: faster_eth_abi.from_type_str.new_from_type_str_parse_tuple_type_str_obj
    r3 :: bool
    r4, r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = parse_tuple_type_str_env()
    if is_error(r0) goto L12 (error at parse_tuple_type_str:103) else goto L1
L1:
    inc_ref old_from_type_str
    r0.old_from_type_str = old_from_type_str; r1 = is_error
    if not r1 goto L13 (error at parse_tuple_type_str:103) else goto L2 :: bool
L2:
    r2 = new_from_type_str_parse_tuple_type_str_obj()
    if is_error(r2) goto L13 (error at parse_tuple_type_str:113) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L14 (error at parse_tuple_type_str:113) else goto L4 :: bool
L4:
    r4 = r0.old_from_type_str
    dec_ref r0
    if is_error(r4) goto L15 (error at parse_tuple_type_str:112) else goto L5
L5:
    r5 = functools :: module
    r6 = 'wraps'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L16 (error at parse_tuple_type_str:112) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L16 (error at parse_tuple_type_str:112) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L15 (error at parse_tuple_type_str:113) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = faster_eth_abi.from_type_str.globals :: static
    r15 = 'new_from_type_str'
    r16 = PyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L17 (error at parse_tuple_type_str:113) else goto L9 :: bool
L9:
    r18 = builtins :: module
    r19 = 'classmethod'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L17 (error at parse_tuple_type_str:135) else goto L10
L10:
    r21 = [r13]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L17 (error at parse_tuple_type_str:135) else goto L11
L11:
    dec_ref r13
    return r23
L12:
    r24 = <error> :: object
    return r24
L13:
    dec_ref r0
    goto L12
L14:
    dec_ref r0
    dec_ref r2
    goto L12
L15:
    dec_ref r2
    goto L12
L16:
    dec_ref r2
    dec_ref r4
    goto L12
L17:
    dec_ref r13
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: object
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44 :: dict
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: list
    r55, r56, r57, r58 :: ptr
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: tuple[list, object]
    r63, r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: i32
    r68 :: bit
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: list
    r82, r83, r84 :: ptr
    r85 :: dict
    r86 :: str
    r87 :: object
    r88 :: tuple[object, list, object]
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = faster_eth_abi.from_type_str.globals :: static
    r12 = 'faster_eth_abi/from_type_str.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('TYPE_CHECKING', 'Any', 'Callable', 'Optional', 'Type', 'TypeVar')
    r16 = 'typing'
    r17 = faster_eth_abi.from_type_str.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('TypeStr',)
    r20 = 'eth_typing'
    r21 = faster_eth_abi.from_type_str.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L30 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r24 = 'faster_eth_abi.grammar'
    r25 = faster_eth_abi.from_type_str.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L30 (error at <module>:15) else goto L7
L7:
    faster_eth_abi.grammar = r26 :: module
    dec_ref r26
    if 0 goto L8 else goto L8 :: bool
L8:
    r27 = 'TType'
    r28 = faster_eth_abi.from_type_str.globals :: static
    r29 = 'Type'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L30 (error at <module>:29) else goto L9
L9:
    r31 = 'BaseCoder'
    r32 = PyObject_GetItem(r30, r31)
    dec_ref r30
    if is_error(r32) goto L30 (error at <module>:29) else goto L10
L10:
    r33 = faster_eth_abi.from_type_str.globals :: static
    r34 = 'TypeVar'
    r35 = CPyDict_GetItem(r33, r34)
    if is_error(r35) goto L31 (error at <module>:29) else goto L11
L11:
    r36 = [r27, r32]
    r37 = load_address r36
    r38 = ('bound',)
    r39 = PyObject_Vectorcall(r35, r37, 1, r38)
    dec_ref r35
    if is_error(r39) goto L31 (error at <module>:29) else goto L12
L12:
    dec_ref r32
    r40 = faster_eth_abi.from_type_str.globals :: static
    r41 = 'TType'
    r42 = CPyDict_SetItem(r40, r41, r39)
    dec_ref r39
    r43 = r42 >= 0 :: signed
    if not r43 goto L30 (error at <module>:29) else goto L13 :: bool
L13:
    r44 = faster_eth_abi.from_type_str.globals :: static
    r45 = 'Callable'
    r46 = CPyDict_GetItem(r44, r45)
    if is_error(r46) goto L30 (error at <module>:30) else goto L14
L14:
    r47 = 'BaseCoder'
    r48 = faster_eth_abi.from_type_str.globals :: static
    r49 = 'ABIType'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L32 (error at <module>:30) else goto L15
L15:
    r51 = faster_eth_abi.from_type_str.globals :: static
    r52 = 'Any'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L33 (error at <module>:30) else goto L16
L16:
    r54 = PyList_New(3)
    if is_error(r54) goto L34 (error at <module>:30) else goto L17
L17:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    inc_ref r47
    set_mem r56, r47 :: builtins.object*
    r57 = r56 + 8
    set_mem r57, r50 :: builtins.object*
    r58 = r56 + 16
    set_mem r58, r53 :: builtins.object*
    r59 = faster_eth_abi.from_type_str.globals :: static
    r60 = 'TType'
    r61 = CPyDict_GetItem(r59, r60)
    if is_error(r61) goto L35 (error at <module>:30) else goto L18
L18:
    r62 = (r54, r61)
    r63 = box(tuple[list, object], r62)
    r64 = PyObject_GetItem(r46, r63)
    dec_ref r46
    dec_ref r63
    if is_error(r64) goto L30 (error at <module>:30) else goto L19
L19:
    r65 = faster_eth_abi.from_type_str.globals :: static
    r66 = 'OldFromTypeStr'
    r67 = CPyDict_SetItem(r65, r66, r64)
    dec_ref r64
    r68 = r67 >= 0 :: signed
    if not r68 goto L30 (error at <module>:30) else goto L20 :: bool
L20:
    if 0 goto L21 else goto L29 :: bool
L21:
    r69 = builtins :: module
    r70 = 'classmethod'
    r71 = CPyObject_GetAttr(r69, r70)
    if is_error(r71) goto L30 (error at <module>:32) else goto L22
L22:
    r72 = faster_eth_abi.from_type_str.globals :: static
    r73 = 'TType'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L36 (error at <module>:32) else goto L23
L23:
    r75 = faster_eth_abi.from_type_str.globals :: static
    r76 = 'TypeStr'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L37 (error at <module>:32) else goto L24
L24:
    r78 = faster_eth_abi.from_type_str.globals :: static
    r79 = 'Any'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L38 (error at <module>:32) else goto L25
L25:
    r81 = PyList_New(2)
    if is_error(r81) goto L39 (error at <module>:32) else goto L26
L26:
    r82 = get_element_ptr r81 ob_item :: PyListObject
    r83 = load_mem r82 :: ptr*
    set_mem r83, r77 :: builtins.object*
    r84 = r83 + 8
    set_mem r84, r80 :: builtins.object*
    r85 = faster_eth_abi.from_type_str.globals :: static
    r86 = 'TType'
    r87 = CPyDict_GetItem(r85, r86)
    if is_error(r87) goto L40 (error at <module>:32) else goto L27
L27:
    r88 = (r74, r81, r87)
    r89 = box(tuple[object, list, object], r88)
    r90 = PyObject_GetItem(r71, r89)
    dec_ref r71
    dec_ref r89
    if is_error(r90) goto L30 (error at <module>:32) else goto L28
L28:
    r91 = faster_eth_abi.from_type_str.globals :: static
    r92 = 'NewFromTypeStr'
    r93 = CPyDict_SetItem(r91, r92, r90)
    dec_ref r90
    r94 = r93 >= 0 :: signed
    if not r94 goto L30 (error at <module>:32) else goto L29 :: bool
L29:
    return 1
L30:
    r95 = <error> :: None
    return r95
L31:
    dec_ref r32
    goto L30
L32:
    dec_ref r46
    goto L30
L33:
    dec_ref r46
    dec_ref r50
    goto L30
L34:
    dec_ref r46
    dec_ref r50
    dec_ref r53
    goto L30
L35:
    dec_ref r46
    dec_ref r54
    goto L30
L36:
    dec_ref r71
    goto L30
L37:
    dec_ref r71
    dec_ref r74
    goto L30
L38:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    goto L30
L39:
    dec_ref r71
    dec_ref r74
    dec_ref r77
    dec_ref r80
    goto L30
L40:
    dec_ref r71
    dec_ref r74
    dec_ref r81
    goto L30

def abbr(value, limit):
    value :: object
    limit :: int
    r0, rep :: str
    r1 :: native_int
    r2 :: bit
    r3 :: short_int
    r4 :: native_int
    r5 :: bit
    r6 :: native_int
    r7, r8, r9 :: bit
    r10 :: native_int
    r11 :: bit
    r12 :: native_int
    r13, r14, r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: int
    r24 :: object
    r25, r26, r27, r28 :: str
L0:
    if is_error(limit) goto L1 else goto L22
L1:
    limit = 158
L2:
    r0 = PyObject_Repr(value)
    if is_error(r0) goto L23 (error at abbr:11) else goto L3
L3:
    rep = r0
    r1 = CPyStr_Size_size_t(rep)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at abbr:13) else goto L4 :: bool
L4:
    r3 = r1 << 1
    r4 = r3 & 1
    r5 = r4 != 0
    if r5 goto L6 else goto L5 :: bool
L5:
    r6 = limit & 1
    r7 = r6 != 0
    if r7 goto L6 else goto L7 :: bool
L6:
    r8 = CPyTagged_IsLt_(limit, r3)
    if r8 goto L8 else goto L25 :: bool
L7:
    r9 = r3 > limit :: signed
    if r9 goto L8 else goto L25 :: bool
L8:
    r10 = limit & 1
    r11 = r10 != 0
    if r11 goto L10 else goto L9 :: bool
L9:
    r12 = 6 & 1
    r13 = r12 != 0
    if r13 goto L10 else goto L11 :: bool
L10:
    r14 = CPyTagged_IsLt_(limit, 6)
    if r14 goto L26 else goto L16 :: bool
L11:
    r15 = limit < 6 :: signed
    if r15 goto L26 else goto L16 :: bool
L12:
    r16 = 'Abbreviation limit may not be less than 3'
    r17 = builtins :: module
    r18 = 'ValueError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L21 (error at abbr:15) else goto L13
L13:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L21 (error at abbr:15) else goto L14
L14:
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L21 (error at abbr:15) else goto L15 :: bool
L15:
    unreachable
L16:
    r23 = CPyTagged_Subtract(limit, 6)
    dec_ref limit :: int
    r24 = CPyStr_GetSlice(rep, 0, r23)
    dec_ref rep
    dec_ref r23 :: int
    if is_error(r24) goto L21 (error at abbr:17) else goto L17
L17:
    r25 = cast(str, r24)
    if is_error(r25) goto L21 (error at abbr:17) else goto L18
L18:
    r26 = '...'
    r27 = PyUnicode_Concat(r25, r26)
    dec_ref r25
    if is_error(r27) goto L21 (error at abbr:17) else goto L19
L19:
    rep = r27
L20:
    return rep
L21:
    r28 = <error> :: str
    return r28
L22:
    inc_ref limit :: int
    goto L2
L23:
    dec_ref limit :: int
    goto L21
L24:
    dec_ref limit :: int
    dec_ref rep
    goto L21
L25:
    dec_ref limit :: int
    goto L20
L26:
    dec_ref limit :: int
    dec_ref rep
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any',)
    r6 = 'typing'
    r7 = faster_eth_abi.utils.string.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: str
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: bool
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: bool
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L31 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L31 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ABICodec',)
    r10 = 'faster_eth_abi.codec'
    r11 = faster_eth_abi.abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L31 (error at <module>:5) else goto L5
L5:
    faster_eth_abi.codec = r12 :: module
    dec_ref r12
    r13 = ('registry',)
    r14 = 'faster_eth_abi.registry'
    r15 = faster_eth_abi.abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L31 (error at <module>:8) else goto L6
L6:
    faster_eth_abi.registry = r16 :: module
    dec_ref r16
    r17 = faster_eth_abi.abi.globals :: static
    r18 = 'registry'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L31 (error at <module>:12) else goto L7
L7:
    r20 = faster_eth_abi.abi.globals :: static
    r21 = 'ABICodec'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L32 (error at <module>:12) else goto L8
L8:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L32 (error at <module>:12) else goto L9
L9:
    dec_ref r19
    faster_eth_abi.abi.default_codec = r25 :: static
    r26 = faster_eth_abi.abi.globals :: static
    r27 = 'default_codec'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L31 (error at <module>:12) else goto L10 :: bool
L10:
    r30 = faster_eth_abi.abi.default_codec :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "default_codec" was not set')
    if not r31 goto L31 (error at <module>:14) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = 'encode'
    r33 = CPyObject_GetAttr(r30, r32)
    if is_error(r33) goto L31 (error at <module>:14) else goto L14
L14:
    faster_eth_abi.abi.encode = r33 :: static
    r34 = faster_eth_abi.abi.globals :: static
    r35 = 'encode'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L31 (error at <module>:14) else goto L15 :: bool
L15:
    r38 = faster_eth_abi.abi.default_codec :: static
    if is_error(r38) goto L16 else goto L18
L16:
    r39 = raise NameError('value for final name "default_codec" was not set')
    if not r39 goto L31 (error at <module>:15) else goto L17 :: bool
L17:
    unreachable
L18:
    r40 = 'decode'
    r41 = CPyObject_GetAttr(r38, r40)
    if is_error(r41) goto L31 (error at <module>:15) else goto L19
L19:
    faster_eth_abi.abi.decode = r41 :: static
    r42 = faster_eth_abi.abi.globals :: static
    r43 = 'decode'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L31 (error at <module>:15) else goto L20 :: bool
L20:
    r46 = faster_eth_abi.abi.default_codec :: static
    if is_error(r46) goto L21 else goto L23
L21:
    r47 = raise NameError('value for final name "default_codec" was not set')
    if not r47 goto L31 (error at <module>:16) else goto L22 :: bool
L22:
    unreachable
L23:
    r48 = 'is_encodable'
    r49 = CPyObject_GetAttr(r46, r48)
    if is_error(r49) goto L31 (error at <module>:16) else goto L24
L24:
    faster_eth_abi.abi.is_encodable = r49 :: static
    r50 = faster_eth_abi.abi.globals :: static
    r51 = 'is_encodable'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L31 (error at <module>:16) else goto L25 :: bool
L25:
    r54 = faster_eth_abi.abi.default_codec :: static
    if is_error(r54) goto L26 else goto L28
L26:
    r55 = raise NameError('value for final name "default_codec" was not set')
    if not r55 goto L31 (error at <module>:17) else goto L27 :: bool
L27:
    unreachable
L28:
    r56 = 'is_encodable_type'
    r57 = CPyObject_GetAttr(r54, r56)
    if is_error(r57) goto L31 (error at <module>:17) else goto L29
L29:
    faster_eth_abi.abi.is_encodable_type = r57 :: static
    r58 = faster_eth_abi.abi.globals :: static
    r59 = 'is_encodable_type'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L31 (error at <module>:17) else goto L30 :: bool
L30:
    return 1
L31:
    r62 = <error> :: None
    return r62
L32:
    dec_ref r19
    goto L31

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L4 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    return 1
L4:
    r5 = <error> :: None
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: int
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: int
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: int
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = faster_eth_abi.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = object 115792089237316195423570985008687907853269984665640564039457584007913129639936
    r10 = faster_eth_abi.constants.globals :: static
    r11 = 'TT256'
    inc_ref r9 :: int
    r12 = box(int, r9)
    r13 = CPyDict_SetItem(r10, r11, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L8 (error at <module>:5) else goto L5 :: bool
L5:
    r15 = object 115792089237316195423570985008687907853269984665640564039457584007913129639935
    r16 = faster_eth_abi.constants.globals :: static
    r17 = 'TT256M1'
    inc_ref r15 :: int
    r18 = box(int, r15)
    r19 = CPyDict_SetItem(r16, r17, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L8 (error at <module>:6) else goto L6 :: bool
L6:
    r21 = object 57896044618658097711785492504343953926634992332820282019728792003956564819968
    r22 = faster_eth_abi.constants.globals :: static
    r23 = 'TT255'
    inc_ref r21 :: int
    r24 = box(int, r21)
    r25 = CPyDict_SetItem(r22, r23, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L8 (error at <module>:7) else goto L7 :: bool
L7:
    return 1
L8:
    r27 = <error> :: None
    return r27

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L5 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('get_abi_strategy',)
    r6 = 'faster_eth_abi.tools._strategies'
    r7 = faster_eth_abi.tools.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L5 (error at <module>:1) else goto L4
L4:
    faster_eth_abi.tools._strategies = r8 :: module
    dec_ref r8
    return 1
L5:
    r9 = <error> :: None
    return r9

def ceil32(x):
    x, r0 :: int
    r1 :: bit
    r2, r3, r4, r5 :: int
L0:
    r0 = CPyTagged_Remainder(x, 64)
    if is_error(r0) goto L5 (error at ceil32:21) else goto L1
L1:
    r1 = r0 == 0
    if r1 goto L6 else goto L3 :: bool
L2:
    inc_ref x :: int
    r2 = x
    goto L4
L3:
    r3 = CPyTagged_Add(x, 64)
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    dec_ref r0 :: int
    r2 = r4
L4:
    return r2
L5:
    r5 = <error> :: int
    return r5
L6:
    dec_ref r0 :: int
    goto L2

def compute_unsigned_integer_bounds(num_bits):
    num_bits :: int
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4, bounds :: union[tuple[int, int], None]
    r5 :: object
    r6 :: bit
    r7, r8, r9, r10, r11 :: object
    r12 :: tuple[int, object]
    r13 :: object
    r14 :: tuple[int, int]
    r15 :: dict
    r16 :: bool
    r17, r18 :: object
    r19 :: i32
    r20 :: bit
    r21, r22 :: tuple[int, int]
L0:
    r0 = faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_unsigned_integer_bounds_cache" was not set')
    if not r1 goto L15 (error at compute_unsigned_integer_bounds:29) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    r2 = box(int, num_bits)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r2
    if is_error(r3) goto L15 (error at compute_unsigned_integer_bounds:29) else goto L4
L4:
    r4 = cast(union[tuple[int, int], None], r3)
    if is_error(r4) goto L15 (error at compute_unsigned_integer_bounds:29) else goto L5
L5:
    bounds = r4
    r5 = load_address _Py_NoneStruct
    r6 = bounds == r5
    if r6 goto L16 else goto L13 :: bool
L6:
    r7 = object 2
    inc_ref num_bits :: int
    r8 = box(int, num_bits)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L15 (error at compute_unsigned_integer_bounds:31) else goto L7
L7:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L15 (error at compute_unsigned_integer_bounds:31) else goto L8
L8:
    r12 = (0, r11)
    r13 = box(tuple[int, object], r12)
    bounds = r13
    r14 = unbox(tuple[int, int], bounds)
    if is_error(r14) goto L17 (error at compute_unsigned_integer_bounds:32) else goto L9
L9:
    r15 = faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache :: static
    if is_error(r15) goto L18 else goto L12
L10:
    r16 = raise NameError('value for final name "_unsigned_integer_bounds_cache" was not set')
    if not r16 goto L15 (error at compute_unsigned_integer_bounds:32) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref num_bits :: int
    r17 = box(int, num_bits)
    r18 = box(tuple[int, int], r14)
    r19 = CPyDict_SetItem(r15, r17, r18)
    dec_ref r17
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L17 (error at compute_unsigned_integer_bounds:32) else goto L13 :: bool
L13:
    r21 = unbox(tuple[int, int], bounds)
    dec_ref bounds
    if is_error(r21) goto L15 (error at compute_unsigned_integer_bounds:33) else goto L14
L14:
    return r21
L15:
    r22 = <error> :: tuple[int, int]
    return r22
L16:
    dec_ref bounds
    goto L6
L17:
    dec_ref bounds
    goto L15
L18:
    dec_ref bounds
    dec_ref r14
    goto L10

def compute_signed_integer_bounds(num_bits):
    num_bits :: int
    r0 :: dict
    r1 :: bool
    r2, r3 :: object
    r4, bounds :: union[tuple[int, int], None]
    r5 :: object
    r6 :: bit
    r7 :: int
    r8, r9, r10, r11, r12, r13 :: object
    r14 :: tuple[object, object]
    r15 :: object
    r16 :: tuple[int, int]
    r17 :: dict
    r18 :: bool
    r19, r20 :: object
    r21 :: i32
    r22 :: bit
    r23, r24 :: tuple[int, int]
L0:
    r0 = faster_eth_abi.utils.numeric._signed_integer_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_signed_integer_bounds_cache" was not set')
    if not r1 goto L16 (error at compute_signed_integer_bounds:40) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    r2 = box(int, num_bits)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r2
    if is_error(r3) goto L16 (error at compute_signed_integer_bounds:40) else goto L4
L4:
    r4 = cast(union[tuple[int, int], None], r3)
    if is_error(r4) goto L16 (error at compute_signed_integer_bounds:40) else goto L5
L5:
    bounds = r4
    r5 = load_address _Py_NoneStruct
    r6 = bounds == r5
    if r6 goto L17 else goto L14 :: bool
L6:
    r7 = CPyTagged_Subtract(num_bits, 2)
    r8 = object 2
    r9 = box(int, r7)
    r10 = CPyNumber_Power(r8, r9)
    dec_ref r9
    if is_error(r10) goto L16 (error at compute_signed_integer_bounds:42) else goto L7
L7:
    r11 = PyNumber_Negative(r10)
    if is_error(r11) goto L18 (error at compute_signed_integer_bounds:43) else goto L8
L8:
    r12 = object 1
    r13 = PyNumber_Subtract(r10, r12)
    dec_ref r10
    if is_error(r13) goto L19 (error at compute_signed_integer_bounds:44) else goto L9
L9:
    r14 = (r11, r13)
    r15 = box(tuple[object, object], r14)
    bounds = r15
    r16 = unbox(tuple[int, int], bounds)
    if is_error(r16) goto L20 (error at compute_signed_integer_bounds:46) else goto L10
L10:
    r17 = faster_eth_abi.utils.numeric._signed_integer_bounds_cache :: static
    if is_error(r17) goto L21 else goto L13
L11:
    r18 = raise NameError('value for final name "_signed_integer_bounds_cache" was not set')
    if not r18 goto L16 (error at compute_signed_integer_bounds:46) else goto L12 :: bool
L12:
    unreachable
L13:
    inc_ref num_bits :: int
    r19 = box(int, num_bits)
    r20 = box(tuple[int, int], r16)
    r21 = CPyDict_SetItem(r17, r19, r20)
    dec_ref r19
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L20 (error at compute_signed_integer_bounds:46) else goto L14 :: bool
L14:
    r23 = unbox(tuple[int, int], bounds)
    dec_ref bounds
    if is_error(r23) goto L16 (error at compute_signed_integer_bounds:47) else goto L15
L15:
    return r23
L16:
    r24 = <error> :: tuple[int, int]
    return r24
L17:
    dec_ref bounds
    goto L6
L18:
    dec_ref r10
    goto L16
L19:
    dec_ref r11
    goto L16
L20:
    dec_ref bounds
    goto L16
L21:
    dec_ref bounds
    dec_ref r16
    goto L11

def compute_unsigned_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0 :: dict
    r1 :: bool
    r2 :: tuple[int, int]
    r3, r4 :: object
    upper :: union[object, None]
    r5 :: object
    r6 :: bit
    r7, r8, r9, r10, r11, r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16 :: object[1]
    r17 :: object_ptr
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: bool
    r28 :: object
    r29 :: bool
    r30 :: object[1]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: bool
    r35 :: int
    r36, r37, r38 :: object
    r39, r40 :: tuple[object, object, object]
    r41, r42, r43 :: object
    r44 :: object[4]
    r45 :: object_ptr
    r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: bool
    r50 :: bit
    r51, r52, r53 :: tuple[object, object, object]
    r54 :: object
    r55 :: object[4]
    r56 :: object_ptr
    r57 :: object
    r58 :: bit
    r59 :: dict
    r60 :: bool
    r61 :: tuple[int, int]
    r62 :: object
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: bool
    r67 :: tuple[object, union[object, None]]
    r68 :: tuple[object, object]
L0:
    r0 = faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_unsigned_fixed_bounds_cache" was not set')
    if not r1 goto L56 (error at compute_unsigned_fixed_bounds:57) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r2 = (num_bits, frac_places)
    r3 = box(tuple[int, int], r2)
    r4 = CPyDict_GetWithNone(r0, r3)
    dec_ref r3
    if is_error(r4) goto L56 (error at compute_unsigned_fixed_bounds:57) else goto L4
L4:
    upper = r4
    r5 = load_address _Py_NoneStruct
    r6 = upper == r5
    if r6 goto L5 else goto L52 :: bool
L5:
    r7 = object 2
    inc_ref num_bits :: int
    r8 = box(int, num_bits)
    r9 = CPyNumber_Power(r7, r8)
    dec_ref r8
    if is_error(r9) goto L57 (error at compute_unsigned_fixed_bounds:59) else goto L6
L6:
    r10 = object 1
    r11 = PyNumber_Subtract(r9, r10)
    dec_ref r9
    if is_error(r11) goto L57 (error at compute_unsigned_fixed_bounds:59) else goto L7
L7:
    r12 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r12) goto L58 else goto L10
L8:
    r13 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r13 goto L56 (error at compute_unsigned_fixed_bounds:61) else goto L9 :: bool
L9:
    unreachable
L10:
    r14 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r14) goto L59 else goto L13
L11:
    r15 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r15 goto L56 (error at compute_unsigned_fixed_bounds:61) else goto L12 :: bool
L12:
    unreachable
L13:
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r14, r17, 1, 0)
    if is_error(r18) goto L60 (error at compute_unsigned_fixed_bounds:61) else goto L14
L14:
    r19 = CPy_TYPE(r18)
    r20 = '__exit__'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L61 (error at compute_unsigned_fixed_bounds:61) else goto L15
L15:
    r22 = '__enter__'
    r23 = CPyObject_GetAttr(r19, r22)
    dec_ref r19
    if is_error(r23) goto L62 (error at compute_unsigned_fixed_bounds:61) else goto L16
L16:
    r24 = [r18]
    r25 = load_address r24
    r26 = PyObject_Vectorcall(r23, r25, 1, 0)
    dec_ref r23
    if is_error(r26) goto L62 (error at compute_unsigned_fixed_bounds:61) else goto L63
L17:
    r27 = 1
L18:
    r28 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r28) goto L64 else goto L21
L19:
    r29 = raise NameError('value for final name "Decimal" was not set')
    if not r29 goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L65 :: bool
L20:
    unreachable
L21:
    r30 = [r11]
    r31 = load_address r30
    r32 = PyObject_Vectorcall(r28, r31, 1, 0)
    if is_error(r32) goto L66 (error at compute_unsigned_fixed_bounds:62) else goto L22
L22:
    dec_ref r11
    r33 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r33) goto L67 else goto L25
L23:
    r34 = raise NameError('value for final name "TEN" was not set')
    if not r34 goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L68 :: bool
L24:
    unreachable
L25:
    r35 = CPyTagged_Negate(frac_places)
    r36 = box(int, r35)
    r37 = CPyNumber_Power(r33, r36)
    dec_ref r36
    if is_error(r37) goto L69 (error at compute_unsigned_fixed_bounds:62) else goto L26
L26:
    r38 = PyNumber_Multiply(r32, r37)
    dec_ref r32
    dec_ref r37
    if is_error(r38) goto L28 (error at compute_unsigned_fixed_bounds:62) else goto L70
L27:
    upper = r38
    goto L36
L28:
    r39 = CPy_CatchError()
    r27 = 0
    r40 = CPy_GetExcInfo()
    r41 = r40[0]
    r42 = r40[1]
    r43 = r40[2]
    dec_ref r40
    r44 = [r18, r41, r42, r43]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r21, r45, 4, 0)
    if is_error(r46) goto L71 (error at compute_unsigned_fixed_bounds:61) else goto L29
L29:
    dec_ref r41
    dec_ref r42
    dec_ref r43
    r47 = PyObject_IsTrue(r46)
    dec_ref r46
    r48 = r47 >= 0 :: signed
    if not r48 goto L34 (error at compute_unsigned_fixed_bounds:61) else goto L30 :: bool
L30:
    r49 = truncate r47: i32 to builtins.bool
    if r49 goto L33 else goto L31 :: bool
L31:
    CPy_Reraise()
    if not 0 goto L34 else goto L72 :: bool
L32:
    unreachable
L33:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    goto L36
L34:
    CPy_RestoreExcInfo(r39)
    dec_ref r39
    r50 = CPy_KeepPropagating()
    if not r50 goto L37 else goto L73 :: bool
L35:
    unreachable
L36:
    r51 = <error> :: tuple[object, object, object]
    r52 = r51
    goto L38
L37:
    r53 = CPy_CatchError()
    r52 = r53
L38:
    if r27 goto L39 else goto L74 :: bool
L39:
    r54 = load_address _Py_NoneStruct
    r55 = [r18, r54, r54, r54]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r21, r56, 4, 0)
    dec_ref r21
    if is_error(r57) goto L75 (error at compute_unsigned_fixed_bounds:61) else goto L76
L40:
    dec_ref r18
L41:
    if is_error(r52) goto L48 else goto L77
L42:
    CPy_Reraise()
    if not 0 goto L44 else goto L78 :: bool
L43:
    unreachable
L44:
    if is_error(r52) goto L46 else goto L45
L45:
    CPy_RestoreExcInfo(r52)
    xdec_ref r52
L46:
    r58 = CPy_KeepPropagating()
    if not r58 goto L56 else goto L47 :: bool
L47:
    unreachable
L48:
    r59 = faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache :: static
    if is_error(r59) goto L79 else goto L51
L49:
    r60 = raise NameError('value for final name "_unsigned_fixed_bounds_cache" was not set')
    if not r60 goto L56 (error at compute_unsigned_fixed_bounds:64) else goto L50 :: bool
L50:
    unreachable
L51:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r61 = (num_bits, frac_places)
    r62 = box(tuple[int, int], r61)
    r63 = CPyDict_SetItem(r59, r62, upper)
    dec_ref r62
    r64 = r63 >= 0 :: signed
    if not r64 goto L57 (error at compute_unsigned_fixed_bounds:64) else goto L52 :: bool
L52:
    r65 = faster_eth_abi.utils.numeric.ZERO :: static
    if is_error(r65) goto L80 else goto L55
L53:
    r66 = raise NameError('value for final name "ZERO" was not set')
    if not r66 goto L56 (error at compute_unsigned_fixed_bounds:66) else goto L54 :: bool
L54:
    unreachable
L55:
    inc_ref r65
    r67 = (r65, upper)
    return r67
L56:
    r68 = <error> :: tuple[object, object]
    return r68
L57:
    dec_ref upper
    goto L56
L58:
    dec_ref upper
    dec_ref r11
    goto L8
L59:
    dec_ref upper
    dec_ref r11
    goto L11
L60:
    dec_ref upper
    dec_ref r11
    goto L56
L61:
    dec_ref upper
    dec_ref r11
    dec_ref r18
    dec_ref r19
    goto L56
L62:
    dec_ref upper
    dec_ref r11
    dec_ref r18
    dec_ref r21
    goto L56
L63:
    dec_ref r26
    goto L17
L64:
    dec_ref r11
    goto L19
L65:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L20
L66:
    dec_ref r11
    goto L28
L67:
    dec_ref r32
    goto L23
L68:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L24
L69:
    dec_ref r32
    goto L28
L70:
    dec_ref upper
    goto L27
L71:
    dec_ref r41
    dec_ref r42
    dec_ref r43
    goto L34
L72:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    dec_ref r39
    goto L32
L73:
    dec_ref upper
    dec_ref r18
    dec_ref r21
    goto L35
L74:
    dec_ref r18
    dec_ref r21
    goto L41
L75:
    dec_ref upper
    dec_ref r18
    goto L44
L76:
    dec_ref r57
    goto L40
L77:
    dec_ref upper
    goto L42
L78:
    xdec_ref r52
    goto L43
L79:
    dec_ref upper
    goto L49
L80:
    dec_ref upper
    goto L53

def compute_signed_fixed_bounds(num_bits, frac_places):
    num_bits, frac_places :: int
    r0, lower, r1, upper :: object
    r2 :: dict
    r3 :: bool
    r4 :: tuple[int, int]
    r5, r6 :: object
    r7, bounds :: union[tuple[object, object], None]
    r8 :: object
    r9 :: bit
    r10 :: tuple[int, int]
    r11, r12, r13, r14 :: int
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: bool
    r31 :: object
    r32 :: bool
    r33 :: int
    r34, r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41, r42, r43 :: object
    r44 :: bool
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48, r49 :: object
    r50, r51 :: tuple[object, object, object]
    r52, r53, r54 :: object
    r55 :: object[4]
    r56 :: object_ptr
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: bit
    r62, r63, r64 :: tuple[object, object, object]
    r65 :: object
    r66 :: object[4]
    r67 :: object_ptr
    r68 :: object
    r69 :: bit
    r70, r71 :: bool
    r72 :: tuple[object, object]
    r73 :: object
    r74 :: tuple[object, object]
    r75 :: dict
    r76 :: bool
    r77 :: tuple[int, int]
    r78, r79 :: object
    r80 :: i32
    r81 :: bit
    r82, r83 :: tuple[object, object]
L0:
    r0 = <error> :: object
    lower = r0
    r1 = <error> :: object
    upper = r1
    r2 = faster_eth_abi.utils.numeric._signed_fixed_bounds_cache :: static
    if is_error(r2) goto L67 else goto L3
L1:
    r3 = raise NameError('value for final name "_signed_fixed_bounds_cache" was not set')
    if not r3 goto L66 (error at compute_signed_fixed_bounds:78) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r4 = (num_bits, frac_places)
    r5 = box(tuple[int, int], r4)
    r6 = CPyDict_GetWithNone(r2, r5)
    dec_ref r5
    if is_error(r6) goto L68 (error at compute_signed_fixed_bounds:78) else goto L4
L4:
    r7 = cast(union[tuple[object, object], None], r6)
    if is_error(r7) goto L68 (error at compute_signed_fixed_bounds:78) else goto L5
L5:
    bounds = r7
    r8 = load_address _Py_NoneStruct
    r9 = bounds == r8
    if r9 goto L69 else goto L70 :: bool
L6:
    r10 = compute_signed_integer_bounds(num_bits)
    if is_error(r10) goto L68 (error at compute_signed_fixed_bounds:80) else goto L7
L7:
    r11 = borrow r10[0]
    r12 = borrow r10[1]
    r13 = unborrow r11
    r14 = unborrow r12
    r15 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r15) goto L71 else goto L10
L8:
    r16 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r16 goto L66 (error at compute_signed_fixed_bounds:82) else goto L9 :: bool
L9:
    unreachable
L10:
    r17 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r17) goto L72 else goto L13
L11:
    r18 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r18 goto L66 (error at compute_signed_fixed_bounds:82) else goto L12 :: bool
L12:
    unreachable
L13:
    r19 = [r15]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L73 (error at compute_signed_fixed_bounds:82) else goto L14
L14:
    r22 = CPy_TYPE(r21)
    r23 = '__exit__'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L74 (error at compute_signed_fixed_bounds:82) else goto L15
L15:
    r25 = '__enter__'
    r26 = CPyObject_GetAttr(r22, r25)
    dec_ref r22
    if is_error(r26) goto L75 (error at compute_signed_fixed_bounds:82) else goto L16
L16:
    r27 = [r21]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L75 (error at compute_signed_fixed_bounds:82) else goto L76
L17:
    r30 = 1
L18:
    r31 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r31) goto L77 else goto L21
L19:
    r32 = raise NameError('value for final name "TEN" was not set')
    if not r32 goto L33 (error at compute_signed_fixed_bounds:83) else goto L78 :: bool
L20:
    unreachable
L21:
    r33 = CPyTagged_Negate(frac_places)
    r34 = box(int, r33)
    r35 = CPyNumber_Power(r31, r34)
    dec_ref r34
    if is_error(r35) goto L79 (error at compute_signed_fixed_bounds:83) else goto L22
L22:
    r36 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r36) goto L80 else goto L25
L23:
    r37 = raise NameError('value for final name "Decimal" was not set')
    if not r37 goto L33 (error at compute_signed_fixed_bounds:84) else goto L81 :: bool
L24:
    unreachable
L25:
    r38 = box(int, r13)
    r39 = [r38]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r36, r40, 1, 0)
    if is_error(r41) goto L82 (error at compute_signed_fixed_bounds:84) else goto L26
L26:
    dec_ref r38
    r42 = PyNumber_Multiply(r41, r35)
    dec_ref r41
    if is_error(r42) goto L83 (error at compute_signed_fixed_bounds:84) else goto L84
L27:
    lower = r42
    r43 = faster_eth_abi.utils.numeric.Decimal :: static
    if is_error(r43) goto L85 else goto L30
L28:
    r44 = raise NameError('value for final name "Decimal" was not set')
    if not r44 goto L33 (error at compute_signed_fixed_bounds:85) else goto L86 :: bool
L29:
    unreachable
L30:
    r45 = box(int, r14)
    r46 = [r45]
    r47 = load_address r46
    r48 = PyObject_Vectorcall(r43, r47, 1, 0)
    if is_error(r48) goto L87 (error at compute_signed_fixed_bounds:85) else goto L31
L31:
    dec_ref r45
    r49 = PyNumber_Multiply(r48, r35)
    dec_ref r48
    dec_ref r35
    if is_error(r49) goto L33 (error at compute_signed_fixed_bounds:85) else goto L88
L32:
    upper = r49
    goto L41
L33:
    r50 = CPy_CatchError()
    r30 = 0
    r51 = CPy_GetExcInfo()
    r52 = r51[0]
    r53 = r51[1]
    r54 = r51[2]
    dec_ref r51
    r55 = [r21, r52, r53, r54]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r24, r56, 4, 0)
    if is_error(r57) goto L89 (error at compute_signed_fixed_bounds:82) else goto L34
L34:
    dec_ref r52
    dec_ref r53
    dec_ref r54
    r58 = PyObject_IsTrue(r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L39 (error at compute_signed_fixed_bounds:82) else goto L35 :: bool
L35:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L38 else goto L36 :: bool
L36:
    CPy_Reraise()
    if not 0 goto L39 else goto L90 :: bool
L37:
    unreachable
L38:
    CPy_RestoreExcInfo(r50)
    dec_ref r50
    goto L41
L39:
    CPy_RestoreExcInfo(r50)
    dec_ref r50
    r61 = CPy_KeepPropagating()
    if not r61 goto L42 else goto L91 :: bool
L40:
    unreachable
L41:
    r62 = <error> :: tuple[object, object, object]
    r63 = r62
    goto L43
L42:
    r64 = CPy_CatchError()
    r63 = r64
L43:
    if r30 goto L44 else goto L92 :: bool
L44:
    r65 = load_address _Py_NoneStruct
    r66 = [r21, r65, r65, r65]
    r67 = load_address r66
    r68 = PyObject_Vectorcall(r24, r67, 4, 0)
    dec_ref r24
    if is_error(r68) goto L93 (error at compute_signed_fixed_bounds:82) else goto L94
L45:
    dec_ref r21
L46:
    if is_error(r63) goto L53 else goto L95
L47:
    CPy_Reraise()
    if not 0 goto L49 else goto L96 :: bool
L48:
    unreachable
L49:
    if is_error(r63) goto L51 else goto L50
L50:
    CPy_RestoreExcInfo(r63)
    xdec_ref r63
L51:
    r69 = CPy_KeepPropagating()
    if not r69 goto L66 else goto L52 :: bool
L52:
    unreachable
L53:
    if is_error(lower) goto L97 else goto L56
L54:
    r70 = raise UnboundLocalError('local variable "lower" referenced before assignment')
    if not r70 goto L66 (error at compute_signed_fixed_bounds:87) else goto L55 :: bool
L55:
    unreachable
L56:
    if is_error(upper) goto L98 else goto L59
L57:
    r71 = raise UnboundLocalError('local variable "upper" referenced before assignment')
    if not r71 goto L66 (error at compute_signed_fixed_bounds:87) else goto L58 :: bool
L58:
    unreachable
L59:
    r72 = (lower, upper)
    r73 = box(tuple[object, object], r72)
    bounds = r73
    r74 = unbox(tuple[object, object], bounds)
    if is_error(r74) goto L99 (error at compute_signed_fixed_bounds:88) else goto L60
L60:
    r75 = faster_eth_abi.utils.numeric._signed_fixed_bounds_cache :: static
    if is_error(r75) goto L100 else goto L63
L61:
    r76 = raise NameError('value for final name "_signed_fixed_bounds_cache" was not set')
    if not r76 goto L66 (error at compute_signed_fixed_bounds:88) else goto L62 :: bool
L62:
    unreachable
L63:
    inc_ref num_bits :: int
    inc_ref frac_places :: int
    r77 = (num_bits, frac_places)
    r78 = box(tuple[int, int], r77)
    r79 = box(tuple[object, object], r74)
    r80 = CPyDict_SetItem(r75, r78, r79)
    dec_ref r78
    dec_ref r79
    r81 = r80 >= 0 :: signed
    if not r81 goto L99 (error at compute_signed_fixed_bounds:88) else goto L64 :: bool
L64:
    r82 = unbox(tuple[object, object], bounds)
    dec_ref bounds
    if is_error(r82) goto L66 (error at compute_signed_fixed_bounds:90) else goto L65
L65:
    return r82
L66:
    r83 = <error> :: tuple[object, object]
    return r83
L67:
    xdec_ref lower
    xdec_ref upper
    goto L1
L68:
    xdec_ref lower
    xdec_ref upper
    goto L66
L69:
    dec_ref bounds
    goto L6
L70:
    xdec_ref lower
    xdec_ref upper
    goto L64
L71:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L8
L72:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L11
L73:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L66
L74:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r21
    dec_ref r22
    goto L66
L75:
    xdec_ref lower
    xdec_ref upper
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r21
    dec_ref r24
    goto L66
L76:
    dec_ref r29
    goto L17
L77:
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L19
L78:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L20
L79:
    dec_ref r13 :: int
    dec_ref r14 :: int
    goto L33
L80:
    dec_ref r13 :: int
    dec_ref r14 :: int
    dec_ref r35
    goto L23
L81:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L24
L82:
    dec_ref r14 :: int
    dec_ref r35
    dec_ref r38
    goto L33
L83:
    dec_ref r14 :: int
    dec_ref r35
    goto L33
L84:
    xdec_ref lower
    goto L27
L85:
    dec_ref r14 :: int
    dec_ref r35
    goto L28
L86:
    dec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L29
L87:
    dec_ref r35
    dec_ref r45
    goto L33
L88:
    xdec_ref upper
    goto L32
L89:
    dec_ref r52
    dec_ref r53
    dec_ref r54
    goto L39
L90:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    dec_ref r50
    goto L37
L91:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    dec_ref r24
    goto L40
L92:
    dec_ref r21
    dec_ref r24
    goto L46
L93:
    xdec_ref lower
    xdec_ref upper
    dec_ref r21
    goto L49
L94:
    dec_ref r68
    goto L45
L95:
    xdec_ref lower
    xdec_ref upper
    goto L47
L96:
    xdec_ref r63
    goto L48
L97:
    xdec_ref upper
    goto L54
L98:
    xdec_ref lower
    goto L57
L99:
    dec_ref bounds
    goto L66
L100:
    dec_ref bounds
    dec_ref r74
    goto L61

def f_scale_places_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def f_scale_places_obj.__call__(__mypyc_self__, x):
    __mypyc_self__ :: faster_eth_abi.utils.numeric.f_scale_places_obj
    x :: object
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: bool
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: bool
    r17, r18, r19 :: object
    r20, r21 :: tuple[object, object, object]
    r22, r23, r24 :: object
    r25 :: object[4]
    r26 :: object_ptr
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: bit
    r32 :: object
    r33, r34 :: tuple[object, object, object]
    r35 :: object
    r36 :: tuple[object, object, object]
    r37 :: object
    r38 :: object[4]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42, r43 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L39 (error at f:107) else goto L1
L1:
    r1 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r1) goto L40 else goto L4
L2:
    r2 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r2 goto L39 (error at f:108) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r3) goto L41 else goto L7
L5:
    r4 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r4 goto L39 (error at f:108) else goto L6 :: bool
L6:
    unreachable
L7:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r3, r6, 1, 0)
    if is_error(r7) goto L42 (error at f:108) else goto L8
L8:
    r8 = CPy_TYPE(r7)
    r9 = '__exit__'
    r10 = CPyObject_GetAttr(r8, r9)
    if is_error(r10) goto L43 (error at f:108) else goto L9
L9:
    r11 = '__enter__'
    r12 = CPyObject_GetAttr(r8, r11)
    dec_ref r8
    if is_error(r12) goto L44 (error at f:108) else goto L10
L10:
    r13 = [r7]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L44 (error at f:108) else goto L45
L11:
    r16 = 1
L12:
    r17 = r0.scaling_factor
    dec_ref r0
    if is_error(r17) goto L15 (error at f:109) else goto L13
L13:
    r18 = PyNumber_Multiply(x, r17)
    dec_ref r17
    if is_error(r18) goto L15 (error at f:109) else goto L14
L14:
    r19 = r18
    goto L24
L15:
    r20 = CPy_CatchError()
    r16 = 0
    r21 = CPy_GetExcInfo()
    r22 = r21[0]
    r23 = r21[1]
    r24 = r21[2]
    dec_ref r21
    r25 = [r7, r22, r23, r24]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r10, r26, 4, 0)
    if is_error(r27) goto L46 (error at f:108) else goto L16
L16:
    dec_ref r22
    dec_ref r23
    dec_ref r24
    r28 = PyObject_IsTrue(r27)
    dec_ref r27
    r29 = r28 >= 0 :: signed
    if not r29 goto L21 (error at f:108) else goto L17 :: bool
L17:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L20 else goto L18 :: bool
L18:
    CPy_Reraise()
    if not 0 goto L21 else goto L47 :: bool
L19:
    unreachable
L20:
    CPy_RestoreExcInfo(r20)
    dec_ref r20
    goto L23
L21:
    CPy_RestoreExcInfo(r20)
    dec_ref r20
    r31 = CPy_KeepPropagating()
    if not r31 goto L25 else goto L48 :: bool
L22:
    unreachable
L23:
    r32 = <error> :: object
    r19 = r32
L24:
    r33 = <error> :: tuple[object, object, object]
    r34 = r33
    goto L26
L25:
    r35 = <error> :: object
    r19 = r35
    r36 = CPy_CatchError()
    r34 = r36
L26:
    if r16 goto L27 else goto L49 :: bool
L27:
    r37 = load_address _Py_NoneStruct
    r38 = [r7, r37, r37, r37]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r10, r39, 4, 0)
    dec_ref r10
    if is_error(r40) goto L50 (error at f:108) else goto L51
L28:
    dec_ref r7
L29:
    if is_error(r34) goto L32 else goto L52
L30:
    CPy_Reraise()
    if not 0 goto L34 else goto L53 :: bool
L31:
    unreachable
L32:
    if is_error(r19) goto L38 else goto L33
L33:
    return r19
L34:
    if is_error(r34) goto L36 else goto L35
L35:
    CPy_RestoreExcInfo(r34)
    xdec_ref r34
L36:
    r41 = CPy_KeepPropagating()
    if not r41 goto L39 else goto L37 :: bool
L37:
    unreachable
L38:
    r42 = box(None, 1)
    inc_ref r42
    return r42
L39:
    r43 = <error> :: object
    return r43
L40:
    dec_ref r0
    goto L2
L41:
    dec_ref r0
    goto L5
L42:
    dec_ref r0
    goto L39
L43:
    dec_ref r0
    dec_ref r7
    dec_ref r8
    goto L39
L44:
    dec_ref r0
    dec_ref r7
    dec_ref r10
    goto L39
L45:
    dec_ref r15
    goto L11
L46:
    dec_ref r22
    dec_ref r23
    dec_ref r24
    goto L21
L47:
    dec_ref r7
    dec_ref r10
    dec_ref r20
    goto L19
L48:
    dec_ref r7
    dec_ref r10
    goto L22
L49:
    dec_ref r7
    dec_ref r10
    goto L29
L50:
    dec_ref r7
    xdec_ref r19
    goto L34
L51:
    dec_ref r40
    goto L28
L52:
    xdec_ref r19
    goto L30
L53:
    xdec_ref r34
    goto L31

def scale_places(places):
    places :: int
    r0 :: faster_eth_abi.utils.numeric.scale_places_env
    r1 :: object
    r2 :: bit
    r3, r4, r5 :: str
    r6 :: object
    r7, r8 :: str
    r9 :: object[3]
    r10 :: object_ptr
    r11 :: object
    r12, r13 :: str
    r14, r15 :: object
    r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22 :: list
    r23, r24, r25, r26, r27, r28 :: ptr
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: bool
    r40 :: object[1]
    r41 :: object_ptr
    r42, r43 :: object
    r44 :: str
    r45 :: object
    r46 :: str
    r47 :: object
    r48 :: object[1]
    r49 :: object_ptr
    r50 :: object
    r51 :: bool
    r52 :: object
    r53 :: bool
    r54 :: int
    r55, r56 :: object
    r57 :: bool
    r58, r59 :: tuple[object, object, object]
    r60, r61, r62 :: object
    r63 :: object[4]
    r64 :: object_ptr
    r65 :: object
    r66 :: i32
    r67 :: bit
    r68 :: bool
    r69 :: bit
    r70, r71, r72 :: tuple[object, object, object]
    r73 :: object
    r74 :: object[4]
    r75 :: object_ptr
    r76 :: object
    r77 :: bit
    r78 :: faster_eth_abi.utils.numeric.f_scale_places_obj
    r79 :: bool
    f :: object
    r80 :: native_int
    r81 :: bit
    r82 :: native_int
    r83, r84, r85 :: bit
    r86, r87, r88, r89, r90 :: str
    r91 :: int
    r92, r93, places_repr, r94, r95, r96 :: str
    r97 :: i32
    r98 :: bit
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: object
L0:
    r0 = scale_places_env()
    if is_error(r0) goto L62 (error at scale_places:93) else goto L1
L1:
    inc_ref places :: int
    r1 = box(int, places)
    r2 = PyLong_Check(r1)
    dec_ref r1
    if r2 goto L10 else goto L63 :: bool
L2:
    r3 = ''
    r4 = 'Argument `places` must be int.  Got value '
    r5 = '{:{}}'
    inc_ref places :: int
    r6 = box(int, places)
    r7 = ''
    r8 = 'format'
    r9 = [r5, r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775811, 0)
    if is_error(r11) goto L64 (error at scale_places:100) else goto L3
L3:
    dec_ref r6
    r12 = ' of type '
    r13 = '{:{}}'
    inc_ref places :: int
    r14 = box(int, places)
    r15 = CPy_TYPE(r14)
    dec_ref r14
    r16 = ''
    r17 = 'format'
    r18 = [r13, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L65 (error at scale_places:101) else goto L4
L4:
    dec_ref r15
    r21 = '.'
    r22 = PyList_New(5)
    if is_error(r22) goto L66 (error at scale_places:100) else goto L5
L5:
    r23 = get_element_ptr r22 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    inc_ref r4
    set_mem r24, r4 :: builtins.object*
    r25 = r24 + 8
    set_mem r25, r11 :: builtins.object*
    inc_ref r12
    r26 = r24 + 16
    set_mem r26, r12 :: builtins.object*
    r27 = r24 + 24
    set_mem r27, r20 :: builtins.object*
    inc_ref r21
    r28 = r24 + 32
    set_mem r28, r21 :: builtins.object*
    r29 = PyUnicode_Join(r3, r22)
    dec_ref r22
    if is_error(r29) goto L62 (error at scale_places:100) else goto L6
L6:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L67 (error at scale_places:99) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L67 (error at scale_places:99) else goto L8
L8:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L62 (error at scale_places:99) else goto L9 :: bool
L9:
    unreachable
L10:
    r36 = faster_eth_abi.utils.numeric.abi_decimal_context :: static
    if is_error(r36) goto L68 else goto L13
L11:
    r37 = raise NameError('value for final name "abi_decimal_context" was not set')
    if not r37 goto L62 (error at scale_places:104) else goto L12 :: bool
L12:
    unreachable
L13:
    r38 = faster_eth_abi.utils.numeric.decimal_localcontext :: static
    if is_error(r38) goto L69 else goto L16
L14:
    r39 = raise NameError('value for final name "decimal_localcontext" was not set')
    if not r39 goto L62 (error at scale_places:104) else goto L15 :: bool
L15:
    unreachable
L16:
    r40 = [r36]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r38, r41, 1, 0)
    if is_error(r42) goto L70 (error at scale_places:104) else goto L17
L17:
    r43 = CPy_TYPE(r42)
    r44 = '__exit__'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L71 (error at scale_places:104) else goto L18
L18:
    r46 = '__enter__'
    r47 = CPyObject_GetAttr(r43, r46)
    dec_ref r43
    if is_error(r47) goto L72 (error at scale_places:104) else goto L19
L19:
    r48 = [r42]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r47, r49, 1, 0)
    dec_ref r47
    if is_error(r50) goto L72 (error at scale_places:104) else goto L73
L20:
    r51 = 1
L21:
    r52 = faster_eth_abi.utils.numeric.TEN :: static
    if is_error(r52) goto L22 else goto L24
L22:
    r53 = raise NameError('value for final name "TEN" was not set')
    if not r53 goto L26 (error at scale_places:105) else goto L74 :: bool
L23:
    unreachable
L24:
    r54 = CPyTagged_Negate(places)
    r55 = box(int, r54)
    r56 = CPyNumber_Power(r52, r55)
    dec_ref r55
    if is_error(r56) goto L26 (error at scale_places:105) else goto L25
L25:
    r0.scaling_factor = r56; r57 = is_error
    if not r57 goto L26 (error at scale_places:105) else goto L34 :: bool
L26:
    r58 = CPy_CatchError()
    r51 = 0
    r59 = CPy_GetExcInfo()
    r60 = r59[0]
    r61 = r59[1]
    r62 = r59[2]
    dec_ref r59
    r63 = [r42, r60, r61, r62]
    r64 = load_address r63
    r65 = PyObject_Vectorcall(r45, r64, 4, 0)
    if is_error(r65) goto L75 (error at scale_places:104) else goto L27
L27:
    dec_ref r60
    dec_ref r61
    dec_ref r62
    r66 = PyObject_IsTrue(r65)
    dec_ref r65
    r67 = r66 >= 0 :: signed
    if not r67 goto L32 (error at scale_places:104) else goto L28 :: bool
L28:
    r68 = truncate r66: i32 to builtins.bool
    if r68 goto L31 else goto L29 :: bool
L29:
    CPy_Reraise()
    if not 0 goto L32 else goto L76 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    goto L34
L32:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    r69 = CPy_KeepPropagating()
    if not r69 goto L35 else goto L77 :: bool
L33:
    unreachable
L34:
    r70 = <error> :: tuple[object, object, object]
    r71 = r70
    goto L36
L35:
    r72 = CPy_CatchError()
    r71 = r72
L36:
    if r51 goto L37 else goto L78 :: bool
L37:
    r73 = load_address _Py_NoneStruct
    r74 = [r42, r73, r73, r73]
    r75 = load_address r74
    r76 = PyObject_Vectorcall(r45, r75, 4, 0)
    dec_ref r45
    if is_error(r76) goto L79 (error at scale_places:104) else goto L80
L38:
    dec_ref r42
L39:
    if is_error(r71) goto L46 else goto L81
L40:
    CPy_Reraise()
    if not 0 goto L42 else goto L82 :: bool
L41:
    unreachable
L42:
    if is_error(r71) goto L44 else goto L43
L43:
    CPy_RestoreExcInfo(r71)
    xdec_ref r71
L44:
    r77 = CPy_KeepPropagating()
    if not r77 goto L62 else goto L45 :: bool
L45:
    unreachable
L46:
    r78 = f_scale_places_obj()
    if is_error(r78) goto L70 (error at scale_places:107) else goto L47
L47:
    r78.__mypyc_env__ = r0; r79 = is_error
    if not r79 goto L83 (error at scale_places:107) else goto L48 :: bool
L48:
    f = r78
    r80 = places & 1
    r81 = r80 != 0
    if r81 goto L50 else goto L49 :: bool
L49:
    r82 = 0 & 1
    r83 = r82 != 0
    if r83 goto L50 else goto L51 :: bool
L50:
    r84 = CPyTagged_IsLt_(0, places)
    if r84 goto L52 else goto L55 :: bool
L51:
    r85 = places > 0 :: signed
    if r85 goto L52 else goto L55 :: bool
L52:
    r86 = 'Eneg'
    r87 = CPyTagged_Str(places)
    if is_error(r87) goto L84 (error at scale_places:111) else goto L53
L53:
    r88 = CPyStr_Build(2, r86, r87)
    dec_ref r87
    if is_error(r88) goto L84 (error at scale_places:111) else goto L54
L54:
    r89 = r88
    goto L58
L55:
    r90 = 'Epos'
    r91 = CPyTagged_Negate(places)
    r92 = CPyTagged_Str(r91)
    dec_ref r91 :: int
    if is_error(r92) goto L84 (error at scale_places:111) else goto L56
L56:
    r93 = CPyStr_Build(2, r90, r92)
    dec_ref r92
    if is_error(r93) goto L84 (error at scale_places:111) else goto L57
L57:
    r89 = r93
L58:
    places_repr = r89
    r94 = 'scale_by_'
    r95 = CPyStr_Build(2, r94, places_repr)
    dec_ref places_repr
    if is_error(r95) goto L84 (error at scale_places:112) else goto L59
L59:
    r96 = '__name__'
    r97 = PyObject_SetAttr(f, r96, r95)
    r98 = r97 >= 0 :: signed
    if not r98 goto L85 (error at scale_places:114) else goto L60 :: bool
L60:
    r99 = '__qualname__'
    r100 = PyObject_SetAttr(f, r99, r95)
    dec_ref r95
    r101 = r100 >= 0 :: signed
    if not r101 goto L84 (error at scale_places:115) else goto L61 :: bool
L61:
    return f
L62:
    r102 = <error> :: object
    return r102
L63:
    dec_ref r0
    goto L2
L64:
    dec_ref r6
    goto L62
L65:
    dec_ref r11
    dec_ref r15
    goto L62
L66:
    dec_ref r11
    dec_ref r20
    goto L62
L67:
    dec_ref r29
    goto L62
L68:
    dec_ref r0
    goto L11
L69:
    dec_ref r0
    goto L14
L70:
    dec_ref r0
    goto L62
L71:
    dec_ref r0
    dec_ref r42
    dec_ref r43
    goto L62
L72:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L62
L73:
    dec_ref r50
    goto L20
L74:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L23
L75:
    dec_ref r60
    dec_ref r61
    dec_ref r62
    goto L32
L76:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    dec_ref r58
    goto L30
L77:
    dec_ref r0
    dec_ref r42
    dec_ref r45
    goto L33
L78:
    dec_ref r42
    dec_ref r45
    goto L39
L79:
    dec_ref r0
    dec_ref r42
    goto L42
L80:
    dec_ref r76
    goto L38
L81:
    dec_ref r0
    goto L40
L82:
    xdec_ref r71
    goto L41
L83:
    dec_ref r78
    goto L62
L84:
    dec_ref f
    goto L62
L85:
    dec_ref f
    dec_ref r95
    goto L62

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: str
    r26, r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: i32
    r42 :: bit
    r43 :: object
    r44 :: str
    r45, r46 :: object
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: object[1]
    r59 :: object_ptr
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72, r73 :: dict
    r74 :: str
    r75 :: i32
    r76 :: bit
    r77, r78 :: dict
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82, r83 :: dict
    r84 :: str
    r85 :: i32
    r86 :: bit
    r87, r88 :: dict
    r89 :: str
    r90 :: i32
    r91 :: bit
    r92 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L28 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = faster_eth_abi.utils.numeric.globals :: static
    r12 = 'faster_eth_abi/utils/numeric.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L28 else goto L4 :: bool
L4:
    r15 = ('Callable', 'Dict', 'Final', 'Tuple')
    r16 = 'typing'
    r17 = faster_eth_abi.utils.numeric.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L28 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = faster_eth_abi.utils.numeric.globals :: static
    r20 = 'ABI_DECIMAL_PREC'
    r21 = object 999
    r22 = CPyDict_SetItem(r19, r20, r21)
    r23 = r22 >= 0 :: signed
    if not r23 goto L28 (error at <module>:9) else goto L6 :: bool
L6:
    r24 = decimal :: module
    r25 = 'Context'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L28 (error at <module>:11) else goto L7
L7:
    r27 = object 999
    r28 = [r27]
    r29 = load_address r28
    r30 = ('prec',)
    r31 = PyObject_Vectorcall(r26, r29, 0, r30)
    dec_ref r26
    if is_error(r31) goto L28 (error at <module>:11) else goto L8
L8:
    faster_eth_abi.utils.numeric.abi_decimal_context = r31 :: static
    r32 = faster_eth_abi.utils.numeric.globals :: static
    r33 = 'abi_decimal_context'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L28 (error at <module>:11) else goto L9 :: bool
L9:
    r36 = decimal :: module
    r37 = 'localcontext'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L28 (error at <module>:12) else goto L10
L10:
    faster_eth_abi.utils.numeric.decimal_localcontext = r38 :: static
    r39 = faster_eth_abi.utils.numeric.globals :: static
    r40 = 'decimal_localcontext'
    r41 = CPyDict_SetItem(r39, r40, r38)
    dec_ref r38
    r42 = r41 >= 0 :: signed
    if not r42 goto L28 (error at <module>:12) else goto L11 :: bool
L11:
    r43 = decimal :: module
    r44 = 'Decimal'
    r45 = CPyObject_GetAttr(r43, r44)
    if is_error(r45) goto L28 (error at <module>:14) else goto L12
L12:
    r46 = object 0
    r47 = [r46]
    r48 = load_address r47
    r49 = PyObject_Vectorcall(r45, r48, 1, 0)
    dec_ref r45
    if is_error(r49) goto L28 (error at <module>:14) else goto L13
L13:
    faster_eth_abi.utils.numeric.ZERO = r49 :: static
    r50 = faster_eth_abi.utils.numeric.globals :: static
    r51 = 'ZERO'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L28 (error at <module>:14) else goto L14 :: bool
L14:
    r54 = decimal :: module
    r55 = 'Decimal'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L28 (error at <module>:15) else goto L15
L15:
    r57 = object 10
    r58 = [r57]
    r59 = load_address r58
    r60 = PyObject_Vectorcall(r56, r59, 1, 0)
    dec_ref r56
    if is_error(r60) goto L28 (error at <module>:15) else goto L16
L16:
    faster_eth_abi.utils.numeric.TEN = r60 :: static
    r61 = faster_eth_abi.utils.numeric.globals :: static
    r62 = 'TEN'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L28 (error at <module>:15) else goto L17 :: bool
L17:
    r65 = decimal :: module
    r66 = 'Decimal'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L28 (error at <module>:17) else goto L18
L18:
    faster_eth_abi.utils.numeric.Decimal = r67 :: static
    r68 = faster_eth_abi.utils.numeric.globals :: static
    r69 = 'Decimal'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L28 (error at <module>:17) else goto L19 :: bool
L19:
    r72 = PyDict_New()
    if is_error(r72) goto L28 (error at <module>:25) else goto L20
L20:
    faster_eth_abi.utils.numeric._unsigned_integer_bounds_cache = r72 :: static
    r73 = faster_eth_abi.utils.numeric.globals :: static
    r74 = '_unsigned_integer_bounds_cache'
    r75 = CPyDict_SetItem(r73, r74, r72)
    dec_ref r72
    r76 = r75 >= 0 :: signed
    if not r76 goto L28 (error at <module>:25) else goto L21 :: bool
L21:
    r77 = PyDict_New()
    if is_error(r77) goto L28 (error at <module>:36) else goto L22
L22:
    faster_eth_abi.utils.numeric._signed_integer_bounds_cache = r77 :: static
    r78 = faster_eth_abi.utils.numeric.globals :: static
    r79 = '_signed_integer_bounds_cache'
    r80 = CPyDict_SetItem(r78, r79, r77)
    dec_ref r77
    r81 = r80 >= 0 :: signed
    if not r81 goto L28 (error at <module>:36) else goto L23 :: bool
L23:
    r82 = PyDict_New()
    if is_error(r82) goto L28 (error at <module>:50) else goto L24
L24:
    faster_eth_abi.utils.numeric._unsigned_fixed_bounds_cache = r82 :: static
    r83 = faster_eth_abi.utils.numeric.globals :: static
    r84 = '_unsigned_fixed_bounds_cache'
    r85 = CPyDict_SetItem(r83, r84, r82)
    dec_ref r82
    r86 = r85 >= 0 :: signed
    if not r86 goto L28 (error at <module>:50) else goto L25 :: bool
L25:
    r87 = PyDict_New()
    if is_error(r87) goto L28 (error at <module>:71) else goto L26
L26:
    faster_eth_abi.utils.numeric._signed_fixed_bounds_cache = r87 :: static
    r88 = faster_eth_abi.utils.numeric.globals :: static
    r89 = '_signed_fixed_bounds_cache'
    r90 = CPyDict_SetItem(r88, r89, r87)
    dec_ref r87
    r91 = r90 >= 0 :: signed
    if not r91 goto L28 (error at <module>:71) else goto L27 :: bool
L27:
    return 1
L28:
    r92 = <error> :: None
    return r92

def decode_uint_256(stream):
    stream :: object
    r0 :: str
    r1 :: object
    r2 :: object[2]
    r3 :: object_ptr
    r4 :: object
    r5 :: bytes
    r6 :: ptr
    r7 :: native_int
    r8 :: short_int
    r9 :: bit
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: int
    r17 :: str
    r18 :: ptr
    r19 :: native_int
    r20 :: short_int
    r21, r22, r23 :: str
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: int
L0:
    r0 = 'read'
    r1 = object 32
    r2 = [stream, r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775810, 0)
    if is_error(r4) goto L13 (error at decode_uint_256:39) else goto L1
L1:
    r5 = cast(bytes, r4)
    if is_error(r5) goto L13 (error at decode_uint_256:39) else goto L2
L2:
    inc_ref r5
    r6 = get_element_ptr r5 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    dec_ref r5
    r8 = r7 << 1
    r9 = r8 == 64
    if r9 goto L3 else goto L7 :: bool
L3:
    r10 = faster_eth_abi._decoding.globals :: static
    r11 = 'big_endian_to_int'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L14 (error at decode_uint_256:40) else goto L4
L4:
    r13 = [r5]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L14 (error at decode_uint_256:40) else goto L5
L5:
    dec_ref r5
    r16 = unbox(int, r15)
    dec_ref r15
    if is_error(r16) goto L13 (error at decode_uint_256:40) else goto L6
L6:
    return r16
L7:
    r17 = 'Tried to read 32 bytes, only got '
    r18 = get_element_ptr r5 ob_size :: PyVarObject
    r19 = load_mem r18 :: native_int*
    dec_ref r5
    r20 = r19 << 1
    r21 = CPyTagged_Str(r20)
    if is_error(r21) goto L13 (error at decode_uint_256:41) else goto L8
L8:
    r22 = ' bytes.'
    r23 = CPyStr_Build(3, r17, r21, r22)
    dec_ref r21
    if is_error(r23) goto L13 (error at decode_uint_256:41) else goto L9
L9:
    r24 = faster_eth_abi._decoding.globals :: static
    r25 = 'InsufficientDataBytes'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L15 (error at decode_uint_256:41) else goto L10
L10:
    r27 = [r23]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r26, r28, 1, 0)
    dec_ref r26
    if is_error(r29) goto L15 (error at decode_uint_256:41) else goto L11
L11:
    dec_ref r23
    CPy_Raise(r29)
    dec_ref r29
    if not 0 goto L13 (error at decode_uint_256:41) else goto L12 :: bool
L12:
    unreachable
L13:
    r30 = <error> :: int
    return r30
L14:
    dec_ref r5
    goto L13
L15:
    dec_ref r23
    goto L13

def get_value_byte_size(decoder):
    decoder :: object
    r0 :: str
    r1 :: object
    r2, r3, r4 :: int
L0:
    r0 = 'value_bit_size'
    r1 = CPyObject_GetAttr(decoder, r0)
    if is_error(r1) goto L4 (error at get_value_byte_size:45) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L4 (error at get_value_byte_size:45) else goto L2
L2:
    r3 = CPyTagged_Rshift(r2, 6)
    dec_ref r2 :: int
    if is_error(r3) goto L4 (error at get_value_byte_size:-1) else goto L3
L3:
    return r3
L4:
    r4 = <error> :: int
    return r4

def decode_head_tail(self, stream):
    self, stream :: object
    r0 :: int
    r1 :: str
    r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7 :: object
    tail_decoder :: union[object, None]
    r8 :: object
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    value :: union[object, tuple]
    r20 :: str
    r21 :: object[1]
    r22 :: object_ptr
    r23, r24 :: object
L0:
    r0 = decode_uint_256(stream)
    if is_error(r0) goto L11 (error at decode_head_tail:51) else goto L1
L1:
    r1 = 'push_frame'
    r2 = box(int, r0)
    r3 = [stream, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775810, 0)
    if is_error(r5) goto L12 (error at decode_head_tail:53) else goto L13
L2:
    dec_ref r2
    r6 = 'tail_decoder'
    r7 = CPyObject_GetAttr(self, r6)
    if is_error(r7) goto L11 (error at decode_head_tail:56) else goto L3
L3:
    tail_decoder = r7
    r8 = load_address _Py_NoneStruct
    r9 = tail_decoder == r8
    if r9 goto L14 else goto L8 :: bool
L4:
    r10 = '`tail_decoder` is None'
    r11 = builtins :: module
    r12 = 'AssertionError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L11 (error at decode_head_tail:58) else goto L5
L5:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L11 (error at decode_head_tail:58) else goto L6
L6:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L11 (error at decode_head_tail:58) else goto L7 :: bool
L7:
    unreachable
L8:
    r17 = [stream]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(tail_decoder, r18, 1, 0)
    dec_ref tail_decoder
    if is_error(r19) goto L11 (error at decode_head_tail:60) else goto L9
L9:
    value = r19
    r20 = 'pop_frame'
    r21 = [stream]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775809, 0)
    if is_error(r23) goto L15 (error at decode_head_tail:62) else goto L16
L10:
    return value
L11:
    r24 = <error> :: object
    return r24
L12:
    dec_ref r2
    goto L11
L13:
    dec_ref r5
    goto L2
L14:
    dec_ref tail_decoder
    goto L4
L15:
    dec_ref value
    goto L11
L16:
    dec_ref r23
    goto L10

def decode_tuple(self, stream):
    self, stream :: object
    r0 :: str
    r1 :: object[2]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: ptr
    r8 :: native_int
    r9 :: tuple
    r10 :: ptr
    r11, r12 :: native_int
    r13 :: bit
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: native_int
    r19 :: tuple
L0:
    r0 = 'validate_pointers'
    r1 = [self, stream]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775810, 0)
    if is_error(r3) goto L10 (error at decode_tuple:69) else goto L11
L1:
    r4 = 'decoders'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L10 (error at decode_tuple:70) else goto L2
L2:
    r6 = cast(tuple, r5)
    if is_error(r6) goto L10 (error at decode_tuple:70) else goto L3
L3:
    r7 = get_element_ptr r6 ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = PyTuple_New(r8)
    if is_error(r9) goto L12 (error at decode_tuple:70) else goto L4
L4:
    r10 = get_element_ptr r6 ob_size :: PyVarObject
    r11 = load_mem r10 :: native_int*
    r12 = 0
L5:
    r13 = r12 < r11 :: signed
    if r13 goto L6 else goto L13 :: bool
L6:
    r14 = CPySequenceTuple_GetItemUnsafe(r6, r12)
    r15 = [stream]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L14 (error at decode_tuple:70) else goto L7
L7:
    CPySequenceTuple_SetItemUnsafe(r9, r12, r17)
L8:
    r18 = r12 + 1
    r12 = r18
    goto L5
L9:
    return r9
L10:
    r19 = <error> :: tuple
    return r19
L11:
    dec_ref r3
    goto L1
L12:
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L9
L14:
    dec_ref r6
    dec_ref r9
    goto L10

def decode_sized_array(self, stream):
    self, stream :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: int
    r14 :: str
    r15 :: object
    r16 :: object[3]
    r17 :: object_ptr
    r18 :: object
    r19 :: list
    r20 :: int
    r21, _ :: object
    r22 :: native_int
    r23 :: bit
    r24 :: native_int
    r25, r26, r27 :: bit
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: i32
    r32 :: bit
    r33 :: int
    r34 :: object
    r35, r36 :: tuple
L0:
    r0 = 'item_decoder'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L20 (error at decode_sized_array:77) else goto L1
L1:
    r2 = load_address _Py_NoneStruct
    r3 = r1 == r2
    if r3 goto L21 else goto L6 :: bool
L2:
    r4 = '`item_decoder` is None'
    r5 = builtins :: module
    r6 = 'AssertionError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L20 (error at decode_sized_array:79) else goto L3
L3:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L20 (error at decode_sized_array:79) else goto L4
L4:
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L20 (error at decode_sized_array:79) else goto L5 :: bool
L5:
    unreachable
L6:
    r11 = 'array_size'
    r12 = CPyObject_GetAttr(self, r11)
    if is_error(r12) goto L22 (error at decode_sized_array:81) else goto L7
L7:
    r13 = unbox(int, r12)
    dec_ref r12
    if is_error(r13) goto L22 (error at decode_sized_array:81) else goto L8
L8:
    r14 = 'validate_pointers'
    inc_ref r13 :: int
    r15 = box(int, r13)
    r16 = [self, stream, r15]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r14, r17, 9223372036854775811, 0)
    if is_error(r18) goto L23 (error at decode_sized_array:82) else goto L24
L9:
    dec_ref r15
    r19 = PyList_New(0)
    if is_error(r19) goto L25 (error at decode_sized_array:83) else goto L10
L10:
    r20 = 0
    inc_ref r20 :: int
    r21 = box(int, r20)
    _ = r21
    dec_ref _
L11:
    r22 = r20 & 1
    r23 = r22 != 0
    if r23 goto L13 else goto L12 :: bool
L12:
    r24 = r13 & 1
    r25 = r24 != 0
    if r25 goto L13 else goto L14 :: bool
L13:
    r26 = CPyTagged_IsLt_(r20, r13)
    if r26 goto L15 else goto L26 :: bool
L14:
    r27 = r20 < r13 :: signed
    if r27 goto L15 else goto L26 :: bool
L15:
    r28 = [stream]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r1, r29, 1, 0)
    if is_error(r30) goto L27 (error at decode_sized_array:83) else goto L16
L16:
    r31 = PyList_Append(r19, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L27 (error at decode_sized_array:83) else goto L17 :: bool
L17:
    r33 = CPyTagged_Add(r20, 2)
    dec_ref r20 :: int
    inc_ref r33 :: int
    r20 = r33
    r34 = box(int, r33)
    _ = r34
    dec_ref _
    goto L11
L18:
    r35 = PyList_AsTuple(r19)
    dec_ref r19
    if is_error(r35) goto L20 (error at decode_sized_array:83) else goto L19
L19:
    return r35
L20:
    r36 = <error> :: tuple
    return r36
L21:
    dec_ref r1
    goto L2
L22:
    dec_ref r1
    goto L20
L23:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r15
    goto L20
L24:
    dec_ref r18
    goto L9
L25:
    dec_ref r1
    dec_ref r13 :: int
    goto L20
L26:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r20 :: int
    goto L18
L27:
    dec_ref r1
    dec_ref r13 :: int
    dec_ref r19
    dec_ref r20 :: int
    goto L20

def decode_dynamic_array(self, stream):
    self, stream :: object
    r0 :: int
    r1 :: str
    r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: list
    r25 :: int
    r26, _ :: object
    r27 :: native_int
    r28 :: bit
    r29 :: native_int
    r30, r31, r32 :: bit
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: i32
    r37 :: bit
    r38 :: int
    r39 :: object
    r40, r41 :: tuple
    r42, r43 :: tuple[object, object, object]
    r44 :: tuple
    r45 :: tuple[object, object, object]
    r46 :: str
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: bit
    r51 :: tuple
L0:
    r0 = decode_uint_256(stream)
    if is_error(r0) goto L35 (error at decode_dynamic_array:90) else goto L1
L1:
    r1 = 'push_frame'
    r2 = object 32
    r3 = [stream, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775810, 0)
    if is_error(r5) goto L36 (error at decode_dynamic_array:91) else goto L37
L2:
    r6 = 'item_decoder'
    r7 = CPyObject_GetAttr(self, r6)
    if is_error(r7) goto L36 (error at decode_dynamic_array:92) else goto L3
L3:
    r8 = load_address _Py_NoneStruct
    r9 = r7 == r8
    dec_ref r7
    if r9 goto L38 else goto L8 :: bool
L4:
    r10 = '`item_decoder` is None'
    r11 = builtins :: module
    r12 = 'AssertionError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L35 (error at decode_dynamic_array:93) else goto L5
L5:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L35 (error at decode_dynamic_array:93) else goto L6
L6:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L35 (error at decode_dynamic_array:93) else goto L7 :: bool
L7:
    unreachable
L8:
    r17 = 'validate_pointers'
    inc_ref r0 :: int
    r18 = box(int, r0)
    r19 = [self, stream, r18]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r17, r20, 9223372036854775811, 0)
    if is_error(r21) goto L39 (error at decode_dynamic_array:95) else goto L40
L9:
    dec_ref r18
    r22 = 'item_decoder'
    r23 = CPyObject_GetAttr(self, r22)
    if is_error(r23) goto L36 (error at decode_dynamic_array:96) else goto L10
L10:
L11:
    r24 = PyList_New(0)
    if is_error(r24) goto L41 (error at decode_dynamic_array:98) else goto L12
L12:
    r25 = 0
    inc_ref r25 :: int
    r26 = box(int, r25)
    _ = r26
    dec_ref _
L13:
    r27 = r25 & 1
    r28 = r27 != 0
    if r28 goto L15 else goto L14 :: bool
L14:
    r29 = r0 & 1
    r30 = r29 != 0
    if r30 goto L15 else goto L16 :: bool
L15:
    r31 = CPyTagged_IsLt_(r25, r0)
    if r31 goto L17 else goto L42 :: bool
L16:
    r32 = r25 < r0 :: signed
    if r32 goto L17 else goto L42 :: bool
L17:
    r33 = [stream]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r23, r34, 1, 0)
    if is_error(r35) goto L43 (error at decode_dynamic_array:98) else goto L18
L18:
    r36 = PyList_Append(r24, r35)
    dec_ref r35
    r37 = r36 >= 0 :: signed
    if not r37 goto L43 (error at decode_dynamic_array:98) else goto L19 :: bool
L19:
    r38 = CPyTagged_Add(r25, 2)
    dec_ref r25 :: int
    inc_ref r38 :: int
    r25 = r38
    r39 = box(int, r38)
    _ = r39
    dec_ref _
    goto L13
L20:
    r40 = PyList_AsTuple(r24)
    dec_ref r24
    if is_error(r40) goto L23 (error at decode_dynamic_array:98) else goto L21
L21:
    r41 = r40
L22:
    r42 = <error> :: tuple[object, object, object]
    r43 = r42
    goto L24
L23:
    r44 = <error> :: tuple
    r41 = r44
    r45 = CPy_CatchError()
    r43 = r45
L24:
    r46 = 'pop_frame'
    r47 = [stream]
    r48 = load_address r47
    r49 = PyObject_VectorcallMethod(r46, r48, 9223372036854775809, 0)
    if is_error(r49) goto L44 (error at decode_dynamic_array:100) else goto L45
L25:
    if is_error(r43) goto L28 else goto L46
L26:
    CPy_Reraise()
    if not 0 goto L30 else goto L47 :: bool
L27:
    unreachable
L28:
    if is_error(r41) goto L34 else goto L29
L29:
    return r41
L30:
    if is_error(r43) goto L32 else goto L31
L31:
    CPy_RestoreExcInfo(r43)
    xdec_ref r43
L32:
    r50 = CPy_KeepPropagating()
    if not r50 goto L35 else goto L33 :: bool
L33:
    unreachable
L34:
    unreachable
L35:
    r51 = <error> :: tuple
    return r51
L36:
    dec_ref r0 :: int
    goto L35
L37:
    dec_ref r5
    goto L2
L38:
    dec_ref r0 :: int
    goto L4
L39:
    dec_ref r0 :: int
    dec_ref r18
    goto L35
L40:
    dec_ref r21
    goto L9
L41:
    dec_ref r0 :: int
    dec_ref r23
    goto L23
L42:
    dec_ref r0 :: int
    dec_ref r23
    dec_ref r25 :: int
    goto L20
L43:
    dec_ref r0 :: int
    dec_ref r23
    dec_ref r24
    dec_ref r25 :: int
    goto L23
L44:
    xdec_ref r41
    goto L30
L45:
    dec_ref r49
    goto L25
L46:
    xdec_ref r41
    goto L26
L47:
    xdec_ref r43
    goto L27

def read_fixed_byte_size_data_from_stream(self, stream):
    self, stream :: object
    r0 :: str
    r1 :: object
    r2 :: int
    r3 :: str
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7 :: object
    r8 :: bytes
    r9 :: ptr
    r10 :: native_int
    r11 :: short_int
    r12 :: bit
    r13, r14, r15 :: str
    r16 :: ptr
    r17 :: native_int
    r18 :: short_int
    r19, r20, r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bytes
L0:
    r0 = 'data_byte_size'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at read_fixed_byte_size_data_from_stream:110) else goto L1
L1:
    r2 = unbox(int, r1)
    dec_ref r1
    if is_error(r2) goto L13 (error at read_fixed_byte_size_data_from_stream:110) else goto L2
L2:
    r3 = 'read'
    inc_ref r2 :: int
    r4 = box(int, r2)
    r5 = [stream, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r3, r6, 9223372036854775810, 0)
    if is_error(r7) goto L14 (error at read_fixed_byte_size_data_from_stream:111) else goto L3
L3:
    dec_ref r4
    r8 = cast(bytes, r7)
    if is_error(r8) goto L15 (error at read_fixed_byte_size_data_from_stream:111) else goto L4
L4:
    inc_ref r8
    r9 = get_element_ptr r8 ob_size :: PyVarObject
    r10 = load_mem r9 :: native_int*
    dec_ref r8
    r11 = r10 << 1
    r12 = r11 == r2
    if r12 goto L16 else goto L6 :: bool
L5:
    return r8
L6:
    r13 = 'Tried to read '
    r14 = CPyTagged_Str(r2)
    dec_ref r2 :: int
    if is_error(r14) goto L17 (error at read_fixed_byte_size_data_from_stream:114) else goto L7
L7:
    r15 = ' bytes, only got '
    r16 = get_element_ptr r8 ob_size :: PyVarObject
    r17 = load_mem r16 :: native_int*
    dec_ref r8
    r18 = r17 << 1
    r19 = CPyTagged_Str(r18)
    if is_error(r19) goto L18 (error at read_fixed_byte_size_data_from_stream:114) else goto L8
L8:
    r20 = ' bytes.'
    r21 = CPyStr_Build(5, r13, r14, r15, r19, r20)
    dec_ref r14
    dec_ref r19
    if is_error(r21) goto L13 (error at read_fixed_byte_size_data_from_stream:114) else goto L9
L9:
    r22 = faster_eth_abi._decoding.globals :: static
    r23 = 'InsufficientDataBytes'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L19 (error at read_fixed_byte_size_data_from_stream:113) else goto L10
L10:
    r25 = [r21]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L19 (error at read_fixed_byte_size_data_from_stream:113) else goto L11
L11:
    dec_ref r21
    CPy_Raise(r27)
    dec_ref r27
    if not 0 goto L13 (error at read_fixed_byte_size_data_from_stream:113) else goto L12 :: bool
L12:
    unreachable
L13:
    r28 = <error> :: bytes
    return r28
L14:
    dec_ref r2 :: int
    dec_ref r4
    goto L13
L15:
    dec_ref r2 :: int
    goto L13
L16:
    dec_ref r2 :: int
    goto L5
L17:
    dec_ref r8
    goto L13
L18:
    dec_ref r14
    goto L13
L19:
    dec_ref r21
    goto L13

def split_data_and_padding_fixed_byte_size(self, raw_data):
    self :: object
    raw_data :: bytes
    r0 :: int
    r1 :: str
    r2 :: object
    r3, r4 :: int
    r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: bit
    r9 :: bytes
    r10 :: tuple[bytes, bytes]
    r11, padding_bytes, r12, data, r13, r14 :: bytes
    r15, r16 :: tuple[bytes, bytes]
L0:
    r0 = get_value_byte_size(self)
    if is_error(r0) goto L15 (error at split_data_and_padding_fixed_byte_size:122) else goto L1
L1:
    r1 = 'data_byte_size'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L16 (error at split_data_and_padding_fixed_byte_size:123) else goto L2
L2:
    r3 = unbox(int, r2)
    dec_ref r2
    if is_error(r3) goto L16 (error at split_data_and_padding_fixed_byte_size:123) else goto L3
L3:
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    r5 = 'is_big_endian'
    r6 = CPyObject_GetAttr(self, r5)
    if is_error(r6) goto L17 (error at split_data_and_padding_fixed_byte_size:125) else goto L4
L4:
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L17 (error at split_data_and_padding_fixed_byte_size:125) else goto L5
L5:
    if r7 goto L18 else goto L19 :: bool
L6:
    r8 = r4 == 0
    if r8 goto L20 else goto L8 :: bool
L7:
    r9 = b''
    inc_ref raw_data
    inc_ref r9
    r10 = (raw_data, r9)
    return r10
L8:
    r11 = CPyBytes_GetSlice(raw_data, 0, r4)
    if is_error(r11) goto L21 (error at split_data_and_padding_fixed_byte_size:128) else goto L9
L9:
    padding_bytes = r11
    r12 = CPyBytes_GetSlice(raw_data, r4, 9223372036854775806)
    dec_ref r4 :: int
    if is_error(r12) goto L22 (error at split_data_and_padding_fixed_byte_size:129) else goto L10
L10:
    data = r12
    goto L14
L11:
    r13 = CPyBytes_GetSlice(raw_data, 0, r0)
    if is_error(r13) goto L16 (error at split_data_and_padding_fixed_byte_size:131) else goto L12
L12:
    data = r13
    r14 = CPyBytes_GetSlice(raw_data, r0, 9223372036854775806)
    dec_ref r0 :: int
    if is_error(r14) goto L23 (error at split_data_and_padding_fixed_byte_size:132) else goto L13
L13:
    padding_bytes = r14
L14:
    r15 = (data, padding_bytes)
    return r15
L15:
    r16 = <error> :: tuple[bytes, bytes]
    return r16
L16:
    dec_ref r0 :: int
    goto L15
L17:
    dec_ref r0 :: int
    dec_ref r4 :: int
    goto L15
L18:
    dec_ref r0 :: int
    goto L6
L19:
    dec_ref r4 :: int
    goto L11
L20:
    dec_ref r4 :: int
    goto L7
L21:
    dec_ref r4 :: int
    goto L15
L22:
    dec_ref padding_bytes
    goto L15
L23:
    dec_ref data
    goto L15

def validate_padding_bytes_fixed_byte_size(self, value, padding_bytes):
    self, value :: object
    padding_bytes :: bytes
    r0 :: int
    r1 :: str
    r2 :: object
    r3, r4 :: int
    r5 :: bytes
    r6, r7 :: object
    r8 :: bytes
    r9 :: i32
    r10, r11 :: bit
    r12, r13, r14, r15, r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19 :: object
    r20 :: str
    r21 :: list
    r22, r23, r24 :: ptr
    r25 :: str
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: None
L0:
    r0 = get_value_byte_size(self)
    if is_error(r0) goto L16 (error at validate_padding_bytes_fixed_byte_size:142) else goto L1
L1:
    r1 = 'data_byte_size'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L17 (error at validate_padding_bytes_fixed_byte_size:143) else goto L2
L2:
    r3 = unbox(int, r2)
    dec_ref r2
    if is_error(r3) goto L17 (error at validate_padding_bytes_fixed_byte_size:143) else goto L3
L3:
    r4 = CPyTagged_Subtract(r3, r0)
    dec_ref r3 :: int
    dec_ref r0 :: int
    r5 = b'\x00'
    r6 = box(int, r4)
    r7 = PyNumber_Multiply(r5, r6)
    dec_ref r6
    if is_error(r7) goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L4
L4:
    r8 = cast(bytes, r7)
    if is_error(r8) goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L5
L5:
    r9 = CPyBytes_Compare(padding_bytes, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L16 (error at validate_padding_bytes_fixed_byte_size:145) else goto L6 :: bool
L6:
    r11 = r9 != 1
    if r11 goto L7 else goto L15 :: bool
L7:
    r12 = ''
    r13 = 'Padding bytes were not empty: '
    r14 = '{!r:{}}'
    r15 = ''
    r16 = 'format'
    r17 = [r14, padding_bytes, r15]
    r18 = load_address r17
    r19 = PyObject_VectorcallMethod(r16, r18, 9223372036854775811, 0)
    if is_error(r19) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L8
L8:
    r20 = cast(str, r19)
    if is_error(r20) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L9
L9:
    r21 = PyList_New(2)
    if is_error(r21) goto L18 (error at validate_padding_bytes_fixed_byte_size:146) else goto L10
L10:
    r22 = get_element_ptr r21 ob_item :: PyListObject
    r23 = load_mem r22 :: ptr*
    inc_ref r13
    set_mem r23, r13 :: builtins.object*
    r24 = r23 + 8
    set_mem r24, r20 :: builtins.object*
    r25 = PyUnicode_Join(r12, r21)
    dec_ref r21
    if is_error(r25) goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L11
L11:
    r26 = faster_eth_abi._decoding.globals :: static
    r27 = 'NonEmptyPaddingBytes'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L19 (error at validate_padding_bytes_fixed_byte_size:146) else goto L12
L12:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L19 (error at validate_padding_bytes_fixed_byte_size:146) else goto L13
L13:
    dec_ref r25
    CPy_Raise(r31)
    dec_ref r31
    if not 0 goto L16 (error at validate_padding_bytes_fixed_byte_size:146) else goto L14 :: bool
L14:
    unreachable
L15:
    return 1
L16:
    r32 = <error> :: None
    return r32
L17:
    dec_ref r0 :: int
    goto L16
L18:
    dec_ref r20
    goto L16
L19:
    dec_ref r25
    goto L16

def decoder_fn_boolean(data):
    data, r0 :: bytes
    r1 :: i32
    r2, r3 :: bit
    r4 :: bytes
    r5 :: i32
    r6, r7 :: bit
    r8, r9, r10, r11, r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16 :: str
    r17 :: list
    r18, r19, r20 :: ptr
    r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bool
L0:
    r0 = b'\x00'
    r1 = CPyBytes_Compare(data, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at decoder_fn_boolean:151) else goto L1 :: bool
L1:
    r3 = r1 == 1
    if r3 goto L2 else goto L3 :: bool
L2:
    return 0
L3:
    r4 = b'\x01'
    r5 = CPyBytes_Compare(data, r4)
    r6 = r5 >= 0 :: signed
    if not r6 goto L14 (error at decoder_fn_boolean:153) else goto L4 :: bool
L4:
    r7 = r5 == 1
    if r7 goto L5 else goto L6 :: bool
L5:
    return 1
L6:
    r8 = ''
    r9 = 'Boolean must be either 0x0 or 0x1.  Got: '
    r10 = '{!r:{}}'
    r11 = ''
    r12 = 'format'
    r13 = [r10, data, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L14 (error at decoder_fn_boolean:155) else goto L7
L7:
    r16 = cast(str, r15)
    if is_error(r16) goto L14 (error at decoder_fn_boolean:155) else goto L8
L8:
    r17 = PyList_New(2)
    if is_error(r17) goto L15 (error at decoder_fn_boolean:155) else goto L9
L9:
    r18 = get_element_ptr r17 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r9
    set_mem r19, r9 :: builtins.object*
    r20 = r19 + 8
    set_mem r20, r16 :: builtins.object*
    r21 = PyUnicode_Join(r8, r17)
    dec_ref r17
    if is_error(r21) goto L14 (error at decoder_fn_boolean:155) else goto L10
L10:
    r22 = faster_eth_abi._decoding.globals :: static
    r23 = 'NonEmptyPaddingBytes'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L16 (error at decoder_fn_boolean:155) else goto L11
L11:
    r25 = [r21]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L16 (error at decoder_fn_boolean:155) else goto L12
L12:
    dec_ref r21
    CPy_Raise(r27)
    dec_ref r27
    if not 0 goto L14 (error at decoder_fn_boolean:155) else goto L13 :: bool
L13:
    unreachable
L14:
    r28 = <error> :: bool
    return r28
L15:
    dec_ref r16
    goto L14
L16:
    dec_ref r21
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L9 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Tuple')
    r6 = 'typing'
    r7 = faster_eth_abi._decoding.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L9 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('big_endian_to_int',)
    r10 = 'faster_eth_utils'
    r11 = faster_eth_abi._decoding.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L9 (error at <module>:7) else goto L5
L5:
    faster_eth_utils = r12 :: module
    dec_ref r12
    r13 = ('InsufficientDataBytes', 'NonEmptyPaddingBytes')
    r14 = 'faster_eth_abi.exceptions'
    r15 = faster_eth_abi._decoding.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L9 (error at <module>:11) else goto L6
L6:
    faster_eth_abi.exceptions = r16 :: module
    dec_ref r16
    r17 = ('BytesIO', 'ContextFramesBytesIO')
    r18 = 'faster_eth_abi.io'
    r19 = faster_eth_abi._decoding.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L9 (error at <module>:15) else goto L7
L7:
    faster_eth_abi.io = r20 :: module
    dec_ref r20
    if 0 goto L8 else goto L8 :: bool
L8:
    return 1
L9:
    r21 = <error> :: None
    return r21

def StrategyRegistry.__init__(self):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: faster_eth_abi._registry.PredicateMapping
    r2 :: bool
    r3 :: None
L0:
    r0 = 'strategy registry'
    r1 = PredicateMapping(r0)
    if is_error(r1) goto L3 (error at __init__:43) else goto L1
L1:
    self._strategies = r1; r2 = is_error
    if not r2 goto L3 (error at __init__:43) else goto L2 :: bool
L2:
    return 1
L3:
    r3 = <error> :: None
    return r3

def StrategyRegistry.register_strategy(self, lookup, registration, label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup :: union[str, object]
    registration :: object
    label :: union[str, None]
    r0 :: object
    r1 :: faster_eth_abi._registry.PredicateMapping
    r2 :: str
    r3 :: object[5]
    r4 :: object_ptr
    r5, r6 :: object
    r7 :: None
L0:
    if is_error(label) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._strategies
    if is_error(r1) goto L7 (error at register_strategy:51) else goto L3
L3:
    r2 = '_register'
    r3 = [self, r1, lookup, registration, label]
    r4 = load_address r3
    r5 = ('label',)
    r6 = PyObject_VectorcallMethod(r2, r4, 9223372036854775812, r5)
    if is_error(r6) goto L8 (error at register_strategy:51) else goto L9
L4:
    dec_ref r1
    dec_ref label
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    inc_ref label
    goto L2
L7:
    dec_ref label
    goto L5
L8:
    dec_ref label
    dec_ref r1
    goto L5
L9:
    dec_ref r6
    goto L4

def StrategyRegistry.unregister_strategy(self, lookup_or_label):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    lookup_or_label :: union[str, object]
    r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: None
L0:
    r0 = self._strategies
    if is_error(r0) goto L3 (error at unregister_strategy:54) else goto L1
L1:
    r1 = '_unregister'
    r2 = [self, r0, lookup_or_label]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L4 (error at unregister_strategy:54) else goto L5
L2:
    dec_ref r0
    return 1
L3:
    r5 = <error> :: None
    return r5
L4:
    dec_ref r0
    goto L3
L5:
    dec_ref r4
    goto L2

def StrategyRegistry.get_strategy(self, type_str):
    self :: faster_eth_abi.tools._strategies.StrategyRegistry
    type_str :: str
    r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: str
    r2 :: object[3]
    r3 :: object_ptr
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = self._strategies
    if is_error(r0) goto L14 (error at get_strategy:66) else goto L1
L1:
    r1 = '_get_registration'
    r2 = [self, r0, type_str]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775811, 0)
    if is_error(r4) goto L15 (error at get_strategy:66) else goto L2
L2:
    dec_ref r0
    r5 = faster_eth_abi.tools._strategies.globals :: static
    r6 = 'st'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L16 (error at get_strategy:68) else goto L3
L3:
    r8 = 'SearchStrategy'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L16 (error at get_strategy:68) else goto L4
L4:
    r10 = PyObject_IsInstance(r4, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L16 (error at get_strategy:68) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L7 :: bool
L6:
    return r4
L7:
    r13 = faster_eth_abi.tools._strategies.globals :: static
    r14 = 'normalize'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at get_strategy:74) else goto L8
L8:
    r16 = [type_str]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L16 (error at get_strategy:74) else goto L9
L9:
    r19 = cast(str, r18)
    if is_error(r19) goto L16 (error at get_strategy:74) else goto L10
L10:
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = 'parse'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L17 (error at get_strategy:75) else goto L11
L11:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L17 (error at get_strategy:75) else goto L12
L12:
    dec_ref r19
    r26 = [r25, self]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r4, r27, 2, 0)
    dec_ref r4
    if is_error(r28) goto L18 (error at get_strategy:76) else goto L13
L13:
    dec_ref r25
    return r28
L14:
    r29 = <error> :: object
    return r29
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r4
    goto L14
L17:
    dec_ref r4
    dec_ref r19
    goto L14
L18:
    dec_ref r25
    goto L14

def get_uint_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[3]
    r12 :: object_ptr
    r13, r14, r15 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L6 (error at get_uint_strategy:84) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L7 (error at get_uint_strategy:86) else goto L2
L2:
    r5 = object 2
    r6 = CPyNumber_Power(r5, r1)
    dec_ref r1
    if is_error(r6) goto L8 (error at get_uint_strategy:88) else goto L3
L3:
    r7 = object 1
    r8 = PyNumber_Subtract(r6, r7)
    dec_ref r6
    if is_error(r8) goto L8 (error at get_uint_strategy:88) else goto L4
L4:
    r9 = 'integers'
    r10 = object 0
    r11 = [r4, r10, r8]
    r12 = load_address r11
    r13 = ('min_value', 'max_value')
    r14 = PyObject_VectorcallMethod(r9, r12, 9223372036854775809, r13)
    if is_error(r14) goto L9 (error at get_uint_strategy:86) else goto L5
L5:
    dec_ref r4
    dec_ref r8
    return r14
L6:
    r15 = <error> :: object
    return r15
L7:
    dec_ref r1
    goto L6
L8:
    dec_ref r4
    goto L6
L9:
    dec_ref r4
    dec_ref r8
    goto L6

def get_int_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17 :: object[3]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L10 (error at get_int_strategy:95) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L11 (error at get_int_strategy:97) else goto L2
L2:
    r5 = object 1
    r6 = PyNumber_Subtract(r1, r5)
    if is_error(r6) goto L12 (error at get_int_strategy:98) else goto L3
L3:
    r7 = object 2
    r8 = CPyNumber_Power(r7, r6)
    dec_ref r6
    if is_error(r8) goto L12 (error at get_int_strategy:98) else goto L4
L4:
    r9 = PyNumber_Negative(r8)
    dec_ref r8
    if is_error(r9) goto L12 (error at get_int_strategy:98) else goto L5
L5:
    r10 = object 1
    r11 = PyNumber_Subtract(r1, r10)
    dec_ref r1
    if is_error(r11) goto L13 (error at get_int_strategy:99) else goto L6
L6:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r11)
    dec_ref r11
    if is_error(r13) goto L13 (error at get_int_strategy:99) else goto L7
L7:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L13 (error at get_int_strategy:99) else goto L8
L8:
    r16 = 'integers'
    r17 = [r4, r9, r15]
    r18 = load_address r17
    r19 = ('min_value', 'max_value')
    r20 = PyObject_VectorcallMethod(r16, r18, 9223372036854775809, r19)
    if is_error(r20) goto L14 (error at get_int_strategy:97) else goto L9
L9:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    return r20
L10:
    r21 = <error> :: object
    return r21
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r4
    goto L10
L13:
    dec_ref r4
    dec_ref r9
    goto L10
L14:
    dec_ref r4
    dec_ref r9
    dec_ref r15
    goto L10

def get_ufixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15 :: object
    r16 :: str
    r17, r18 :: object
    r19 :: object[4]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: int
    r24 :: object
    r25 :: str
    r26 :: object[2]
    r27 :: object_ptr
    r28, r29 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L19 (error at get_ufixed_strategy:110) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L19 (error at get_ufixed_strategy:110) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L20 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L19 (error at get_ufixed_strategy:110) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L21 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L19 (error at get_ufixed_strategy:110) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L22
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L19 (error at get_ufixed_strategy:110) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L23 (error at get_ufixed_strategy:112) else goto L12
L12:
    r12 = object 2
    r13 = CPyNumber_Power(r12, r3)
    dec_ref r3
    if is_error(r13) goto L24 (error at get_ufixed_strategy:114) else goto L13
L13:
    r14 = object 1
    r15 = PyNumber_Subtract(r13, r14)
    dec_ref r13
    if is_error(r15) goto L24 (error at get_ufixed_strategy:114) else goto L14
L14:
    r16 = 'decimals'
    r17 = object 0
    r18 = object 0
    r19 = [r11, r17, r15, r18]
    r20 = load_address r19
    r21 = ('min_value', 'max_value', 'places')
    r22 = PyObject_VectorcallMethod(r16, r20, 9223372036854775809, r21)
    if is_error(r22) goto L25 (error at get_ufixed_strategy:112) else goto L15
L15:
    dec_ref r11
    dec_ref r15
    r23 = unbox(int, r5)
    dec_ref r5
    if is_error(r23) goto L26 (error at get_ufixed_strategy:116) else goto L16
L16:
    r24 = scale_places(r23)
    dec_ref r23 :: int
    if is_error(r24) goto L26 (error at get_ufixed_strategy:116) else goto L17
L17:
    r25 = 'map'
    r26 = [r22, r24]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r25, r27, 9223372036854775810, 0)
    if is_error(r28) goto L27 (error at get_ufixed_strategy:112) else goto L18
L18:
    dec_ref r22
    dec_ref r24
    return r28
L19:
    r29 = <error> :: object
    return r29
L20:
    dec_ref r2
    goto L3
L21:
    dec_ref r2
    dec_ref r3
    goto L6
L22:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L23:
    dec_ref r3
    dec_ref r5
    goto L19
L24:
    dec_ref r5
    dec_ref r11
    goto L19
L25:
    dec_ref r5
    dec_ref r11
    dec_ref r15
    goto L19
L26:
    dec_ref r22
    goto L19
L27:
    dec_ref r22
    dec_ref r24
    goto L19

def get_fixed_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1, r2, r3 :: object
    r4 :: bool
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: str
    r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[4]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: int
    r30 :: object
    r31 :: str
    r32 :: object[2]
    r33 :: object_ptr
    r34, r35 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L23 (error at get_fixed_strategy:122) else goto L1
L1:
    r2 = PyObject_GetIter(r1)
    dec_ref r1
    if is_error(r2) goto L23 (error at get_fixed_strategy:122) else goto L2
L2:
    r3 = PyIter_Next(r2)
    if is_error(r3) goto L24 else goto L5
L3:
    r4 = raise ValueError('not enough values to unpack')
    if not r4 goto L23 (error at get_fixed_strategy:122) else goto L4 :: bool
L4:
    unreachable
L5:
    r5 = PyIter_Next(r2)
    if is_error(r5) goto L25 else goto L8
L6:
    r6 = raise ValueError('not enough values to unpack')
    if not r6 goto L23 (error at get_fixed_strategy:122) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = PyIter_Next(r2)
    dec_ref r2
    if is_error(r7) goto L11 else goto L26
L9:
    r8 = raise ValueError('too many values to unpack')
    if not r8 goto L23 (error at get_fixed_strategy:122) else goto L10 :: bool
L10:
    unreachable
L11:
    r9 = faster_eth_abi.tools._strategies.globals :: static
    r10 = 'st'
    r11 = CPyDict_GetItem(r9, r10)
    if is_error(r11) goto L27 (error at get_fixed_strategy:124) else goto L12
L12:
    r12 = object 1
    r13 = PyNumber_Subtract(r3, r12)
    if is_error(r13) goto L28 (error at get_fixed_strategy:125) else goto L13
L13:
    r14 = object 2
    r15 = CPyNumber_Power(r14, r13)
    dec_ref r13
    if is_error(r15) goto L28 (error at get_fixed_strategy:125) else goto L14
L14:
    r16 = PyNumber_Negative(r15)
    dec_ref r15
    if is_error(r16) goto L28 (error at get_fixed_strategy:125) else goto L15
L15:
    r17 = object 1
    r18 = PyNumber_Subtract(r3, r17)
    dec_ref r3
    if is_error(r18) goto L29 (error at get_fixed_strategy:126) else goto L16
L16:
    r19 = object 2
    r20 = CPyNumber_Power(r19, r18)
    dec_ref r18
    if is_error(r20) goto L29 (error at get_fixed_strategy:126) else goto L17
L17:
    r21 = object 1
    r22 = PyNumber_Subtract(r20, r21)
    dec_ref r20
    if is_error(r22) goto L29 (error at get_fixed_strategy:126) else goto L18
L18:
    r23 = 'decimals'
    r24 = object 0
    r25 = [r11, r16, r22, r24]
    r26 = load_address r25
    r27 = ('min_value', 'max_value', 'places')
    r28 = PyObject_VectorcallMethod(r23, r26, 9223372036854775809, r27)
    if is_error(r28) goto L30 (error at get_fixed_strategy:124) else goto L19
L19:
    dec_ref r11
    dec_ref r16
    dec_ref r22
    r29 = unbox(int, r5)
    dec_ref r5
    if is_error(r29) goto L31 (error at get_fixed_strategy:128) else goto L20
L20:
    r30 = scale_places(r29)
    dec_ref r29 :: int
    if is_error(r30) goto L31 (error at get_fixed_strategy:128) else goto L21
L21:
    r31 = 'map'
    r32 = [r28, r30]
    r33 = load_address r32
    r34 = PyObject_VectorcallMethod(r31, r33, 9223372036854775810, 0)
    if is_error(r34) goto L32 (error at get_fixed_strategy:124) else goto L22
L22:
    dec_ref r28
    dec_ref r30
    return r34
L23:
    r35 = <error> :: object
    return r35
L24:
    dec_ref r2
    goto L3
L25:
    dec_ref r2
    dec_ref r3
    goto L6
L26:
    dec_ref r3
    dec_ref r5
    dec_ref r7
    goto L9
L27:
    dec_ref r3
    dec_ref r5
    goto L23
L28:
    dec_ref r3
    dec_ref r5
    dec_ref r11
    goto L23
L29:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    goto L23
L30:
    dec_ref r5
    dec_ref r11
    dec_ref r16
    dec_ref r22
    goto L23
L31:
    dec_ref r28
    goto L23
L32:
    dec_ref r28
    dec_ref r30
    goto L23

def get_bytes_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8, r9, r10 :: object
L0:
    r0 = 'sub'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L4 (error at get_bytes_strategy:134) else goto L1
L1:
    r2 = faster_eth_abi.tools._strategies.globals :: static
    r3 = 'st'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L5 (error at get_bytes_strategy:136) else goto L2
L2:
    r5 = 'binary'
    r6 = [r4, r1, r1]
    r7 = load_address r6
    r8 = ('min_size', 'max_size')
    r9 = PyObject_VectorcallMethod(r5, r7, 9223372036854775809, r8)
    if is_error(r9) goto L6 (error at get_bytes_strategy:136) else goto L3
L3:
    dec_ref r4
    dec_ref r1
    return r9
L4:
    r10 = <error> :: object
    return r10
L5:
    dec_ref r1
    goto L4
L6:
    dec_ref r1
    dec_ref r4
    goto L4

def get_array_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9, r10, r11 :: object
    r12 :: int
    r13 :: bit
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object[2]
    r19 :: object_ptr
    r20, r21, r22 :: object
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object[4]
    r28 :: object_ptr
    r29, r30, r31 :: object
L0:
    r0 = 'item_type'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L15 (error at get_array_strategy:149) else goto L1
L1:
    r2 = 'to_type_str'
    r3 = [r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L16 (error at get_array_strategy:150) else goto L2
L2:
    dec_ref r1
    r6 = cast(str, r5)
    if is_error(r6) goto L15 (error at get_array_strategy:150) else goto L3
L3:
    r7 = registry.get_strategy(r6)
    dec_ref r6
    if is_error(r7) goto L15 (error at get_array_strategy:151) else goto L4
L4:
    r8 = 'arrlist'
    r9 = CPyObject_GetAttr(abi_type, r8)
    if is_error(r9) goto L17 (error at get_array_strategy:153) else goto L5
L5:
    r10 = object -1
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L17 (error at get_array_strategy:153) else goto L6
L6:
    r12 = CPyObject_Size(r11)
    if is_error(r12) goto L18 (error at get_array_strategy:154) else goto L7
L7:
    r13 = r12 == 0
    dec_ref r12 :: int
    if r13 goto L19 else goto L11 :: bool
L8:
    r14 = faster_eth_abi.tools._strategies.globals :: static
    r15 = 'st'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L17 (error at get_array_strategy:156) else goto L9
L9:
    r17 = 'lists'
    r18 = [r16, r7]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775810, 0)
    if is_error(r20) goto L20 (error at get_array_strategy:156) else goto L10
L10:
    dec_ref r16
    dec_ref r7
    return r20
L11:
    r21 = object 0
    r22 = PyObject_GetItem(r11, r21)
    dec_ref r11
    if is_error(r22) goto L17 (error at get_array_strategy:159) else goto L12
L12:
    r23 = faster_eth_abi.tools._strategies.globals :: static
    r24 = 'st'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L21 (error at get_array_strategy:160) else goto L13
L13:
    r26 = 'lists'
    r27 = [r25, r7, r22, r22]
    r28 = load_address r27
    r29 = ('min_size', 'max_size')
    r30 = PyObject_VectorcallMethod(r26, r28, 9223372036854775810, r29)
    if is_error(r30) goto L22 (error at get_array_strategy:160) else goto L14
L14:
    dec_ref r25
    dec_ref r7
    dec_ref r22
    return r30
L15:
    r31 = <error> :: object
    return r31
L16:
    dec_ref r1
    goto L15
L17:
    dec_ref r7
    goto L15
L18:
    dec_ref r7
    dec_ref r11
    goto L15
L19:
    dec_ref r11
    goto L8
L20:
    dec_ref r7
    dec_ref r16
    goto L15
L21:
    dec_ref r7
    dec_ref r22
    goto L15
L22:
    dec_ref r7
    dec_ref r22
    dec_ref r25
    goto L15

def get_tuple_strategy(abi_type, registry):
    abi_type :: object
    registry :: faster_eth_abi.tools._strategies.StrategyRegistry
    r0 :: str
    r1 :: object
    r2 :: tuple
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: ptr
    r7, r8 :: native_int
    r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: native_int
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: tuple
    r24, r25 :: object
L0:
    r0 = 'components'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L15 (error at get_tuple_strategy:168) else goto L1
L1:
    r2 = cast(tuple, r1)
    if is_error(r2) goto L15 (error at get_tuple_strategy:168) else goto L2
L2:
    r3 = get_element_ptr r2 ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L16 (error at get_tuple_strategy:166) else goto L3
L3:
    r6 = get_element_ptr r2 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = 0
L4:
    r9 = r8 < r7 :: signed
    if r9 goto L5 else goto L17 :: bool
L5:
    r10 = CPySequenceTuple_GetItemUnsafe(r2, r8)
    r11 = 'to_type_str'
    r12 = [r10]
    r13 = load_address r12
    r14 = PyObject_VectorcallMethod(r11, r13, 9223372036854775809, 0)
    if is_error(r14) goto L18 (error at get_tuple_strategy:167) else goto L6
L6:
    dec_ref r10
    r15 = cast(str, r14)
    if is_error(r15) goto L19 (error at get_tuple_strategy:167) else goto L7
L7:
    r16 = registry.get_strategy(r15)
    dec_ref r15
    if is_error(r16) goto L19 (error at get_tuple_strategy:167) else goto L8
L8:
    CPyList_SetItemUnsafe(r5, r8, r16)
L9:
    r17 = r8 + 1
    r8 = r17
    goto L4
L10:
    r18 = faster_eth_abi.tools._strategies.globals :: static
    r19 = 'st'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at get_tuple_strategy:171) else goto L11
L11:
    r21 = 'tuples'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L20 (error at get_tuple_strategy:171) else goto L12
L12:
    r23 = PyList_AsTuple(r5)
    dec_ref r5
    if is_error(r23) goto L21 (error at get_tuple_strategy:171) else goto L13
L13:
    r24 = PyObject_CallObject(r22, r23)
    dec_ref r22
    dec_ref r23
    if is_error(r24) goto L15 (error at get_tuple_strategy:171) else goto L14
L14:
    return r24
L15:
    r25 = <error> :: object
    return r25
L16:
    dec_ref r2
    goto L15
L17:
    dec_ref r2
    goto L10
L18:
    dec_ref r2
    dec_ref r5
    dec_ref r10
    goto L15
L19:
    dec_ref r2
    dec_ref r5
    goto L15
L20:
    dec_ref r5
    goto L15
L21:
    dec_ref r22
    goto L15

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17, r18 :: object
    r19 :: str
    r20 :: dict
    r21, r22 :: object
    r23 :: str
    r24 :: dict
    r25, r26 :: object
    r27 :: str
    r28 :: dict
    r29, r30 :: object
    r31 :: str
    r32 :: dict
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: tuple[list, object]
    r51, r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58 :: str
    r59 :: object
    r60 :: dict
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: tuple[object, object]
    r69, r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: tuple
    r79 :: str
    r80, r81 :: object
    r82 :: bool
    r83, r84, r85 :: str
    r86 :: tuple
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: str
    r97, r98 :: object
    r99 :: object[3]
    r100 :: object_ptr
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: str
    r107 :: object[2]
    r108 :: object_ptr
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: str
    r118 :: object[1]
    r119 :: object_ptr
    r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: str
    r129, r130 :: object
    r131 :: object[3]
    r132 :: object_ptr
    r133, r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: i32
    r138 :: bit
    r139 :: dict
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: object[1]
    r144 :: object_ptr
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: i32
    r149 :: bit
    r150 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r151 :: dict
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r156 :: bool
    r157 :: str
    r158 :: union[bool, None]
    r159 :: faster_eth_abi._registry.BaseEquals
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: None
    r165 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r166 :: bool
    r167 :: str
    r168 :: union[bool, None]
    r169 :: faster_eth_abi._registry.BaseEquals
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: str
    r174 :: None
    r175 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r176 :: bool
    r177 :: str
    r178 :: object
    r179 :: faster_eth_abi._registry.BaseEquals
    r180 :: object
    r181 :: bool
    r182 :: str
    r183 :: None
    r184 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r185 :: bool
    r186 :: str
    r187 :: object
    r188 :: faster_eth_abi._registry.BaseEquals
    r189 :: object
    r190 :: bool
    r191 :: str
    r192 :: None
    r193 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r194 :: bool
    r195 :: str
    r196 :: union[bool, None]
    r197 :: faster_eth_abi._registry.BaseEquals
    r198 :: dict
    r199 :: str
    r200 :: object
    r201 :: str
    r202 :: None
    r203 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r204 :: bool
    r205 :: str
    r206 :: union[bool, None]
    r207 :: faster_eth_abi._registry.BaseEquals
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: str
    r212 :: None
    r213 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r214 :: bool
    r215 :: str
    r216 :: object
    r217 :: faster_eth_abi._registry.BaseEquals
    r218 :: dict
    r219 :: str
    r220 :: object
    r221 :: str
    r222 :: None
    r223 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r224 :: bool
    r225 :: str
    r226 :: object
    r227 :: faster_eth_abi._registry.BaseEquals
    r228 :: object
    r229 :: bool
    r230 :: str
    r231 :: None
    r232 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r233 :: bool
    r234 :: str
    r235 :: object
    r236 :: faster_eth_abi._registry.BaseEquals
    r237 :: dict
    r238 :: str
    r239 :: object
    r240 :: str
    r241 :: None
    r242 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r243 :: bool
    r244 :: str
    r245 :: object
    r246 :: faster_eth_abi._registry.BaseEquals
    r247 :: object
    r248 :: bool
    r249 :: str
    r250 :: None
    r251 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r252 :: bool
    r253 :: dict
    r254 :: str
    r255 :: object
    r256 :: dict
    r257 :: str
    r258 :: object
    r259 :: str
    r260 :: None
    r261 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r262 :: bool
    r263 :: dict
    r264 :: str
    r265 :: object
    r266 :: dict
    r267 :: str
    r268 :: object
    r269 :: str
    r270 :: None
    r271 :: faster_eth_abi.tools._strategies.StrategyRegistry
    r272 :: bool
    r273 :: str
    r274 :: object
    r275 :: dict
    r276 :: str
    r277 :: i32
    r278 :: bit
    r279 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L132 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Callable', 'Final', 'Optional', 'Union')
    r6 = 'typing'
    r7 = faster_eth_abi.tools._strategies.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L132 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('to_checksum_address',)
    r10 = 'cchecksum'
    r11 = faster_eth_abi.tools._strategies.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L132 (error at <module>:8) else goto L5
L5:
    cchecksum = r12 :: module
    dec_ref r12
    r13 = ('TypeStr',)
    r14 = 'eth_typing.abi'
    r15 = faster_eth_abi.tools._strategies.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L132 (error at <module>:11) else goto L6
L6:
    eth_typing.abi = r16 :: module
    dec_ref r16
    r17 = ('strategies',)
    r18 = ('st',)
    r19 = 'hypothesis'
    r20 = faster_eth_abi.tools._strategies.globals :: static
    r21 = CPyImport_ImportFromMany(r19, r17, r18, r20)
    if is_error(r21) goto L132 (error at <module>:14) else goto L7
L7:
    hypothesis = r21 :: module
    dec_ref r21
    r22 = ('ABIType', 'BasicType', 'TupleType', 'normalize', 'parse')
    r23 = 'faster_eth_abi.grammar'
    r24 = faster_eth_abi.tools._strategies.globals :: static
    r25 = CPyImport_ImportFromMany(r23, r22, r22, r24)
    if is_error(r25) goto L132 (error at <module>:18) else goto L8
L8:
    faster_eth_abi.grammar = r25 :: module
    dec_ref r25
    r26 = ('BaseEquals', 'BaseRegistry', 'Lookup', 'PredicateMapping', 'has_arrlist', 'is_base_tuple')
    r27 = 'faster_eth_abi.registry'
    r28 = faster_eth_abi.tools._strategies.globals :: static
    r29 = CPyImport_ImportFromMany(r27, r26, r26, r28)
    if is_error(r29) goto L132 (error at <module>:25) else goto L9
L9:
    faster_eth_abi.registry = r29 :: module
    dec_ref r29
    r30 = ('scale_places',)
    r31 = 'faster_eth_abi.utils.numeric'
    r32 = faster_eth_abi.tools._strategies.globals :: static
    r33 = CPyImport_ImportFromMany(r31, r30, r30, r32)
    if is_error(r33) goto L132 (error at <module>:33) else goto L10
L10:
    faster_eth_abi.utils.numeric = r33 :: module
    dec_ref r33
    r34 = faster_eth_abi.tools._strategies.globals :: static
    r35 = 'Callable'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L132 (error at <module>:37) else goto L11
L11:
    r37 = faster_eth_abi.tools._strategies.globals :: static
    r38 = 'ABIType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L133 (error at <module>:37) else goto L12
L12:
    r40 = 'StrategyRegistry'
    r41 = PyList_New(2)
    if is_error(r41) goto L134 (error at <module>:37) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = faster_eth_abi.tools._strategies.globals :: static
    r46 = 'st'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L135 (error at <module>:37) else goto L14
L14:
    r48 = 'SearchStrategy'
    r49 = CPyObject_GetAttr(r47, r48)
    dec_ref r47
    if is_error(r49) goto L135 (error at <module>:37) else goto L15
L15:
    r50 = (r41, r49)
    r51 = box(tuple[list, object], r50)
    r52 = PyObject_GetItem(r36, r51)
    dec_ref r36
    dec_ref r51
    if is_error(r52) goto L132 (error at <module>:37) else goto L16
L16:
    r53 = faster_eth_abi.tools._strategies.globals :: static
    r54 = 'StrategyFactory'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L132 (error at <module>:37) else goto L17 :: bool
L17:
    r57 = faster_eth_abi.tools._strategies.globals :: static
    r58 = 'Union'
    r59 = CPyDict_GetItem(r57, r58)
    if is_error(r59) goto L132 (error at <module>:38) else goto L18
L18:
    r60 = faster_eth_abi.tools._strategies.globals :: static
    r61 = 'st'
    r62 = CPyDict_GetItem(r60, r61)
    if is_error(r62) goto L136 (error at <module>:38) else goto L19
L19:
    r63 = 'SearchStrategy'
    r64 = CPyObject_GetAttr(r62, r63)
    dec_ref r62
    if is_error(r64) goto L136 (error at <module>:38) else goto L20
L20:
    r65 = faster_eth_abi.tools._strategies.globals :: static
    r66 = 'StrategyFactory'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L137 (error at <module>:38) else goto L21
L21:
    r68 = (r64, r67)
    r69 = box(tuple[object, object], r68)
    r70 = PyObject_GetItem(r59, r69)
    dec_ref r59
    dec_ref r69
    if is_error(r70) goto L132 (error at <module>:38) else goto L22
L22:
    r71 = faster_eth_abi.tools._strategies.globals :: static
    r72 = 'StrategyRegistration'
    r73 = CPyDict_SetItem(r71, r72, r70)
    dec_ref r70
    r74 = r73 >= 0 :: signed
    if not r74 goto L132 (error at <module>:38) else goto L23 :: bool
L23:
    r75 = faster_eth_abi.tools._strategies.globals :: static
    r76 = 'BaseRegistry'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L132 (error at <module>:41) else goto L24
L24:
    r78 = PyTuple_Pack(1, r77)
    dec_ref r77
    if is_error(r78) goto L132 (error at <module>:41) else goto L25
L25:
    r79 = 'faster_eth_abi.tools._strategies'
    r80 = faster_eth_abi.tools._strategies.StrategyRegistry_template :: type
    r81 = CPyType_FromTemplate(r80, r78, r79)
    dec_ref r78
    if is_error(r81) goto L132 (error at <module>:41) else goto L26
L26:
    r82 = StrategyRegistry_trait_vtable_setup()
    if is_error(r82) goto L138 (error at <module>:-1) else goto L27
L27:
    r83 = '__mypyc_attrs__'
    r84 = '_strategies'
    r85 = '__dict__'
    r86 = PyTuple_Pack(2, r84, r85)
    if is_error(r86) goto L138 (error at <module>:41) else goto L28
L28:
    r87 = PyObject_SetAttr(r81, r83, r86)
    dec_ref r86
    r88 = r87 >= 0 :: signed
    if not r88 goto L138 (error at <module>:41) else goto L29 :: bool
L29:
    faster_eth_abi.tools._strategies.StrategyRegistry = r81 :: type
    r89 = faster_eth_abi.tools._strategies.globals :: static
    r90 = 'StrategyRegistry'
    r91 = PyDict_SetItem(r89, r90, r81)
    dec_ref r81
    r92 = r91 >= 0 :: signed
    if not r92 goto L132 (error at <module>:41) else goto L30 :: bool
L30:
    r93 = faster_eth_abi.tools._strategies.globals :: static
    r94 = 'st'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L132 (error at <module>:103) else goto L31
L31:
    r96 = 'binary'
    r97 = object 20
    r98 = object 20
    r99 = [r95, r97, r98]
    r100 = load_address r99
    r101 = ('min_size', 'max_size')
    r102 = PyObject_VectorcallMethod(r96, r100, 9223372036854775809, r101)
    if is_error(r102) goto L139 (error at <module>:103) else goto L32
L32:
    dec_ref r95
    r103 = faster_eth_abi.tools._strategies.globals :: static
    r104 = 'to_checksum_address'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L140 (error at <module>:103) else goto L33
L33:
    r106 = 'map'
    r107 = [r102, r105]
    r108 = load_address r107
    r109 = PyObject_VectorcallMethod(r106, r108, 9223372036854775810, 0)
    if is_error(r109) goto L141 (error at <module>:103) else goto L34
L34:
    dec_ref r102
    dec_ref r105
    faster_eth_abi.tools._strategies.address_strategy = r109 :: static
    r110 = faster_eth_abi.tools._strategies.globals :: static
    r111 = 'address_strategy'
    r112 = CPyDict_SetItem(r110, r111, r109)
    dec_ref r109
    r113 = r112 >= 0 :: signed
    if not r113 goto L132 (error at <module>:103) else goto L35 :: bool
L35:
    r114 = faster_eth_abi.tools._strategies.globals :: static
    r115 = 'st'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L132 (error at <module>:104) else goto L36
L36:
    r117 = 'booleans'
    r118 = [r116]
    r119 = load_address r118
    r120 = PyObject_VectorcallMethod(r117, r119, 9223372036854775809, 0)
    if is_error(r120) goto L142 (error at <module>:104) else goto L37
L37:
    dec_ref r116
    faster_eth_abi.tools._strategies.bool_strategy = r120 :: static
    r121 = faster_eth_abi.tools._strategies.globals :: static
    r122 = 'bool_strategy'
    r123 = CPyDict_SetItem(r121, r122, r120)
    dec_ref r120
    r124 = r123 >= 0 :: signed
    if not r124 goto L132 (error at <module>:104) else goto L38 :: bool
L38:
    r125 = faster_eth_abi.tools._strategies.globals :: static
    r126 = 'st'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L132 (error at <module>:142) else goto L39
L39:
    r128 = 'binary'
    r129 = object 0
    r130 = object 4096
    r131 = [r127, r129, r130]
    r132 = load_address r131
    r133 = ('min_size', 'max_size')
    r134 = PyObject_VectorcallMethod(r128, r132, 9223372036854775809, r133)
    if is_error(r134) goto L143 (error at <module>:142) else goto L40
L40:
    dec_ref r127
    faster_eth_abi.tools._strategies.bytes_strategy = r134 :: static
    r135 = faster_eth_abi.tools._strategies.globals :: static
    r136 = 'bytes_strategy'
    r137 = CPyDict_SetItem(r135, r136, r134)
    dec_ref r134
    r138 = r137 >= 0 :: signed
    if not r138 goto L132 (error at <module>:142) else goto L41 :: bool
L41:
    r139 = faster_eth_abi.tools._strategies.globals :: static
    r140 = 'st'
    r141 = CPyDict_GetItem(r139, r140)
    if is_error(r141) goto L132 (error at <module>:143) else goto L42
L42:
    r142 = 'text'
    r143 = [r141]
    r144 = load_address r143
    r145 = PyObject_VectorcallMethod(r142, r144, 9223372036854775809, 0)
    if is_error(r145) goto L144 (error at <module>:143) else goto L43
L43:
    dec_ref r141
    faster_eth_abi.tools._strategies.string_strategy = r145 :: static
    r146 = faster_eth_abi.tools._strategies.globals :: static
    r147 = 'string_strategy'
    r148 = CPyDict_SetItem(r146, r147, r145)
    dec_ref r145
    r149 = r148 >= 0 :: signed
    if not r149 goto L132 (error at <module>:143) else goto L44 :: bool
L44:
    r150 = StrategyRegistry()
    if is_error(r150) goto L132 (error at <module>:174) else goto L45
L45:
    faster_eth_abi.tools._strategies.strategy_registry = r150 :: static
    r151 = faster_eth_abi.tools._strategies.globals :: static
    r152 = 'strategy_registry'
    r153 = CPyDict_SetItem(r151, r152, r150)
    dec_ref r150
    r154 = r153 >= 0 :: signed
    if not r154 goto L132 (error at <module>:174) else goto L46 :: bool
L46:
    r155 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r155) goto L47 else goto L49
L47:
    r156 = raise NameError('value for final name "strategy_registry" was not set')
    if not r156 goto L132 (error at <module>:176) else goto L48 :: bool
L48:
    unreachable
L49:
    r157 = 'uint'
    r158 = <error> :: union[bool, None]
    r159 = BaseEquals(r157, r158)
    if is_error(r159) goto L132 (error at <module>:177) else goto L50
L50:
    r160 = faster_eth_abi.tools._strategies.globals :: static
    r161 = 'get_uint_strategy'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L145 (error at <module>:178) else goto L51
L51:
    r163 = 'uint'
    r164 = r155.register_strategy(r159, r162, r163)
    dec_ref r159
    dec_ref r162
    if is_error(r164) goto L132 (error at <module>:176) else goto L52
L52:
    r165 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r165) goto L53 else goto L55
L53:
    r166 = raise NameError('value for final name "strategy_registry" was not set')
    if not r166 goto L132 (error at <module>:181) else goto L54 :: bool
L54:
    unreachable
L55:
    r167 = 'int'
    r168 = <error> :: union[bool, None]
    r169 = BaseEquals(r167, r168)
    if is_error(r169) goto L132 (error at <module>:182) else goto L56
L56:
    r170 = faster_eth_abi.tools._strategies.globals :: static
    r171 = 'get_int_strategy'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L146 (error at <module>:183) else goto L57
L57:
    r173 = 'int'
    r174 = r165.register_strategy(r169, r172, r173)
    dec_ref r169
    dec_ref r172
    if is_error(r174) goto L132 (error at <module>:181) else goto L58
L58:
    r175 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r175) goto L59 else goto L61
L59:
    r176 = raise NameError('value for final name "strategy_registry" was not set')
    if not r176 goto L132 (error at <module>:186) else goto L60 :: bool
L60:
    unreachable
L61:
    r177 = 'address'
    r178 = box(bool, 0)
    r179 = BaseEquals(r177, r178)
    if is_error(r179) goto L132 (error at <module>:187) else goto L62
L62:
    r180 = faster_eth_abi.tools._strategies.address_strategy :: static
    if is_error(r180) goto L147 else goto L65
L63:
    r181 = raise NameError('value for final name "address_strategy" was not set')
    if not r181 goto L132 (error at <module>:188) else goto L64 :: bool
L64:
    unreachable
L65:
    r182 = 'address'
    r183 = r175.register_strategy(r179, r180, r182)
    dec_ref r179
    if is_error(r183) goto L132 (error at <module>:186) else goto L66
L66:
    r184 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r184) goto L67 else goto L69
L67:
    r185 = raise NameError('value for final name "strategy_registry" was not set')
    if not r185 goto L132 (error at <module>:191) else goto L68 :: bool
L68:
    unreachable
L69:
    r186 = 'bool'
    r187 = box(bool, 0)
    r188 = BaseEquals(r186, r187)
    if is_error(r188) goto L132 (error at <module>:192) else goto L70
L70:
    r189 = faster_eth_abi.tools._strategies.bool_strategy :: static
    if is_error(r189) goto L148 else goto L73
L71:
    r190 = raise NameError('value for final name "bool_strategy" was not set')
    if not r190 goto L132 (error at <module>:193) else goto L72 :: bool
L72:
    unreachable
L73:
    r191 = 'bool'
    r192 = r184.register_strategy(r188, r189, r191)
    dec_ref r188
    if is_error(r192) goto L132 (error at <module>:191) else goto L74
L74:
    r193 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r193) goto L75 else goto L77
L75:
    r194 = raise NameError('value for final name "strategy_registry" was not set')
    if not r194 goto L132 (error at <module>:196) else goto L76 :: bool
L76:
    unreachable
L77:
    r195 = 'ufixed'
    r196 = <error> :: union[bool, None]
    r197 = BaseEquals(r195, r196)
    if is_error(r197) goto L132 (error at <module>:197) else goto L78
L78:
    r198 = faster_eth_abi.tools._strategies.globals :: static
    r199 = 'get_ufixed_strategy'
    r200 = CPyDict_GetItem(r198, r199)
    if is_error(r200) goto L149 (error at <module>:198) else goto L79
L79:
    r201 = 'ufixed'
    r202 = r193.register_strategy(r197, r200, r201)
    dec_ref r197
    dec_ref r200
    if is_error(r202) goto L132 (error at <module>:196) else goto L80
L80:
    r203 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r203) goto L81 else goto L83
L81:
    r204 = raise NameError('value for final name "strategy_registry" was not set')
    if not r204 goto L132 (error at <module>:201) else goto L82 :: bool
L82:
    unreachable
L83:
    r205 = 'fixed'
    r206 = <error> :: union[bool, None]
    r207 = BaseEquals(r205, r206)
    if is_error(r207) goto L132 (error at <module>:202) else goto L84
L84:
    r208 = faster_eth_abi.tools._strategies.globals :: static
    r209 = 'get_fixed_strategy'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L150 (error at <module>:203) else goto L85
L85:
    r211 = 'fixed'
    r212 = r203.register_strategy(r207, r210, r211)
    dec_ref r207
    dec_ref r210
    if is_error(r212) goto L132 (error at <module>:201) else goto L86
L86:
    r213 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r213) goto L87 else goto L89
L87:
    r214 = raise NameError('value for final name "strategy_registry" was not set')
    if not r214 goto L132 (error at <module>:206) else goto L88 :: bool
L88:
    unreachable
L89:
    r215 = 'bytes'
    r216 = box(bool, 1)
    r217 = BaseEquals(r215, r216)
    if is_error(r217) goto L132 (error at <module>:207) else goto L90
L90:
    r218 = faster_eth_abi.tools._strategies.globals :: static
    r219 = 'get_bytes_strategy'
    r220 = CPyDict_GetItem(r218, r219)
    if is_error(r220) goto L151 (error at <module>:208) else goto L91
L91:
    r221 = 'bytes<M>'
    r222 = r213.register_strategy(r217, r220, r221)
    dec_ref r217
    dec_ref r220
    if is_error(r222) goto L132 (error at <module>:206) else goto L92
L92:
    r223 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r223) goto L93 else goto L95
L93:
    r224 = raise NameError('value for final name "strategy_registry" was not set')
    if not r224 goto L132 (error at <module>:211) else goto L94 :: bool
L94:
    unreachable
L95:
    r225 = 'bytes'
    r226 = box(bool, 0)
    r227 = BaseEquals(r225, r226)
    if is_error(r227) goto L132 (error at <module>:212) else goto L96
L96:
    r228 = faster_eth_abi.tools._strategies.bytes_strategy :: static
    if is_error(r228) goto L152 else goto L99
L97:
    r229 = raise NameError('value for final name "bytes_strategy" was not set')
    if not r229 goto L132 (error at <module>:213) else goto L98 :: bool
L98:
    unreachable
L99:
    r230 = 'bytes'
    r231 = r223.register_strategy(r227, r228, r230)
    dec_ref r227
    if is_error(r231) goto L132 (error at <module>:211) else goto L100
L100:
    r232 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r232) goto L101 else goto L103
L101:
    r233 = raise NameError('value for final name "strategy_registry" was not set')
    if not r233 goto L132 (error at <module>:216) else goto L102 :: bool
L102:
    unreachable
L103:
    r234 = 'function'
    r235 = box(bool, 0)
    r236 = BaseEquals(r234, r235)
    if is_error(r236) goto L132 (error at <module>:217) else goto L104
L104:
    r237 = faster_eth_abi.tools._strategies.globals :: static
    r238 = 'get_bytes_strategy'
    r239 = CPyDict_GetItem(r237, r238)
    if is_error(r239) goto L153 (error at <module>:218) else goto L105
L105:
    r240 = 'function'
    r241 = r232.register_strategy(r236, r239, r240)
    dec_ref r236
    dec_ref r239
    if is_error(r241) goto L132 (error at <module>:216) else goto L106
L106:
    r242 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r242) goto L107 else goto L109
L107:
    r243 = raise NameError('value for final name "strategy_registry" was not set')
    if not r243 goto L132 (error at <module>:221) else goto L108 :: bool
L108:
    unreachable
L109:
    r244 = 'string'
    r245 = box(bool, 0)
    r246 = BaseEquals(r244, r245)
    if is_error(r246) goto L132 (error at <module>:222) else goto L110
L110:
    r247 = faster_eth_abi.tools._strategies.string_strategy :: static
    if is_error(r247) goto L154 else goto L113
L111:
    r248 = raise NameError('value for final name "string_strategy" was not set')
    if not r248 goto L132 (error at <module>:223) else goto L112 :: bool
L112:
    unreachable
L113:
    r249 = 'string'
    r250 = r242.register_strategy(r246, r247, r249)
    dec_ref r246
    if is_error(r250) goto L132 (error at <module>:221) else goto L114
L114:
    r251 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r251) goto L115 else goto L117
L115:
    r252 = raise NameError('value for final name "strategy_registry" was not set')
    if not r252 goto L132 (error at <module>:226) else goto L116 :: bool
L116:
    unreachable
L117:
    r253 = faster_eth_abi.tools._strategies.globals :: static
    r254 = 'has_arrlist'
    r255 = CPyDict_GetItem(r253, r254)
    if is_error(r255) goto L132 (error at <module>:227) else goto L118
L118:
    r256 = faster_eth_abi.tools._strategies.globals :: static
    r257 = 'get_array_strategy'
    r258 = CPyDict_GetItem(r256, r257)
    if is_error(r258) goto L155 (error at <module>:228) else goto L119
L119:
    r259 = 'has_arrlist'
    r260 = r251.register_strategy(r255, r258, r259)
    dec_ref r255
    dec_ref r258
    if is_error(r260) goto L132 (error at <module>:226) else goto L120
L120:
    r261 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r261) goto L121 else goto L123
L121:
    r262 = raise NameError('value for final name "strategy_registry" was not set')
    if not r262 goto L132 (error at <module>:231) else goto L122 :: bool
L122:
    unreachable
L123:
    r263 = faster_eth_abi.tools._strategies.globals :: static
    r264 = 'is_base_tuple'
    r265 = CPyDict_GetItem(r263, r264)
    if is_error(r265) goto L132 (error at <module>:232) else goto L124
L124:
    r266 = faster_eth_abi.tools._strategies.globals :: static
    r267 = 'get_tuple_strategy'
    r268 = CPyDict_GetItem(r266, r267)
    if is_error(r268) goto L156 (error at <module>:233) else goto L125
L125:
    r269 = 'is_base_tuple'
    r270 = r261.register_strategy(r265, r268, r269)
    dec_ref r265
    dec_ref r268
    if is_error(r270) goto L132 (error at <module>:231) else goto L126
L126:
    r271 = faster_eth_abi.tools._strategies.strategy_registry :: static
    if is_error(r271) goto L127 else goto L129
L127:
    r272 = raise NameError('value for final name "strategy_registry" was not set')
    if not r272 goto L132 (error at <module>:237) else goto L128 :: bool
L128:
    unreachable
L129:
    r273 = 'get_strategy'
    r274 = CPyObject_GetAttr(r271, r273)
    if is_error(r274) goto L132 (error at <module>:237) else goto L130
L130:
    faster_eth_abi.tools._strategies.get_abi_strategy = r274 :: static
    r275 = faster_eth_abi.tools._strategies.globals :: static
    r276 = 'get_abi_strategy'
    r277 = CPyDict_SetItem(r275, r276, r274)
    dec_ref r274
    r278 = r277 >= 0 :: signed
    if not r278 goto L132 (error at <module>:237) else goto L131 :: bool
L131:
    return 1
L132:
    r279 = <error> :: None
    return r279
L133:
    dec_ref r36
    goto L132
L134:
    dec_ref r36
    dec_ref r39
    goto L132
L135:
    dec_ref r36
    dec_ref r41
    goto L132
L136:
    dec_ref r59
    goto L132
L137:
    dec_ref r59
    dec_ref r64
    goto L132
L138:
    dec_ref r81
    goto L132
L139:
    dec_ref r95
    goto L132
L140:
    dec_ref r102
    goto L132
L141:
    dec_ref r102
    dec_ref r105
    goto L132
L142:
    dec_ref r116
    goto L132
L143:
    dec_ref r127
    goto L132
L144:
    dec_ref r141
    goto L132
L145:
    dec_ref r159
    goto L132
L146:
    dec_ref r169
    goto L132
L147:
    dec_ref r179
    goto L63
L148:
    dec_ref r188
    goto L71
L149:
    dec_ref r197
    goto L132
L150:
    dec_ref r207
    goto L132
L151:
    dec_ref r217
    goto L132
L152:
    dec_ref r227
    goto L97
L153:
    dec_ref r236
    goto L132
L154:
    dec_ref r246
    goto L111
L155:
    dec_ref r255
    goto L132
L156:
    dec_ref r265
    goto L132

def encode_c(self, types, args):
    self, types, args :: object
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11, r12 :: bytes
L0:
    r0 = 'args'
    r1 = validate_list_like_param(args, r0)
    if is_error(r1) goto L8 (error at encode_c:42) else goto L1
L1:
    r2 = '_registry'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L8 (error at encode_c:44) else goto L2
L2:
    r4 = 'get_tuple_encoder'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L8 (error at encode_c:44) else goto L3
L3:
    r6 = PySequence_Tuple(types)
    if is_error(r6) goto L9 (error at encode_c:44) else goto L4
L4:
    r7 = PyObject_CallObject(r5, r6)
    dec_ref r5
    dec_ref r6
    if is_error(r7) goto L8 (error at encode_c:44) else goto L5
L5:
    r8 = [args]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L8 (error at encode_c:46) else goto L6
L6:
    r11 = cast(bytes, r10)
    if is_error(r11) goto L8 (error at encode_c:46) else goto L7
L7:
    return r11
L8:
    r12 = <error> :: bytes
    return r12
L9:
    dec_ref r5
    goto L8

def decode_c(self, types, data, strict):
    self, types :: object
    data :: union[bytes, object]
    strict :: bool
    r0 :: str
    r1 :: None
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: str
    r9 :: tuple
    r10 :: object
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: tuple
L0:
    if is_error(strict) goto L1 else goto L2
L1:
    strict = 1
L2:
    r0 = 'data'
    r1 = validate_bytes_param(data, r0)
    if is_error(r1) goto L14 (error at decode_c:72) else goto L3
L3:
    r2 = '_registry'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L14 (error at decode_c:74) else goto L4
L4:
    r4 = 'get_tuple_decoder'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L14 (error at decode_c:74) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L15 (error at decode_c:74) else goto L6
L6:
    r7 = CPyList_Extend(r6, types)
    if is_error(r7) goto L16 (error at decode_c:74) else goto L17
L7:
    r8 = 'strict'
    r9 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r9) goto L15 (error at decode_c:74) else goto L8
L8:
    r10 = box(bool, strict)
    r11 = CPyDict_Build(1, r8, r10)
    if is_error(r11) goto L18 (error at decode_c:74) else goto L9
L9:
    r12 = PyObject_Call(r5, r9, r11)
    dec_ref r5
    dec_ref r9
    dec_ref r11
    if is_error(r12) goto L14 (error at decode_c:74) else goto L10
L10:
    r13 = 'stream_class'
    r14 = [self, data]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L19 (error at decode_c:75) else goto L11
L11:
    r17 = [r16]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r12, r18, 1, 0)
    dec_ref r12
    if is_error(r19) goto L20 (error at decode_c:77) else goto L12
L12:
    dec_ref r16
    r20 = cast(tuple, r19)
    if is_error(r20) goto L14 (error at decode_c:77) else goto L13
L13:
    return r20
L14:
    r21 = <error> :: tuple
    return r21
L15:
    dec_ref r5
    goto L14
L16:
    dec_ref r5
    dec_ref r6
    goto L14
L17:
    dec_ref r7
    goto L7
L18:
    dec_ref r5
    dec_ref r9
    goto L14
L19:
    dec_ref r12
    goto L14
L20:
    dec_ref r16
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L8 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'Iterable', 'Tuple')
    r6 = 'typing'
    r7 = faster_eth_abi._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L8 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('Decodable', 'TypeStr')
    r10 = 'eth_typing'
    r11 = faster_eth_abi._codec.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L8 (error at <module>:8) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('validate_bytes_param', 'validate_list_like_param')
    r14 = 'faster_eth_abi.utils.validation'
    r15 = faster_eth_abi._codec.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L8 (error at <module>:13) else goto L6
L6:
    faster_eth_abi.utils.validation = r16 :: module
    dec_ref r16
    if 0 goto L7 else goto L7 :: bool
L7:
    return 1
L8:
    r17 = <error> :: None
    return r17

def Copyable.copy(self):
    self :: faster_eth_abi._registry.Copyable
L0:
    unreachable

def Copyable.__copy__(self):
    self, r0, r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = self.copy()
    if is_error(r0) goto L2 (error at __copy__:47) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def Copyable.__deepcopy__(self, args):
    self :: faster_eth_abi._registry.Copyable
    args :: tuple
    r0, r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = self.copy()
    if is_error(r0) goto L2 (error at __deepcopy__:50) else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def PredicateMapping.__init__(self, name):
    self :: faster_eth_abi._registry.PredicateMapping
    name :: str
    r0 :: bool
    r1 :: dict
    r2 :: bool
    r3 :: dict
    r4 :: bool
    r5 :: None
L0:
    inc_ref name
    self._name = name; r0 = is_error
    if not r0 goto L6 (error at __init__:62) else goto L1 :: bool
L1:
    r1 = PyDict_New()
    if is_error(r1) goto L6 (error at __init__:63) else goto L2
L2:
    self._values = r1; r2 = is_error
    if not r2 goto L6 (error at __init__:63) else goto L3 :: bool
L3:
    r3 = PyDict_New()
    if is_error(r3) goto L6 (error at __init__:64) else goto L4
L4:
    self._labeled_predicates = r3; r4 = is_error
    if not r4 goto L6 (error at __init__:64) else goto L5 :: bool
L5:
    return 1
L6:
    r5 = <error> :: None
    return r5

def PredicateMapping.add(self, predicate, value, label):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: faster_eth_abi._registry.Predicate
    value :: str
    label :: union[str, None]
    r0 :: object
    r1 :: dict
    r2 :: i32
    r3 :: bit
    r4 :: bool
    r5, r6, r7, r8, r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13, r14, r15, r16, r17, r18 :: str
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: str
    r23 :: list
    r24, r25, r26, r27, r28 :: ptr
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: bit
    r38 :: dict
    r39 :: str
    r40 :: i32
    r41 :: bit
    r42 :: bool
    r43, r44, r45, r46, r47 :: str
    r48 :: object[3]
    r49 :: object_ptr
    r50 :: object
    r51, r52, r53, r54, r55, r56 :: str
    r57 :: object[3]
    r58 :: object_ptr
    r59 :: object
    r60, r61, r62, r63, r64, r65 :: str
    r66 :: object[3]
    r67 :: object_ptr
    r68 :: object
    r69 :: str
    r70 :: list
    r71, r72, r73, r74, r75, r76, r77 :: ptr
    r78 :: str
    r79 :: object
    r80 :: str
    r81 :: object
    r82 :: object[1]
    r83 :: object_ptr
    r84 :: object
    r85 :: str
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: i32
    r90 :: bit
    r91 :: None
L0:
    if is_error(label) goto L1 else goto L41
L1:
    r0 = box(None, 1)
    inc_ref r0
    label = r0
L2:
    r1 = self._values
    if is_error(r1) goto L42 (error at add:67) else goto L3
L3:
    r2 = PyDict_Contains(r1, predicate)
    dec_ref r1
    r3 = r2 >= 0 :: signed
    if not r3 goto L42 (error at add:67) else goto L4 :: bool
L4:
    r4 = truncate r2: i32 to builtins.bool
    if r4 goto L43 else goto L16 :: bool
L5:
    r5 = ''
    r6 = 'Matcher '
    r7 = '{!r:{}}'
    r8 = ''
    r9 = 'format'
    r10 = [r7, predicate, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L40 (error at add:68) else goto L6
L6:
    r13 = cast(str, r12)
    if is_error(r13) goto L40 (error at add:68) else goto L7
L7:
    r14 = ' already exists in '
    r15 = '{:{}}'
    r16 = self._name
    if is_error(r16) goto L44 (error at add:68) else goto L8
L8:
    r17 = ''
    r18 = 'format'
    r19 = [r15, r16, r17]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775811, 0)
    if is_error(r21) goto L45 (error at add:68) else goto L9
L9:
    dec_ref r16
    r22 = cast(str, r21)
    if is_error(r22) goto L44 (error at add:68) else goto L10
L10:
    r23 = PyList_New(4)
    if is_error(r23) goto L46 (error at add:68) else goto L11
L11:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r6
    set_mem r25, r6 :: builtins.object*
    r26 = r25 + 8
    set_mem r26, r13 :: builtins.object*
    inc_ref r14
    r27 = r25 + 16
    set_mem r27, r14 :: builtins.object*
    r28 = r25 + 24
    set_mem r28, r22 :: builtins.object*
    r29 = PyUnicode_Join(r5, r23)
    dec_ref r23
    if is_error(r29) goto L40 (error at add:68) else goto L12
L12:
    r30 = builtins :: module
    r31 = 'ValueError'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L47 (error at add:68) else goto L13
L13:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L47 (error at add:68) else goto L14
L14:
    dec_ref r29
    CPy_Raise(r35)
    dec_ref r35
    if not 0 goto L40 (error at add:68) else goto L15 :: bool
L15:
    unreachable
L16:
    r36 = load_address _Py_NoneStruct
    r37 = label != r36
    if r37 goto L17 else goto L48 :: bool
L17:
    r38 = self._labeled_predicates
    if is_error(r38) goto L42 (error at add:71) else goto L18
L18:
    inc_ref label
    r39 = cast(str, label)
    if is_error(r39) goto L49 (error at add:72) else goto L19
L19:
    r40 = PyDict_Contains(r38, r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L49 (error at add:72) else goto L20 :: bool
L20:
    r42 = truncate r40: i32 to builtins.bool
    if r42 goto L50 else goto L35 :: bool
L21:
    r43 = ''
    r44 = 'Matcher '
    r45 = '{!r:{}}'
    r46 = ''
    r47 = 'format'
    r48 = [r45, predicate, r46]
    r49 = load_address r48
    r50 = PyObject_VectorcallMethod(r47, r49, 9223372036854775811, 0)
    if is_error(r50) goto L42 (error at add:74) else goto L22
L22:
    r51 = cast(str, r50)
    if is_error(r51) goto L42 (error at add:74) else goto L23
L23:
    r52 = " with label '"
    r53 = '{:{}}'
    r54 = cast(str, label)
    if is_error(r54) goto L51 (error at add:74) else goto L24
L24:
    r55 = ''
    r56 = 'format'
    r57 = [r53, r54, r55]
    r58 = load_address r57
    r59 = PyObject_VectorcallMethod(r56, r58, 9223372036854775811, 0)
    if is_error(r59) goto L52 (error at add:74) else goto L25
L25:
    dec_ref r54
    r60 = cast(str, r59)
    if is_error(r60) goto L51 (error at add:74) else goto L26
L26:
    r61 = "' already exists in "
    r62 = '{:{}}'
    r63 = self._name
    if is_error(r63) goto L53 (error at add:75) else goto L27
L27:
    r64 = ''
    r65 = 'format'
    r66 = [r62, r63, r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775811, 0)
    if is_error(r68) goto L54 (error at add:75) else goto L28
L28:
    dec_ref r63
    r69 = cast(str, r68)
    if is_error(r69) goto L53 (error at add:75) else goto L29
L29:
    r70 = PyList_New(6)
    if is_error(r70) goto L55 (error at add:74) else goto L30
L30:
    r71 = get_element_ptr r70 ob_item :: PyListObject
    r72 = load_mem r71 :: ptr*
    inc_ref r44
    set_mem r72, r44 :: builtins.object*
    r73 = r72 + 8
    set_mem r73, r51 :: builtins.object*
    inc_ref r52
    r74 = r72 + 16
    set_mem r74, r52 :: builtins.object*
    r75 = r72 + 24
    set_mem r75, r60 :: builtins.object*
    inc_ref r61
    r76 = r72 + 32
    set_mem r76, r61 :: builtins.object*
    r77 = r72 + 40
    set_mem r77, r69 :: builtins.object*
    r78 = PyUnicode_Join(r43, r70)
    dec_ref r70
    if is_error(r78) goto L40 (error at add:74) else goto L31
L31:
    r79 = builtins :: module
    r80 = 'ValueError'
    r81 = CPyObject_GetAttr(r79, r80)
    if is_error(r81) goto L56 (error at add:73) else goto L32
L32:
    r82 = [r78]
    r83 = load_address r82
    r84 = PyObject_Vectorcall(r81, r83, 1, 0)
    dec_ref r81
    if is_error(r84) goto L56 (error at add:73) else goto L33
L33:
    dec_ref r78
    CPy_Raise(r84)
    dec_ref r84
    if not 0 goto L40 (error at add:73) else goto L34 :: bool
L34:
    unreachable
L35:
    r85 = cast(str, label)
    if is_error(r85) goto L57 (error at add:78) else goto L36
L36:
    r86 = CPyDict_SetItem(r38, r85, predicate)
    dec_ref r38
    dec_ref r85
    r87 = r86 >= 0 :: signed
    if not r87 goto L40 (error at add:78) else goto L37 :: bool
L37:
    r88 = self._values
    if is_error(r88) goto L40 (error at add:80) else goto L38
L38:
    r89 = CPyDict_SetItem(r88, predicate, value)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L40 (error at add:80) else goto L39 :: bool
L39:
    return 1
L40:
    r91 = <error> :: None
    return r91
L41:
    inc_ref label
    goto L2
L42:
    dec_ref label
    goto L40
L43:
    dec_ref label
    goto L5
L44:
    dec_ref r13
    goto L40
L45:
    dec_ref r13
    dec_ref r16
    goto L40
L46:
    dec_ref r13
    dec_ref r22
    goto L40
L47:
    dec_ref r29
    goto L40
L48:
    dec_ref label
    goto L37
L49:
    dec_ref label
    dec_ref r38
    goto L40
L50:
    dec_ref r38
    goto L21
L51:
    dec_ref r51
    goto L40
L52:
    dec_ref r51
    dec_ref r54
    goto L40
L53:
    dec_ref r51
    dec_ref r60
    goto L40
L54:
    dec_ref r51
    dec_ref r60
    dec_ref r63
    goto L40
L55:
    dec_ref r51
    dec_ref r60
    dec_ref r69
    goto L40
L56:
    dec_ref r78
    goto L40
L57:
    dec_ref r38
    goto L40

def PredicateMapping.find(self, type_str):
    self :: faster_eth_abi._registry.PredicateMapping
    type_str :: str
    r0 :: list
    r1 :: dict
    r2 :: short_int
    r3 :: native_int
    r4 :: object
    r5 :: tuple[bool, short_int, object, object]
    r6 :: short_int
    r7 :: bool
    r8, r9 :: object
    r10 :: faster_eth_abi._registry.Predicate
    r11 :: str
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: bool
    r16 :: tuple[faster_eth_abi._registry.Predicate, str]
    r17 :: object
    r18 :: i32
    r19, r20, r21 :: bit
    r22 :: tuple
    r23 :: ptr
    r24 :: native_int
    r25 :: short_int
    r26 :: bit
    r27, r28, r29, r30 :: str
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: object[1]
    r35 :: object_ptr
    r36, r37 :: object
    r38 :: str
    r39, r40 :: object
    r41 :: tuple
    r42 :: i32
    r43 :: bit
    r44, r45 :: object
    r46 :: ptr
    r47 :: native_int
    r48 :: short_int
    r49 :: bit
    r50 :: str
    r51 :: object
    r52 :: str
    r53, r54 :: object
    r55 :: str
    r56 :: object
    r57 :: object[2]
    r58 :: object_ptr
    r59 :: object
    r60, r61, r62, r63, r64, r65, r66 :: str
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: object[1]
    r71 :: object_ptr
    r72, r73, r74 :: object
    r75, r76 :: str
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L38 (error at find:83) else goto L1
L1:
    r1 = self._values
    if is_error(r1) goto L39 (error at find:85) else goto L2
L2:
    r2 = 0
    r3 = PyDict_Size(r1)
    r4 = CPyDict_GetItemsIter(r1)
    if is_error(r4) goto L40 (error at find:83) else goto L3
L3:
    r5 = CPyDict_NextItem(r4, r2)
    r6 = r5[1]
    r2 = r6
    r7 = r5[0]
    if r7 goto L4 else goto L41 :: bool
L4:
    r8 = r5[2]
    r9 = r5[3]
    dec_ref r5
    r10 = cast(faster_eth_abi._registry.Predicate, r8)
    if is_error(r10) goto L42 (error at find:83) else goto L5
L5:
    r11 = cast(str, r9)
    if is_error(r11) goto L43 (error at find:83) else goto L6
L6:
    r12 = [type_str]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r10, r13, 1, 0)
    if is_error(r14) goto L44 (error at find:86) else goto L7
L7:
    r15 = unbox(bool, r14)
    dec_ref r14
    if is_error(r15) goto L44 (error at find:86) else goto L8
L8:
    if r15 goto L9 else goto L45 :: bool
L9:
    r16 = (r10, r11)
    r17 = box(tuple[faster_eth_abi._registry.Predicate, str], r16)
    r18 = PyList_Append(r0, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L46 (error at find:83) else goto L10 :: bool
L10:
    r20 = CPyDict_CheckSize(r1, r3)
    if not r20 goto L46 (error at find:83) else goto L3 :: bool
L11:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L39 (error at find:83) else goto L12 :: bool
L12:
    r22 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r22) goto L38 (error at find:83) else goto L13
L13:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    r25 = r24 << 1
    r26 = r25 == 0
    if r26 goto L47 else goto L20 :: bool
L14:
    r27 = "No matching entries for '"
    r28 = "' in "
    r29 = self._name
    if is_error(r29) goto L38 (error at find:91) else goto L15
L15:
    r30 = CPyStr_Build(4, r27, type_str, r28, r29)
    dec_ref r29
    if is_error(r30) goto L38 (error at find:91) else goto L16
L16:
    r31 = faster_eth_abi._registry.globals :: static
    r32 = 'NoEntriesFound'
    r33 = CPyDict_GetItem(r31, r32)
    if is_error(r33) goto L48 (error at find:90) else goto L17
L17:
    r34 = [r30]
    r35 = load_address r34
    r36 = PyObject_Vectorcall(r33, r35, 1, 0)
    dec_ref r33
    if is_error(r36) goto L48 (error at find:90) else goto L18
L18:
    dec_ref r30
    CPy_Raise(r36)
    dec_ref r36
    if not 0 goto L38 (error at find:90) else goto L19 :: bool
L19:
    unreachable
L20:
    r37 = builtins :: module
    r38 = 'zip'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L49 (error at find:94) else goto L21
L21:
    r40 = PyObject_CallObject(r39, r22)
    dec_ref r39
    if is_error(r40) goto L49 (error at find:94) else goto L22
L22:
    r41 = PySequence_Tuple(r40)
    dec_ref r40
    if is_error(r41) goto L49 (error at find:94) else goto L23
L23:
    r42 = CPySequence_CheckUnpackCount(r41, 2)
    r43 = r42 >= 0 :: signed
    if not r43 goto L50 (error at find:94) else goto L24 :: bool
L24:
    r44 = CPySequenceTuple_GetItemUnsafe(r41, 0)
    r45 = CPySequenceTuple_GetItemUnsafe(r41, 1)
    dec_ref r41
    r46 = get_element_ptr r22 ob_size :: PyVarObject
    r47 = load_mem r46 :: native_int*
    dec_ref r22
    r48 = r47 << 1
    r49 = r48 > 2 :: signed
    if r49 goto L51 else goto L52 :: bool
L25:
    r50 = ', '
    r51 = builtins :: module
    r52 = 'repr'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L53 (error at find:97) else goto L26
L26:
    r54 = builtins :: module
    r55 = 'map'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L54 (error at find:97) else goto L27
L27:
    r57 = [r53, r44]
    r58 = load_address r57
    r59 = PyObject_Vectorcall(r56, r58, 2, 0)
    dec_ref r56
    if is_error(r59) goto L54 (error at find:97) else goto L28
L28:
    dec_ref r53
    dec_ref r44
    r60 = PyUnicode_Join(r50, r59)
    dec_ref r59
    if is_error(r60) goto L38 (error at find:97) else goto L29
L29:
    r61 = "Multiple matching entries for '"
    r62 = "' in "
    r63 = self._name
    if is_error(r63) goto L55 (error at find:99) else goto L30
L30:
    r64 = ': '
    r65 = '. This occurs when two registrations match the same type string. You may need to delete one of the registrations or modify its matching behavior to ensure it doesn\'t collide with other registrations. See the "Registry" documentation for more information.'
    r66 = CPyStr_Build(7, r61, type_str, r62, r63, r64, r60, r65)
    dec_ref r63
    dec_ref r60
    if is_error(r66) goto L38 (error at find:99) else goto L31
L31:
    r67 = faster_eth_abi._registry.globals :: static
    r68 = 'MultipleEntriesFound'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L56 (error at find:98) else goto L32
L32:
    r70 = [r66]
    r71 = load_address r70
    r72 = PyObject_Vectorcall(r69, r71, 1, 0)
    dec_ref r69
    if is_error(r72) goto L56 (error at find:98) else goto L33
L33:
    dec_ref r66
    CPy_Raise(r72)
    dec_ref r72
    if not 0 goto L38 (error at find:98) else goto L34 :: bool
L34:
    unreachable
L35:
    r73 = object 0
    r74 = PyObject_GetItem(r45, r73)
    dec_ref r45
    if is_error(r74) goto L38 (error at find:107) else goto L36
L36:
    r75 = cast(str, r74)
    if is_error(r75) goto L38 (error at find:107) else goto L37
L37:
    return r75
L38:
    r76 = <error> :: str
    return r76
L39:
    dec_ref r0
    goto L38
L40:
    dec_ref r0
    dec_ref r1
    goto L38
L41:
    dec_ref r1
    dec_ref r4
    dec_ref r5
    goto L11
L42:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    dec_ref r9
    goto L38
L43:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    dec_ref r10
    goto L38
L44:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    dec_ref r10
    dec_ref r11
    goto L38
L45:
    dec_ref r10
    dec_ref r11
    goto L10
L46:
    dec_ref r0
    dec_ref r1
    dec_ref r4
    goto L38
L47:
    dec_ref r22
    goto L14
L48:
    dec_ref r30
    goto L38
L49:
    dec_ref r22
    goto L38
L50:
    dec_ref r22
    dec_ref r41
    goto L38
L51:
    dec_ref r45
    goto L25
L52:
    dec_ref r44
    goto L35
L53:
    dec_ref r44
    goto L38
L54:
    dec_ref r44
    dec_ref r53
    goto L38
L55:
    dec_ref r60
    goto L38
L56:
    dec_ref r66
    goto L38

def PredicateMapping.remove_by_equality(self, predicate):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: faster_eth_abi._registry.Predicate
    r0 :: dict
    r1 :: i32
    r2 :: bit
    r3 :: tuple[object, object, object]
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: bit
    r8, r9, r10, r11, r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16, r17, r18, r19, r20, r21 :: str
    r22 :: object[3]
    r23 :: object_ptr
    r24 :: object
    r25 :: str
    r26 :: list
    r27, r28, r29, r30, r31 :: ptr
    r32 :: str
    r33 :: object
    r34 :: str
    r35 :: object
    r36 :: object[1]
    r37 :: object_ptr
    r38 :: object
    r39 :: bit
    r40 :: str
    r41 :: tuple[object, object, object]
    r42 :: object
    r43 :: str
    r44 :: object
    r45, r46 :: bit
    r47 :: dict
    r48 :: i32
    r49 :: bit
    r50 :: None
L0:
L1:
    r0 = self._values
    if is_error(r0) goto L3 (error at remove_by_equality:112) else goto L2
L2:
    r1 = PyObject_DelItem(r0, predicate)
    dec_ref r0
    r2 = r1 >= 0 :: signed
    if not r2 goto L3 (error at remove_by_equality:112) else goto L20 :: bool
L3:
    r3 = CPy_CatchError()
    r4 = builtins :: module
    r5 = 'KeyError'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at remove_by_equality:113) else goto L4
L4:
    r7 = CPy_ExceptionMatches(r6)
    dec_ref r6
    if r7 goto L5 else goto L16 :: bool
L5:
    r8 = ''
    r9 = 'Matcher '
    r10 = '{!r:{}}'
    r11 = ''
    r12 = 'format'
    r13 = [r10, predicate, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L18 (error at remove_by_equality:114) else goto L6
L6:
    r16 = cast(str, r15)
    if is_error(r16) goto L18 (error at remove_by_equality:114) else goto L7
L7:
    r17 = ' not found in '
    r18 = '{:{}}'
    r19 = self._name
    if is_error(r19) goto L33 (error at remove_by_equality:114) else goto L8
L8:
    r20 = ''
    r21 = 'format'
    r22 = [r18, r19, r20]
    r23 = load_address r22
    r24 = PyObject_VectorcallMethod(r21, r23, 9223372036854775811, 0)
    if is_error(r24) goto L34 (error at remove_by_equality:114) else goto L9
L9:
    dec_ref r19
    r25 = cast(str, r24)
    if is_error(r25) goto L33 (error at remove_by_equality:114) else goto L10
L10:
    r26 = PyList_New(4)
    if is_error(r26) goto L35 (error at remove_by_equality:114) else goto L11
L11:
    r27 = get_element_ptr r26 ob_item :: PyListObject
    r28 = load_mem r27 :: ptr*
    inc_ref r9
    set_mem r28, r9 :: builtins.object*
    r29 = r28 + 8
    set_mem r29, r16 :: builtins.object*
    inc_ref r17
    r30 = r28 + 16
    set_mem r30, r17 :: builtins.object*
    r31 = r28 + 24
    set_mem r31, r25 :: builtins.object*
    r32 = PyUnicode_Join(r8, r26)
    dec_ref r26
    if is_error(r32) goto L18 (error at remove_by_equality:114) else goto L12
L12:
    r33 = builtins :: module
    r34 = 'KeyError'
    r35 = CPyObject_GetAttr(r33, r34)
    if is_error(r35) goto L36 (error at remove_by_equality:114) else goto L13
L13:
    r36 = [r32]
    r37 = load_address r36
    r38 = PyObject_Vectorcall(r35, r37, 1, 0)
    dec_ref r35
    if is_error(r38) goto L36 (error at remove_by_equality:114) else goto L14
L14:
    dec_ref r32
    CPy_Raise(r38)
    dec_ref r38
    if not 0 goto L18 (error at remove_by_equality:114) else goto L37 :: bool
L15:
    unreachable
L16:
    CPy_Reraise()
    if not 0 goto L18 else goto L38 :: bool
L17:
    unreachable
L18:
    CPy_RestoreExcInfo(r3)
    dec_ref r3
    r39 = CPy_KeepPropagating()
    if not r39 goto L32 else goto L19 :: bool
L19:
    unreachable
L20:
    r40 = self._label_for_predicate(predicate)
    if is_error(r40) goto L22 (error at remove_by_equality:118) else goto L21
L21:
    goto L29
L22:
    r41 = CPy_CatchError()
    r42 = builtins :: module
    r43 = 'ValueError'
    r44 = CPyObject_GetAttr(r42, r43)
    if is_error(r44) goto L27 (error at remove_by_equality:119) else goto L23
L23:
    r45 = CPy_ExceptionMatches(r44)
    dec_ref r44
    if r45 goto L26 else goto L24 :: bool
L24:
    CPy_Reraise()
    if not 0 goto L27 else goto L39 :: bool
L25:
    unreachable
L26:
    CPy_RestoreExcInfo(r41)
    dec_ref r41
    goto L31
L27:
    CPy_RestoreExcInfo(r41)
    dec_ref r41
    r46 = CPy_KeepPropagating()
    if not r46 goto L32 else goto L28 :: bool
L28:
    unreachable
L29:
    r47 = self._labeled_predicates
    if is_error(r47) goto L40 (error at remove_by_equality:122) else goto L30
L30:
    r48 = PyObject_DelItem(r47, r40)
    dec_ref r47
    dec_ref r40
    r49 = r48 >= 0 :: signed
    if not r49 goto L32 (error at remove_by_equality:122) else goto L31 :: bool
L31:
    return 1
L32:
    r50 = <error> :: None
    return r50
L33:
    dec_ref r16
    goto L18
L34:
    dec_ref r16
    dec_ref r19
    goto L18
L35:
    dec_ref r16
    dec_ref r25
    goto L18
L36:
    dec_ref r32
    goto L18
L37:
    dec_ref r3
    goto L15
L38:
    dec_ref r3
    goto L17
L39:
    dec_ref r41
    goto L25
L40:
    dec_ref r40
    goto L32

def PredicateMapping._label_for_predicate(self, predicate):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate :: faster_eth_abi._registry.Predicate
    r0 :: dict
    r1 :: short_int
    r2 :: native_int
    r3 :: object
    r4 :: tuple[bool, short_int, object, object]
    r5 :: short_int
    r6 :: bool
    r7, r8 :: object
    r9 :: str
    r10 :: faster_eth_abi._registry.Predicate
    r11, r12, r13 :: bit
    r14, r15, r16, r17, r18 :: str
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22, r23, r24, r25, r26, r27 :: str
    r28 :: object[3]
    r29 :: object_ptr
    r30 :: object
    r31 :: str
    r32 :: list
    r33, r34, r35, r36, r37 :: ptr
    r38 :: str
    r39 :: object
    r40 :: str
    r41 :: object
    r42 :: object[1]
    r43 :: object_ptr
    r44 :: object
    r45 :: str
L0:
    r0 = self._labeled_predicates
    if is_error(r0) goto L20 (error at _label_for_predicate:127) else goto L1
L1:
    r1 = 0
    r2 = PyDict_Size(r0)
    r3 = CPyDict_GetItemsIter(r0)
    if is_error(r3) goto L21 (error at _label_for_predicate:127) else goto L2
L2:
    r4 = CPyDict_NextItem(r3, r1)
    r5 = r4[1]
    r1 = r5
    r6 = r4[0]
    if r6 goto L3 else goto L22 :: bool
L3:
    r7 = r4[2]
    r8 = r4[3]
    dec_ref r4
    r9 = cast(str, r7)
    if is_error(r9) goto L23 (error at _label_for_predicate:127) else goto L4
L4:
    r10 = cast(faster_eth_abi._registry.Predicate, r8)
    if is_error(r10) goto L24 (error at _label_for_predicate:127) else goto L5
L5:
    r11 = r10 == predicate
    dec_ref r10
    if r11 goto L25 else goto L26 :: bool
L6:
    return r9
L7:
    r12 = CPyDict_CheckSize(r0, r2)
    if not r12 goto L27 (error at _label_for_predicate:127) else goto L2 :: bool
L8:
    r13 = CPy_NoErrOccurred()
    if not r13 goto L20 (error at _label_for_predicate:127) else goto L9 :: bool
L9:
    r14 = ''
    r15 = 'Matcher '
    r16 = '{!r:{}}'
    r17 = ''
    r18 = 'format'
    r19 = [r16, predicate, r17]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775811, 0)
    if is_error(r21) goto L20 (error at _label_for_predicate:132) else goto L10
L10:
    r22 = cast(str, r21)
    if is_error(r22) goto L20 (error at _label_for_predicate:132) else goto L11
L11:
    r23 = ' not referred to by any label in '
    r24 = '{:{}}'
    r25 = self._name
    if is_error(r25) goto L28 (error at _label_for_predicate:132) else goto L12
L12:
    r26 = ''
    r27 = 'format'
    r28 = [r24, r25, r26]
    r29 = load_address r28
    r30 = PyObject_VectorcallMethod(r27, r29, 9223372036854775811, 0)
    if is_error(r30) goto L29 (error at _label_for_predicate:132) else goto L13
L13:
    dec_ref r25
    r31 = cast(str, r30)
    if is_error(r31) goto L28 (error at _label_for_predicate:132) else goto L14
L14:
    r32 = PyList_New(4)
    if is_error(r32) goto L30 (error at _label_for_predicate:132) else goto L15
L15:
    r33 = get_element_ptr r32 ob_item :: PyListObject
    r34 = load_mem r33 :: ptr*
    inc_ref r15
    set_mem r34, r15 :: builtins.object*
    r35 = r34 + 8
    set_mem r35, r22 :: builtins.object*
    inc_ref r23
    r36 = r34 + 16
    set_mem r36, r23 :: builtins.object*
    r37 = r34 + 24
    set_mem r37, r31 :: builtins.object*
    r38 = PyUnicode_Join(r14, r32)
    dec_ref r32
    if is_error(r38) goto L20 (error at _label_for_predicate:132) else goto L16
L16:
    r39 = builtins :: module
    r40 = 'ValueError'
    r41 = CPyObject_GetAttr(r39, r40)
    if is_error(r41) goto L31 (error at _label_for_predicate:131) else goto L17
L17:
    r42 = [r38]
    r43 = load_address r42
    r44 = PyObject_Vectorcall(r41, r43, 1, 0)
    dec_ref r41
    if is_error(r44) goto L31 (error at _label_for_predicate:131) else goto L18
L18:
    dec_ref r38
    CPy_Raise(r44)
    dec_ref r44
    if not 0 goto L20 (error at _label_for_predicate:131) else goto L19 :: bool
L19:
    unreachable
L20:
    r45 = <error> :: str
    return r45
L21:
    dec_ref r0
    goto L20
L22:
    dec_ref r0
    dec_ref r3
    dec_ref r4
    goto L8
L23:
    dec_ref r0
    dec_ref r3
    dec_ref r8
    goto L20
L24:
    dec_ref r0
    dec_ref r3
    dec_ref r9
    goto L20
L25:
    dec_ref r0
    dec_ref r3
    goto L6
L26:
    dec_ref r9
    goto L7
L27:
    dec_ref r0
    dec_ref r3
    goto L20
L28:
    dec_ref r22
    goto L20
L29:
    dec_ref r22
    dec_ref r25
    goto L20
L30:
    dec_ref r22
    dec_ref r31
    goto L20
L31:
    dec_ref r38
    goto L20

def PredicateMapping.remove_by_label(self, label):
    self :: faster_eth_abi._registry.PredicateMapping
    label :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6 :: union[faster_eth_abi._registry.Predicate, None]
    r7 :: object
    r8 :: bit
    r9, r10, r11, r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19 :: dict
    r20 :: faster_eth_abi._registry.Predicate
    r21 :: i32
    r22 :: bit
    r23 :: None
L0:
    r0 = self._labeled_predicates
    if is_error(r0) goto L14 (error at remove_by_label:136) else goto L1
L1:
    r1 = 'pop'
    r2 = box(None, 1)
    r3 = [r0, label, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775811, 0)
    if is_error(r5) goto L15 (error at remove_by_label:136) else goto L2
L2:
    dec_ref r0
    r6 = cast(union[faster_eth_abi._registry.Predicate, None], r5)
    if is_error(r6) goto L14 (error at remove_by_label:136) else goto L3
L3:
    r7 = load_address _Py_NoneStruct
    r8 = r6 == r7
    if r8 goto L16 else goto L10 :: bool
L4:
    r9 = "Label '"
    r10 = "' not found in "
    r11 = self._name
    if is_error(r11) goto L14 (error at remove_by_label:138) else goto L5
L5:
    r12 = CPyStr_Build(4, r9, label, r10, r11)
    dec_ref r11
    if is_error(r12) goto L14 (error at remove_by_label:138) else goto L6
L6:
    r13 = builtins :: module
    r14 = 'KeyError'
    r15 = CPyObject_GetAttr(r13, r14)
    if is_error(r15) goto L17 (error at remove_by_label:138) else goto L7
L7:
    r16 = [r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    dec_ref r15
    if is_error(r18) goto L17 (error at remove_by_label:138) else goto L8
L8:
    dec_ref r12
    CPy_Raise(r18)
    dec_ref r18
    if not 0 goto L14 (error at remove_by_label:138) else goto L9 :: bool
L9:
    unreachable
L10:
    r19 = self._values
    if is_error(r19) goto L18 (error at remove_by_label:140) else goto L11
L11:
    r20 = cast(faster_eth_abi._registry.Predicate, r6)
    if is_error(r20) goto L19 (error at remove_by_label:140) else goto L12
L12:
    r21 = PyObject_DelItem(r19, r20)
    dec_ref r19
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L14 (error at remove_by_label:140) else goto L13 :: bool
L13:
    return 1
L14:
    r23 = <error> :: None
    return r23
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r6
    goto L4
L17:
    dec_ref r12
    goto L14
L18:
    dec_ref r6
    goto L14
L19:
    dec_ref r19
    goto L14

def PredicateMapping.remove(self, predicate_or_label):
    self :: faster_eth_abi._registry.PredicateMapping
    predicate_or_label :: union[faster_eth_abi._registry.Predicate, str]
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bool
    r7 :: faster_eth_abi._registry.Predicate
    r8 :: None
    r9 :: bit
    r10 :: str
    r11 :: None
    r12, r13, r14 :: str
    r15 :: object
    r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: list
    r22, r23, r24 :: ptr
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: None
L0:
    r0 = builtins :: module
    r1 = 'callable'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L17 (error at remove:143) else goto L1
L1:
    r3 = [predicate_or_label]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L17 (error at remove:143) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L17 (error at remove:143) else goto L3
L3:
    if r6 goto L4 else goto L6 :: bool
L4:
    inc_ref predicate_or_label
    r7 = cast(faster_eth_abi._registry.Predicate, predicate_or_label)
    if is_error(r7) goto L17 (error at remove:144) else goto L5
L5:
    r8 = self.remove_by_equality(r7)
    dec_ref r7
    if is_error(r8) goto L17 (error at remove:144) else goto L16
L6:
    r9 = PyUnicode_Check(predicate_or_label)
    if r9 goto L7 else goto L9 :: bool
L7:
    inc_ref predicate_or_label
    r10 = cast(str, predicate_or_label)
    if is_error(r10) goto L17 (error at remove:146) else goto L8
L8:
    r11 = self.remove_by_label(r10)
    dec_ref r10
    if is_error(r11) goto L17 (error at remove:146) else goto L16
L9:
    r12 = ''
    r13 = 'Key to be removed must be callable or string: got '
    r14 = '{:{}}'
    r15 = CPy_TYPE(predicate_or_label)
    r16 = ''
    r17 = 'format'
    r18 = [r14, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L18 (error at remove:150) else goto L10
L10:
    dec_ref r15
    r21 = PyList_New(2)
    if is_error(r21) goto L19 (error at remove:149) else goto L11
L11:
    r22 = get_element_ptr r21 ob_item :: PyListObject
    r23 = load_mem r22 :: ptr*
    inc_ref r13
    set_mem r23, r13 :: builtins.object*
    r24 = r23 + 8
    set_mem r24, r20 :: builtins.object*
    r25 = PyUnicode_Join(r12, r21)
    dec_ref r21
    if is_error(r25) goto L17 (error at remove:149) else goto L12
L12:
    r26 = builtins :: module
    r27 = 'TypeError'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L20 (error at remove:148) else goto L13
L13:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L20 (error at remove:148) else goto L14
L14:
    dec_ref r25
    CPy_Raise(r31)
    dec_ref r31
    if not 0 goto L17 (error at remove:148) else goto L15 :: bool
L15:
    unreachable
L16:
    return 1
L17:
    r32 = <error> :: None
    return r32
L18:
    dec_ref r15
    goto L17
L19:
    dec_ref r20
    goto L17
L20:
    dec_ref r25
    goto L17

def PredicateMapping.copy(self):
    self :: faster_eth_abi._registry.PredicateMapping
    r0 :: object
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: faster_eth_abi._registry.PredicateMapping
    r6 :: dict
    r7 :: object
    r8 :: bool
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: dict
    r13 :: bool
    r14 :: dict
    r15 :: object
    r16 :: bool
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: bool
    r22 :: faster_eth_abi._registry.PredicateMapping
L0:
    r0 = CPy_TYPE(self)
    r1 = self._name
    if is_error(r1) goto L19 (error at copy:154) else goto L1
L1:
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    dec_ref r0
    if is_error(r4) goto L20 (error at copy:154) else goto L2
L2:
    dec_ref r1
    r5 = cast(faster_eth_abi._registry.PredicateMapping, r4)
    if is_error(r5) goto L18 (error at copy:154) else goto L3
L3:
    r6 = self._values
    if is_error(r6) goto L21 (error at copy:156) else goto L4
L4:
    r7 = faster_eth_abi._registry.copy :: static
    if is_error(r7) goto L22 else goto L7
L5:
    r8 = raise NameError('value for final name "copy" was not set')
    if not r8 goto L18 (error at copy:156) else goto L6 :: bool
L6:
    unreachable
L7:
    r9 = [r6]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 1, 0)
    if is_error(r11) goto L23 (error at copy:156) else goto L8
L8:
    dec_ref r6
    r12 = cast(dict, r11)
    if is_error(r12) goto L21 (error at copy:156) else goto L9
L9:
    r5._values = r12; r13 = is_error
    if not r13 goto L21 (error at copy:156) else goto L10 :: bool
L10:
    r14 = self._labeled_predicates
    if is_error(r14) goto L21 (error at copy:157) else goto L11
L11:
    r15 = faster_eth_abi._registry.copy :: static
    if is_error(r15) goto L24 else goto L14
L12:
    r16 = raise NameError('value for final name "copy" was not set')
    if not r16 goto L18 (error at copy:157) else goto L13 :: bool
L13:
    unreachable
L14:
    r17 = [r14]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r15, r18, 1, 0)
    if is_error(r19) goto L25 (error at copy:157) else goto L15
L15:
    dec_ref r14
    r20 = cast(dict, r19)
    if is_error(r20) goto L21 (error at copy:157) else goto L16
L16:
    r5._labeled_predicates = r20; r21 = is_error
    if not r21 goto L21 (error at copy:157) else goto L17 :: bool
L17:
    return r5
L18:
    r22 = <error> :: faster_eth_abi._registry.PredicateMapping
    return r22
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r1
    goto L18
L21:
    dec_ref r5
    goto L18
L22:
    dec_ref r5
    dec_ref r6
    goto L5
L23:
    dec_ref r5
    dec_ref r6
    goto L18
L24:
    dec_ref r5
    dec_ref r14
    goto L12
L25:
    dec_ref r5
    dec_ref r14
    goto L18

def PredicateMapping.copy__Copyable_glue(self):
    self, r0 :: faster_eth_abi._registry.PredicateMapping
    r1 :: faster_eth_abi._registry.Copyable
L0:
    r0 = PredicateMapping.copy(self)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: faster_eth_abi._registry.Copyable
    return r1

def Predicate.__call__(self, arg):
    self :: faster_eth_abi._registry.Predicate
    arg, r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
L0:
    r0 = 'Must implement `__call__`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at __call__:171) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __call__:171) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at __call__:171) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: bool
    return r7

def Predicate.__str__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
L0:
    r0 = 'Must implement `__str__`'
    r1 = builtins :: module
    r2 = 'NotImplementedError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at __str__:174) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __str__:174) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at __str__:174) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: str
    return r7

def Predicate.__repr__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: str
    r1, r2 :: object
    r3, r4, r5, r6, r7, r8 :: str
L0:
    r0 = '<'
    r1 = CPy_TYPE(self)
    r2 = CPy_GetName(r1)
    dec_ref r1
    if is_error(r2) goto L5 (error at __repr__:177) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L5 (error at __repr__:177) else goto L2
L2:
    r4 = ' '
    r5 = PyObject_Str(self)
    if is_error(r5) goto L6 (error at __repr__:177) else goto L3
L3:
    r6 = '>'
    r7 = CPyStr_Build(5, r0, r3, r4, r5, r6)
    dec_ref r3
    dec_ref r5
    if is_error(r7) goto L5 (error at __repr__:177) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: str
    return r8
L6:
    dec_ref r3
    goto L5

def __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: faster_eth_abi._registry.Predicate
    r4 :: str
    r5 :: object
    r6 :: tuple
    r7 :: bool
    r8 :: tuple
    r9 :: ptr
    r10 :: native_int
    r11, r12 :: bool
    r13, r14 :: native_int
    r15 :: bit
    r16 :: tuple
    r17 :: native_int
    r18 :: object
    r19 :: str
    r20 :: bool
    r21 :: faster_eth_abi._registry.Predicate
    r22 :: str
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bit
    r27, r28 :: native_int
    r29 :: bool
    r30 :: object
    r31 :: bool
    r32, r33 :: bit
    r34 :: bool
    r35 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L32
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L36 (error at __iter__:179) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r3) goto L36 (error at __iter__:180) else goto L5
L5:
    r4 = '__slots__'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L36 (error at __iter__:180) else goto L6
L6:
    r6 = cast(tuple, r5)
    if is_error(r6) goto L36 (error at __iter__:180) else goto L7
L7:
    __mypyc_self__.__mypyc_temp__0 = r6; r7 = is_error
    if not r7 goto L36 (error at __iter__:-1) else goto L8 :: bool
L8:
    r8 = __mypyc_self__.__mypyc_temp__0
    if is_error(r8) goto L36 (error at __iter__:180) else goto L9
L9:
    r9 = get_element_ptr r8 ob_size :: PyVarObject
    r10 = load_mem r9 :: native_int*
    dec_ref r8
    __mypyc_self__.__mypyc_temp__1 = r10; r11 = is_error
    if not r11 goto L36 (error at __iter__:-1) else goto L10 :: bool
L10:
    __mypyc_self__.__mypyc_temp__2 = 0; r12 = is_error
    if not r12 goto L36 (error at __iter__:-1) else goto L11 :: bool
L11:
    r13 = __mypyc_self__.__mypyc_temp__1
    if is_error(r13) goto L36 (error at __iter__:180) else goto L12
L12:
    r14 = __mypyc_self__.__mypyc_temp__2
    if is_error(r14) goto L36 (error at __iter__:180) else goto L13
L13:
    r15 = r14 < r13 :: signed
    if r15 goto L14 else goto L27 :: bool
L14:
    r16 = __mypyc_self__.__mypyc_temp__0
    if is_error(r16) goto L36 (error at __iter__:180) else goto L15
L15:
    r17 = __mypyc_self__.__mypyc_temp__2
    if is_error(r17) goto L37 (error at __iter__:180) else goto L16
L16:
    r18 = CPySequenceTuple_GetItemUnsafe(r16, r17)
    dec_ref r16
    r19 = cast(str, r18)
    if is_error(r19) goto L36 (error at __iter__:180) else goto L17
L17:
    __mypyc_self__.__mypyc_generator_attribute__attr = r19; r20 = is_error
    if not r20 goto L36 (error at __iter__:180) else goto L18 :: bool
L18:
    r21 = __mypyc_self__.__mypyc_generator_attribute__self
    if is_error(r21) goto L36 (error at __iter__:181) else goto L19
L19:
    r22 = __mypyc_self__.__mypyc_generator_attribute__attr
    if is_error(r22) goto L38 (error at __iter__:181) else goto L20
L20:
    r23 = CPyObject_GetAttr(r21, r22)
    dec_ref r21
    dec_ref r22
    if is_error(r23) goto L36 (error at __iter__:181) else goto L21
L21:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r23
L22:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L23 else goto L25 :: bool
L23:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L36 (error at __iter__:181) else goto L24 :: bool
L24:
    unreachable
L25:
    r27 = __mypyc_self__.__mypyc_temp__2
    if is_error(r27) goto L36 (error at __iter__:180) else goto L26
L26:
    r28 = r27 + 1
    __mypyc_self__.__mypyc_temp__2 = r28; r29 = is_error
    if not r29 goto L36 (error at __iter__:180) else goto L11 :: bool
L27:
    r30 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L28:
    if is_error(stop_iter_ptr) goto L29 else goto L31
L29:
    CPyGen_SetStopIterationValue(r30)
    if not 0 goto L36 else goto L30 :: bool
L30:
    unreachable
L31:
    inc_ref r30
    set_mem stop_iter_ptr, r30 :: builtins.object*
    return 0
L32:
    r32 = r0 == 0
    if r32 goto L1 else goto L33 :: bool
L33:
    r33 = r0 == 1
    if r33 goto L22 else goto L34 :: bool
L34:
    r34 = raise StopIteration
    if not r34 goto L36 (error at __iter__:179) else goto L35 :: bool
L35:
    unreachable
L36:
    r35 = <error> :: object
    return r35
L37:
    dec_ref r16
    goto L36
L38:
    dec_ref r21
    goto L36

def __iter___Predicate_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___Predicate_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___Predicate_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___Predicate_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___Predicate_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___Predicate_gen.close(__mypyc_self__):
    __mypyc_self__ :: faster_eth_abi._registry.__iter___Predicate_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def Predicate.__iter__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: faster_eth_abi._registry.__iter___Predicate_gen
    r1, r2 :: bool
    r3 :: faster_eth_abi._registry.__iter___Predicate_gen
L0:
    r0 = __iter___Predicate_gen()
    if is_error(r0) goto L3 (error at __iter__:179) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.__mypyc_generator_attribute__self = self; r2 = is_error
    if not r2 goto L4 (error at __iter__:179) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: faster_eth_abi._registry.__iter___Predicate_gen
    return r3
L4:
    dec_ref r0
    goto L3

def Predicate.__hash__(self):
    self :: faster_eth_abi._registry.Predicate
    r0 :: tuple
    r1, r2 :: int
L0:
    r0 = PySequence_Tuple(self)
    if is_error(r0) goto L3 (error at __hash__:184) else goto L1
L1:
    r1 = CPyObject_Hash(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at __hash__:184) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: int
    return r2

def Predicate.__eq__(self, other):
    self, other :: faster_eth_abi._registry.Predicate
    r0, r1 :: object
    r2 :: bit
    r3 :: bool
    r4, r5 :: tuple
    r6 :: object
    r7 :: bool
    r8, r9 :: object
L0:
    r0 = CPy_TYPE(self)
    r1 = CPy_TYPE(other)
    r2 = r0 == r1
    dec_ref r0
    dec_ref r1
    if r2 goto L2 else goto L1 :: bool
L1:
    r3 = r2
    goto L7
L2:
    r4 = PySequence_Tuple(self)
    if is_error(r4) goto L8 (error at __eq__:187) else goto L3
L3:
    r5 = PySequence_Tuple(other)
    if is_error(r5) goto L9 (error at __eq__:187) else goto L4
L4:
    r6 = PyObject_RichCompare(r4, r5, 2)
    dec_ref r4
    dec_ref r5
    if is_error(r6) goto L8 (error at __eq__:187) else goto L5
L5:
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L8 (error at __eq__:187) else goto L6
L6:
    r3 = r7
L7:
    r8 = box(bool, r3)
    inc_ref r8
    return r8
L8:
    r9 = <error> :: object
    return r9
L9:
    dec_ref r4
    goto L8

def Predicate.__ne__(__mypyc_self__, rhs):
    __mypyc_self__ :: faster_eth_abi._registry.Predicate
    rhs, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4, r5 :: bit
    r6 :: object
    r7 :: bit
    r8 :: i32
    r9 :: bit
    r10 :: bool
    r11, r12 :: object
L0:
    r0 = __mypyc_self__.__eq__(rhs)
    if is_error(r0) goto L10 else goto L1
L1:
    r1 = load_address _Py_NotImplementedStruct
    r2 = r0 == r1
    if r2 goto L11 else goto L2 :: bool
L2:
    r3 = load_global Py_True :: static
    r4 = r0 == r3
    if r4 goto L12 else goto L4 :: bool
L3:
    r5 = 0
    goto L8
L4:
    r6 = load_global Py_False :: static
    r7 = r0 == r6
    if r7 goto L13 else goto L6 :: bool
L5:
    r5 = 1
    goto L8
L6:
    r8 = PyObject_Not(r0)
    dec_ref r0
    r9 = r8 >= 0 :: signed
    if not r9 goto L10 else goto L7 :: bool
L7:
    r10 = truncate r8: i32 to builtins.bool
    r5 = r10
L8:
    r11 = box(bit, r5)
    inc_ref r11
    return r11
L9:
    inc_ref r1
    return r1
L10:
    r12 = <error> :: object
    return r12
L11:
    dec_ref r0
    goto L9
L12:
    dec_ref r0
    goto L3
L13:
    dec_ref r0
    goto L5

def Equals.__init__(self, value):
    self :: faster_eth_abi._registry.Equals
    value :: str
    r0 :: bool
    r1 :: None
L0:
    inc_ref value
    self.value = value; r0 = is_error
    if not r0 goto L2 (error at __init__:199) else goto L1 :: bool
L1:
    return 1
L2:
    r1 = <error> :: None
    return r1

def Equals.__call__(self, other):
    self :: faster_eth_abi._registry.Equals
    other, r0 :: str
    r1, r2 :: bool
L0:
    r0 = self.value
    if is_error(r0) goto L2 (error at __call__:202) else goto L1
L1:
    r1 = CPyStr_Equal(r0, other)
    dec_ref r0
    return r1
L2:
    r2 = <error> :: bool
    return r2

def Equals.__call____Predicate_glue(self, arg):
    self :: faster_eth_abi._registry.Equals
    arg :: str
    r0, r1 :: bool
L0:
    r0 = Equals.__call__(self, arg)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bool
    return r1

def Equals.__str__(self):
    self :: faster_eth_abi._registry.Equals
    r0, r1, r2, r3, r4, r5 :: str
    r6 :: object[3]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: str
    r11 :: list
    r12, r13, r14, r15 :: ptr
    r16, r17 :: str
L0:
    r0 = ''
    r1 = '(== '
    r2 = '{!r:{}}'
    r3 = self.value
    if is_error(r3) goto L6 (error at __str__:205) else goto L1
L1:
    r4 = ''
    r5 = 'format'
    r6 = [r2, r3, r4]
    r7 = load_address r6
    r8 = PyObject_VectorcallMethod(r5, r7, 9223372036854775811, 0)
    if is_error(r8) goto L7 (error at __str__:205) else goto L2
L2:
    dec_ref r3
    r9 = cast(str, r8)
    if is_error(r9) goto L6 (error at __str__:205) else goto L3
L3:
    r10 = ')'
    r11 = PyList_New(3)
    if is_error(r11) goto L8 (error at __str__:205) else goto L4
L4:
    r12 = get_element_ptr r11 ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    inc_ref r1
    set_mem r13, r1 :: builtins.object*
    r14 = r13 + 8
    set_mem r14, r9 :: builtins.object*
    inc_ref r10
    r15 = r13 + 16
    set_mem r15, r10 :: builtins.object*
    r16 = PyUnicode_Join(r0, r11)
    dec_ref r11
    if is_error(r16) goto L6 (error at __str__:205) else goto L5
L5:
    return r16
L6:
    r17 = <error> :: str
    return r17
L7:
    dec_ref r3
    goto L6
L8:
    dec_ref r9
    goto L6

def BaseEquals.__init__(self, base, with_sub):
    self :: faster_eth_abi._registry.BaseEquals
    base :: str
    with_sub :: union[bool, None]
    r0 :: object
    r1, r2 :: bool
    r3 :: None
L0:
    if is_error(with_sub) goto L1 else goto L6
L1:
    r0 = box(None, 1)
    inc_ref r0
    with_sub = r0
L2:
    inc_ref base
    self.base = base; r1 = is_error
    if not r1 goto L7 (error at __init__:221) else goto L3 :: bool
L3:
    self.with_sub = with_sub; r2 = is_error
    if not r2 goto L5 (error at __init__:222) else goto L4 :: bool
L4:
    return 1
L5:
    r3 = <error> :: None
    return r3
L6:
    inc_ref with_sub
    goto L2
L7:
    dec_ref with_sub
    goto L5

def BaseEquals.__call__(self, type_str):
    self :: faster_eth_abi._registry.BaseEquals
    type_str :: str
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: dict
    r8 :: str
    r9, r10 :: object
    r11 :: str
    r12 :: object
    r13 :: tuple[object, object]
    r14 :: object
    r15, r16 :: bit
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: i32
    r21 :: bit
    r22 :: bool
    r23 :: str
    r24, r25 :: object
    r26 :: bit
    r27 :: union[bool, None]
    r28 :: object
    r29 :: bit
    r30 :: bool
    r31 :: str
    r32, r33 :: object
    r34 :: bit
    r35 :: bool
    r36 :: str
    r37, r38 :: object
    r39 :: bit
    r40 :: str
    r41 :: object
    r42, r43 :: str
    r44, r45 :: bool
L0:
L1:
    r0 = faster_eth_abi._registry.globals :: static
    r1 = 'parse'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L4 (error at __call__:226) else goto L2
L2:
    r3 = [type_str]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at __call__:226) else goto L3
L3:
    goto L12
L4:
    r6 = CPy_CatchError()
    r7 = faster_eth_abi._registry.globals :: static
    r8 = 'ParseError'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L10 (error at __call__:227) else goto L5
L5:
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L36 (error at __call__:227) else goto L6
L6:
    r13 = (r9, r12)
    r14 = box(tuple[object, object], r13)
    r15 = CPy_ExceptionMatches(r14)
    dec_ref r14
    if r15 goto L7 else goto L8 :: bool
L7:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    return 0
L8:
    CPy_Reraise()
    if not 0 goto L10 else goto L37 :: bool
L9:
    unreachable
L10:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r16 = CPy_KeepPropagating()
    if not r16 goto L35 else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = faster_eth_abi._registry.globals :: static
    r18 = 'BasicType'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L38 (error at __call__:230) else goto L13
L13:
    r20 = PyObject_IsInstance(r5, r19)
    dec_ref r19
    r21 = r20 >= 0 :: signed
    if not r21 goto L38 (error at __call__:230) else goto L14 :: bool
L14:
    r22 = truncate r20: i32 to builtins.bool
    if r22 goto L15 else goto L39 :: bool
L15:
    r23 = 'arrlist'
    r24 = CPyObject_GetAttr(r5, r23)
    if is_error(r24) goto L38 (error at __call__:231) else goto L16
L16:
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    dec_ref r24
    if r26 goto L40 else goto L18 :: bool
L17:
    return 0
L18:
    r27 = self.with_sub
    if is_error(r27) goto L38 (error at __call__:234) else goto L19
L19:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L20 else goto L41 :: bool
L20:
    r30 = unbox(bool, r27)
    if is_error(r30) goto L42 (error at __call__:236) else goto L21
L21:
    if r30 goto L22 else goto L25 :: bool
L22:
    r31 = 'sub'
    r32 = CPyObject_GetAttr(r5, r31)
    if is_error(r32) goto L42 (error at __call__:236) else goto L23
L23:
    r33 = load_address _Py_NoneStruct
    r34 = r32 == r33
    dec_ref r32
    if r34 goto L43 else goto L25 :: bool
L24:
    return 0
L25:
    r35 = unbox(bool, r27)
    dec_ref r27
    if is_error(r35) goto L38 (error at __call__:238) else goto L26
L26:
    if r35 goto L30 else goto L27 :: bool
L27:
    r36 = 'sub'
    r37 = CPyObject_GetAttr(r5, r36)
    if is_error(r37) goto L38 (error at __call__:238) else goto L28
L28:
    r38 = load_address _Py_NoneStruct
    r39 = r37 != r38
    dec_ref r37
    if r39 goto L44 else goto L30 :: bool
L29:
    return 0
L30:
    r40 = 'base'
    r41 = CPyObject_GetAttr(r5, r40)
    dec_ref r5
    if is_error(r41) goto L35 (error at __call__:241) else goto L31
L31:
    r42 = cast(str, r41)
    if is_error(r42) goto L35 (error at __call__:241) else goto L32
L32:
    r43 = self.base
    if is_error(r43) goto L45 (error at __call__:241) else goto L33
L33:
    r44 = CPyStr_Equal(r42, r43)
    dec_ref r42
    dec_ref r43
    return r44
L34:
    return 0
L35:
    r45 = <error> :: bool
    return r45
L36:
    dec_ref r9
    goto L10
L37:
    dec_ref r6
    goto L9
L38:
    dec_ref r5
    goto L35
L39:
    dec_ref r5
    goto L34
L40:
    dec_ref r5
    goto L17
L41:
    dec_ref r27
    goto L30
L42:
    dec_ref r5
    dec_ref r27
    goto L35
L43:
    dec_ref r5
    dec_ref r27
    goto L24
L44:
    dec_ref r5
    goto L29
L45:
    dec_ref r42
    goto L35

def BaseEquals.__call____Predicate_glue(self, arg):
    self :: faster_eth_abi._registry.BaseEquals
    arg :: str
    r0, r1 :: bool
L0:
    r0 = BaseEquals.__call__(self, arg)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: bool
    return r1

def BaseEquals.__str__(self):
    self :: faster_eth_abi._registry.BaseEquals
    r0 :: union[bool, None]
    r1, r2, r3, r4, r5, r6 :: str
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10 :: str
    r11 :: list
    r12, r13, r14 :: ptr
    r15 :: str
    r16 :: object
    r17 :: bit
    r18, r19 :: str
    r20 :: bool
    r21, r22, r23, r24, r25, r26, r27 :: str
L0:
    r0 = self.with_sub
    if is_error(r0) goto L16 (error at __str__:248) else goto L1
L1:
    r1 = ''
    r2 = '(base == '
    r3 = '{!r:{}}'
    r4 = self.base
    if is_error(r4) goto L17 (error at __str__:250) else goto L2
L2:
    r5 = ''
    r6 = 'format'
    r7 = [r3, r4, r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775811, 0)
    if is_error(r9) goto L18 (error at __str__:250) else goto L3
L3:
    dec_ref r4
    r10 = cast(str, r9)
    if is_error(r10) goto L17 (error at __str__:250) else goto L4
L4:
    r11 = PyList_New(2)
    if is_error(r11) goto L19 (error at __str__:250) else goto L5
L5:
    r12 = get_element_ptr r11 ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    inc_ref r2
    set_mem r13, r2 :: builtins.object*
    r14 = r13 + 8
    set_mem r14, r10 :: builtins.object*
    r15 = PyUnicode_Join(r1, r11)
    dec_ref r11
    if is_error(r15) goto L17 (error at __str__:250) else goto L6
L6:
    r16 = load_address _Py_NoneStruct
    r17 = r0 == r16
    if r17 goto L20 else goto L8 :: bool
L7:
    r18 = ''
    inc_ref r18
    r19 = r18
    goto L13
L8:
    r20 = unbox(bool, r0)
    dec_ref r0
    if is_error(r20) goto L21 (error at __str__:254) else goto L9
L9:
    if r20 goto L10 else goto L11 :: bool
L10:
    r21 = ' and sub is not None'
    inc_ref r21
    r22 = r21
    goto L12
L11:
    r23 = ' and sub is None'
    inc_ref r23
    r22 = r23
L12:
    r19 = r22
L13:
    r24 = PyUnicode_Concat(r15, r19)
    dec_ref r15
    dec_ref r19
    if is_error(r24) goto L16 (error at __str__:250) else goto L14
L14:
    r25 = ')'
    r26 = PyUnicode_Concat(r24, r25)
    dec_ref r24
    if is_error(r26) goto L16 (error at __str__:250) else goto L15
L15:
    return r26
L16:
    r27 = <error> :: str
    return r27
L17:
    dec_ref r0
    goto L16
L18:
    dec_ref r0
    dec_ref r4
    goto L16
L19:
    dec_ref r0
    dec_ref r10
    goto L16
L20:
    dec_ref r0
    goto L7
L21:
    dec_ref r15
    goto L16

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15, r16 :: object
    r17 :: str
    r18 :: dict
    r19, r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: object
    r40 :: str
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: object[1]
    r45 :: object_ptr
    r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: tuple
    r62 :: str
    r63, r64 :: object
    r65 :: bool
    r66, r67 :: str
    r68 :: tuple
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: object
    r76 :: tuple
    r77 :: str
    r78, r79 :: object
    r80 :: bool
    r81, r82, r83, r84, r85 :: str
    r86 :: tuple
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: dict
    r97 :: str
    r98, r99 :: object
    r100 :: tuple
    r101 :: str
    r102, r103 :: object
    r104 :: bool
    r105, r106 :: str
    r107 :: tuple
    r108 :: i32
    r109 :: bit
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114, r115, r116 :: object
    r117 :: tuple
    r118 :: str
    r119, r120 :: object
    r121 :: bool
    r122, r123, r124 :: str
    r125 :: tuple
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: object
    r133 :: dict
    r134 :: str
    r135, r136 :: object
    r137 :: dict
    r138 :: str
    r139, r140, r141 :: object
    r142 :: tuple[object, object]
    r143, r144, r145 :: object
    r146 :: tuple
    r147 :: str
    r148, r149 :: object
    r150 :: bool
    r151, r152, r153, r154 :: str
    r155 :: tuple
    r156 :: i32
    r157 :: bit
    r158 :: dict
    r159 :: str
    r160 :: i32
    r161 :: bit
    r162 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address abc :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('abc', 'abc', 'abc'),)
    r11 = faster_eth_abi._registry.globals :: static
    r12 = 'faster_eth_abi/_registry.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L56 else goto L4 :: bool
L4:
    r15 = ('copy',)
    r16 = ('stdlib_copy',)
    r17 = 'copy'
    r18 = faster_eth_abi._registry.globals :: static
    r19 = CPyImport_ImportFromMany(r17, r15, r16, r18)
    if is_error(r19) goto L56 (error at <module>:2) else goto L5
L5:
    copy = r19 :: module
    dec_ref r19
    r20 = ('Any', 'Dict', 'Final', 'Generic', 'Iterator', 'Optional', 'TypeVar', 'Union', 'final')
    r21 = 'typing'
    r22 = faster_eth_abi._registry.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L56 (error at <module>:5) else goto L6
L6:
    typing = r23 :: module
    dec_ref r23
    r24 = ('TypeStr',)
    r25 = 'eth_typing'
    r26 = faster_eth_abi._registry.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L56 (error at <module>:17) else goto L7
L7:
    eth_typing = r27 :: module
    dec_ref r27
    r28 = ('Self',)
    r29 = 'typing_extensions'
    r30 = faster_eth_abi._registry.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L56 (error at <module>:20) else goto L8
L8:
    typing_extensions = r31 :: module
    dec_ref r31
    r32 = ('MultipleEntriesFound', 'NoEntriesFound', 'ParseError')
    r33 = 'faster_eth_abi.exceptions'
    r34 = faster_eth_abi._registry.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L56 (error at <module>:24) else goto L9
L9:
    faster_eth_abi.exceptions = r35 :: module
    dec_ref r35
    r36 = ('BasicType', 'parse')
    r37 = 'faster_eth_abi.grammar'
    r38 = faster_eth_abi._registry.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L56 (error at <module>:29) else goto L10
L10:
    faster_eth_abi.grammar = r39 :: module
    dec_ref r39
    r40 = '_T'
    r41 = faster_eth_abi._registry.globals :: static
    r42 = 'TypeVar'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L56 (error at <module>:35) else goto L11
L11:
    r44 = [r40]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r43, r45, 1, 0)
    dec_ref r43
    if is_error(r46) goto L56 (error at <module>:35) else goto L12
L12:
    r47 = faster_eth_abi._registry.globals :: static
    r48 = '_T'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L56 (error at <module>:35) else goto L13 :: bool
L13:
    r51 = faster_eth_abi._registry.globals :: static
    r52 = 'stdlib_copy'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L56 (error at <module>:38) else goto L14
L14:
    faster_eth_abi._registry.copy = r53 :: static
    r54 = faster_eth_abi._registry.globals :: static
    r55 = 'copy'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L56 (error at <module>:38) else goto L15 :: bool
L15:
    r58 = abc :: module
    r59 = 'ABC'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L56 (error at <module>:41) else goto L16
L16:
    r61 = PyTuple_Pack(1, r60)
    dec_ref r60
    if is_error(r61) goto L56 (error at <module>:41) else goto L17
L17:
    r62 = 'faster_eth_abi._registry'
    r63 = faster_eth_abi._registry.Copyable_template :: type
    r64 = CPyType_FromTemplate(r63, r61, r62)
    dec_ref r61
    if is_error(r64) goto L56 (error at <module>:41) else goto L18
L18:
    r65 = Copyable_trait_vtable_setup()
    if is_error(r65) goto L57 (error at <module>:-1) else goto L19
L19:
    r66 = '__mypyc_attrs__'
    r67 = '__dict__'
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L57 (error at <module>:41) else goto L20
L20:
    r69 = PyObject_SetAttr(r64, r66, r68)
    dec_ref r68
    r70 = r69 >= 0 :: signed
    if not r70 goto L57 (error at <module>:41) else goto L21 :: bool
L21:
    faster_eth_abi._registry.Copyable = r64 :: type
    r71 = faster_eth_abi._registry.globals :: static
    r72 = 'Copyable'
    r73 = PyDict_SetItem(r71, r72, r64)
    dec_ref r64
    r74 = r73 >= 0 :: signed
    if not r74 goto L56 (error at <module>:41) else goto L22 :: bool
L22:
    r75 = faster_eth_abi._registry.Copyable :: type
    r76 = PyTuple_Pack(1, r75)
    if is_error(r76) goto L56 (error at <module>:54) else goto L23
L23:
    r77 = 'faster_eth_abi._registry'
    r78 = faster_eth_abi._registry.PredicateMapping_template :: type
    r79 = CPyType_FromTemplate(r78, r76, r77)
    dec_ref r76
    if is_error(r79) goto L56 (error at <module>:54) else goto L24
L24:
    r80 = PredicateMapping_trait_vtable_setup()
    if is_error(r80) goto L58 (error at <module>:-1) else goto L25
L25:
    r81 = '__mypyc_attrs__'
    r82 = '_name'
    r83 = '_values'
    r84 = '_labeled_predicates'
    r85 = '__dict__'
    r86 = PyTuple_Pack(4, r82, r83, r84, r85)
    if is_error(r86) goto L58 (error at <module>:54) else goto L26
L26:
    r87 = PyObject_SetAttr(r79, r81, r86)
    dec_ref r86
    r88 = r87 >= 0 :: signed
    if not r88 goto L58 (error at <module>:54) else goto L27 :: bool
L27:
    faster_eth_abi._registry.PredicateMapping = r79 :: type
    r89 = faster_eth_abi._registry.globals :: static
    r90 = 'PredicateMapping'
    r91 = PyDict_SetItem(r89, r90, r79)
    dec_ref r79
    r92 = r91 >= 0 :: signed
    if not r92 goto L56 (error at <module>:54) else goto L28 :: bool
L28:
    r93 = faster_eth_abi._registry.globals :: static
    r94 = 'Generic'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L56 (error at <module>:162) else goto L29
L29:
    r96 = faster_eth_abi._registry.globals :: static
    r97 = '_T'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L59 (error at <module>:162) else goto L30
L30:
    r99 = PyObject_GetItem(r95, r98)
    dec_ref r95
    dec_ref r98
    if is_error(r99) goto L56 (error at <module>:162) else goto L31
L31:
    r100 = PyTuple_Pack(1, r99)
    dec_ref r99
    if is_error(r100) goto L56 (error at <module>:162) else goto L32
L32:
    r101 = 'faster_eth_abi._registry'
    r102 = faster_eth_abi._registry.Predicate_template :: type
    r103 = CPyType_FromTemplate(r102, r100, r101)
    dec_ref r100
    if is_error(r103) goto L56 (error at <module>:162) else goto L33
L33:
    r104 = Predicate_trait_vtable_setup()
    if is_error(r104) goto L60 (error at <module>:-1) else goto L34
L34:
    r105 = '__mypyc_attrs__'
    r106 = '__dict__'
    r107 = PyTuple_Pack(1, r106)
    if is_error(r107) goto L60 (error at <module>:162) else goto L35
L35:
    r108 = PyObject_SetAttr(r103, r105, r107)
    dec_ref r107
    r109 = r108 >= 0 :: signed
    if not r109 goto L60 (error at <module>:162) else goto L36 :: bool
L36:
    faster_eth_abi._registry.Predicate = r103 :: type
    r110 = faster_eth_abi._registry.globals :: static
    r111 = 'Predicate'
    r112 = PyDict_SetItem(r110, r111, r103)
    dec_ref r103
    r113 = r112 >= 0 :: signed
    if not r113 goto L56 (error at <module>:162) else goto L37 :: bool
L37:
    r114 = faster_eth_abi._registry.Predicate :: type
    r115 = load_address PyUnicode_Type
    r116 = PyObject_GetItem(r114, r115)
    if is_error(r116) goto L56 (error at <module>:191) else goto L38
L38:
    r117 = PyTuple_Pack(1, r116)
    dec_ref r116
    if is_error(r117) goto L56 (error at <module>:191) else goto L39
L39:
    r118 = 'faster_eth_abi._registry'
    r119 = faster_eth_abi._registry.Equals_template :: type
    r120 = CPyType_FromTemplate(r119, r117, r118)
    dec_ref r117
    if is_error(r120) goto L56 (error at <module>:191) else goto L40
L40:
    r121 = Equals_trait_vtable_setup()
    if is_error(r121) goto L61 (error at <module>:-1) else goto L41
L41:
    r122 = '__mypyc_attrs__'
    r123 = 'value'
    r124 = '__dict__'
    r125 = PyTuple_Pack(2, r123, r124)
    if is_error(r125) goto L61 (error at <module>:191) else goto L42
L42:
    r126 = PyObject_SetAttr(r120, r122, r125)
    dec_ref r125
    r127 = r126 >= 0 :: signed
    if not r127 goto L61 (error at <module>:191) else goto L43 :: bool
L43:
    faster_eth_abi._registry.Equals = r120 :: type
    r128 = faster_eth_abi._registry.globals :: static
    r129 = 'Equals'
    r130 = PyDict_SetItem(r128, r129, r120)
    dec_ref r120
    r131 = r130 >= 0 :: signed
    if not r131 goto L56 (error at <module>:191) else goto L44 :: bool
L44:
    r132 = faster_eth_abi._registry.Predicate :: type
    r133 = faster_eth_abi._registry.globals :: static
    r134 = 'Union'
    r135 = CPyDict_GetItem(r133, r134)
    if is_error(r135) goto L56 (error at <module>:209) else goto L45
L45:
    r136 = load_address PyUnicode_Type
    r137 = faster_eth_abi._registry.globals :: static
    r138 = 'Optional'
    r139 = CPyDict_GetItem(r137, r138)
    if is_error(r139) goto L62 (error at <module>:209) else goto L46
L46:
    r140 = load_address PyBool_Type
    r141 = PyObject_GetItem(r139, r140)
    dec_ref r139
    if is_error(r141) goto L62 (error at <module>:209) else goto L47
L47:
    inc_ref r136
    r142 = (r136, r141)
    r143 = box(tuple[object, object], r142)
    r144 = PyObject_GetItem(r135, r143)
    dec_ref r135
    dec_ref r143
    if is_error(r144) goto L56 (error at <module>:209) else goto L48
L48:
    r145 = PyObject_GetItem(r132, r144)
    dec_ref r144
    if is_error(r145) goto L56 (error at <module>:209) else goto L49
L49:
    r146 = PyTuple_Pack(1, r145)
    dec_ref r145
    if is_error(r146) goto L56 (error at <module>:209) else goto L50
L50:
    r147 = 'faster_eth_abi._registry'
    r148 = faster_eth_abi._registry.BaseEquals_template :: type
    r149 = CPyType_FromTemplate(r148, r146, r147)
    dec_ref r146
    if is_error(r149) goto L56 (error at <module>:209) else goto L51
L51:
    r150 = BaseEquals_trait_vtable_setup()
    if is_error(r150) goto L63 (error at <module>:-1) else goto L52
L52:
    r151 = '__mypyc_attrs__'
    r152 = 'base'
    r153 = 'with_sub'
    r154 = '__dict__'
    r155 = PyTuple_Pack(3, r152, r153, r154)
    if is_error(r155) goto L63 (error at <module>:209) else goto L53
L53:
    r156 = PyObject_SetAttr(r149, r151, r155)
    dec_ref r155
    r157 = r156 >= 0 :: signed
    if not r157 goto L63 (error at <module>:209) else goto L54 :: bool
L54:
    faster_eth_abi._registry.BaseEquals = r149 :: type
    r158 = faster_eth_abi._registry.globals :: static
    r159 = 'BaseEquals'
    r160 = PyDict_SetItem(r158, r159, r149)
    dec_ref r149
    r161 = r160 >= 0 :: signed
    if not r161 goto L56 (error at <module>:209) else goto L55 :: bool
L55:
    return 1
L56:
    r162 = <error> :: None
    return r162
L57:
    dec_ref r64
    goto L56
L58:
    dec_ref r79
    goto L56
L59:
    dec_ref r95
    goto L56
L60:
    dec_ref r103
    goto L56
L61:
    dec_ref r120
    goto L56
L62:
    dec_ref r135
    goto L56
L63:
    dec_ref r149
    goto L56
