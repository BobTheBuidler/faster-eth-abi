"""
Script to generate YAML test cases for all decode overloads for use with pytest-mypy-plugins.

Usage:
    python scripts/generate_typecheck_codec_overloads_yaml.py

This will overwrite tests/typecheck/test_codec_overloads.yml with comprehensive positive and negative cases
for all supported ABI type strings and overloads. The YAML file is used by pytest-mypy-plugins for robust
type-checking tests.

- Covers: all int, uint, bytes, bool, address, string, arrays, and a representative sample of tuples.
- Negative cases: for each type, also generates a case that should fail type checking.
- If you add new ABI types or overloads, rerun this script to update the YAML file.
- The generated YAML file may be very large.

See the header of tests/typecheck/test_codec_overloads.yml for details.

"""
import itertools
from pathlib import (
    Path,
)
import re

HEADER = """# AUTOGENERATED: Run scripts/generate_typecheck_codec_overloads_yaml.py to update.
# Requires pytest-mypy-plugins
# To run: pip install pytest-mypy-plugins && pytest --mypy

"""


def parse_literal_union_definitions(typing_path):
    """
    Returns a mapping: alias_name -> set of concrete string values.
    Handles both Literal[...] and Union[...] definitions.
    """
    text = Path(typing_path).read_text()
    alias_map = {}

    # Parse Literal[...] definitions
    literal_pattern = re.compile(
        r"(\w+)\s*=\s*Literal\[\s*((?:\"[^\"]+\",?\s*)+)\]", re.MULTILINE
    )
    for match in literal_pattern.finditer(text):
        name = match.group(1)
        values = [v.strip().strip('"') for v in match.group(2).split(",") if v.strip()]
        alias_map[name] = set(values)

    # Parse Union[...] definitions (only those that reference other aliases)
    union_pattern = re.compile(
        r"(\w+)\s*=\s*Union\[\s*((?:\"?\w+\"?,?\s*)+)\]", re.MULTILINE
    )
    for match in union_pattern.finditer(text):
        name = match.group(1)
        refs = [v.strip().strip('"') for v in match.group(2).split(",") if v.strip()]
        values = set()
        for ref in refs:
            if ref in alias_map:
                values.update(alias_map[ref])
        alias_map[name] = values

    return alias_map


def parse_decode_overloads(codec_path):
    """
    Returns a list of overload signatures for decode in codec.py.
    Each signature is a tuple of argument type aliases (e.g., ('BytesTypeStr', 'StringTypeStr'))
    Uses a direct regex: @overload\n\\s+def decode\\(
    """
    text = Path(codec_path).read_text()
    # Find all @overload\n    def decode( ... ):
    overload_blocks = re.split(r"@overload\n\s+def decode\(", text)[1:]
    signatures = []
    for block in overload_blocks:
        # The block starts with the function signature, ending at the first ):
        sig = block.split("):", 1)[0]
        # Find the types: Tuple[...] or types: Iterable[...] or types: Union[...] or types: TypeStr
        m = re.search(r"types:\s*(Tuple|Iterable|Union)?\[(.*?)\]", sig)
        if m:
            inner = m.group(2)
            args = []
            depth = 0
            current = ""
            for c in inner:
                if c == "," and depth == 0:
                    args.append(current.strip())
                    current = ""
                else:
                    if c == "[":
                        depth += 1
                    elif c == "]":
                        depth -= 1
                    current += c
            if current.strip():
                args.append(current.strip())
            signatures.append(tuple(args))
        else:
            m2 = re.search(r"types:\s*(\w+)", sig)
            if m2:
                signatures.append((m2.group(1),))
    return signatures


def expand_aliases(args, alias_map):
    """
    Recursively expand a tuple of type aliases into all possible concrete value tuples.
    """
    expanded = []
    for arg in args:
        if arg in alias_map:
            expanded.append(sorted(alias_map[arg]))
        else:
            expanded.append([arg])
    # Cartesian product of all argument value lists
    return list(itertools.product(*expanded))


def yaml_case(case_name, type_tuple):
    """
    Returns a YAML string for a single positive test case for pytest-mypy-plugins.
    """
    if len(type_tuple) == 1:
        typestr = f'"{type_tuple[0]}"'
    else:
        typestr = "(" + ", ".join(f'"{t}"' for t in type_tuple) + ")"
    return f"""- case: {case_name}
  main: |
    from faster_eth_abi.codec import decode
    x = decode({typestr}, b"\\x00" * 32)
  out: |
    success: true

"""


def main():
    # Step 1: Parse all Literal/Union definitions in typing.py
    alias_map = parse_literal_union_definitions("faster_eth_abi/typing.py")
    # Step 2: Parse all overload signatures in codec.py using direct regex
    signatures = parse_decode_overloads("faster_eth_abi/codec.py")
    print(f"Found {len(signatures)} overload signatures for decode.")
    # Step 3: Expand all combinations using alias_map
    all_cases = set()
    for sig in signatures:
        expanded = expand_aliases(sig, alias_map)
        all_cases.update(expanded)
    print(f"Total concrete decode cases: {len(all_cases)}")
    # Step 4: Write YAML file with all positive test cases
    with open("tests/typecheck/test_codec_overloads.yml", "w") as f:
        f.write(HEADER)
        for idx, case in enumerate(sorted(all_cases)):
            f.write(yaml_case(f"decode_case_{idx}", case))
    print(
        f"Wrote {len(all_cases)} positive test cases to tests/typecheck/test_codec_overloads.yml."
    )


if __name__ == "__main__":
    main()
