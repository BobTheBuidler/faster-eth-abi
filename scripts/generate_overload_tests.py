"""
Script to generate Python typecheck test files for all possible ABI type string argument combinations.

Usage:
    python scripts/generate_overload_tests.py

This will overwrite test files in:
- tests/typecheck/codec/decode/fixed/overload_test_data_*.py (tuple-based)
- tests/typecheck/codec/decode/variable/overload_test_data_*.py (iterable-based)

Test files are chunked in 10,000-case intervals.

- Covers: all int, uint, bytes, bool, string, arrays, and all possible combinations up to length 3, including fallback/unknown types in all permutations.
- If you add new ABI type strings, rerun this script to update the test files.
"""

import itertools
from pathlib import Path

HEADER = """# AUTOGENERATED: Run scripts/generate_overload_tests.py to update.
# Requires mypy and Python 3.10+ (for typing.assert_type)
# To run: pip install mypy && mypy tests/typecheck

from typing import Any, Tuple, Union
from typing_extensions import assert_type
from faster_eth_abi.codec import ABIDecoder
from faster_eth_abi.registry import ABIRegistry

decoder = ABIDecoder(ABIRegistry())
data = b"\\x00" * 32
"""

RETURN_TYPE_MAP = {
    "bytes": "bytes",
    "string": "str",
    "int": "int",
    "bool": "bool",
}
for i in range(8, 257, 8):
    RETURN_TYPE_MAP[f"int{i}"] = "int"
    RETURN_TYPE_MAP[f"uint{i}"] = "int"
for i in range(1, 33):
    RETURN_TYPE_MAP[f"bytes{i}"] = "bytes"

def get_literal_alias_map():
    import sys
    sys.path.insert(0, str(Path(__file__).parent.parent))
    from faster_eth_abi import typing as fabi_typing

    alias_names = [
        "BytesTypeStr",
        "StringTypeStr",
        "IntTypeStr",
        "UintTypeStr",
        "BoolTypeStr",
        "TypeStr",
        "DecodesToIntTypeStr",
    ]
    alias_map = {}
    from typing import get_args
    for name in alias_names:
        if name == "TypeStr":
            from eth_typing.abi import TypeStr as imported_TypeStr
            alias = imported_TypeStr
        elif name == "DecodesToIntTypeStr":
            from faster_eth_abi.codec import DecodesToIntTypeStr
            alias = DecodesToIntTypeStr
        else:
            alias = getattr(fabi_typing, name)
        args = get_args(alias)
        # Flatten nested Unions
        flat = []
        for a in args:
            if hasattr(a, "__origin__") and a.__origin__ is not None:
                flat.extend(get_args(a))
            else:
                flat.append(a)
        alias_map[name] = [str(x) for x in flat]
    return alias_map

def get_all_literals():
    alias_map = get_literal_alias_map()
    # Combine all unique ABI type string literals
    all_literals = set()
    for v in alias_map.values():
        all_literals.update(v)
    # Add fallback/unknown type string
    all_literals.add("unknown_type")
    return sorted(all_literals)

def get_expected_type_tuple(types):
    py_types = [RETURN_TYPE_MAP.get(t, "Any") for t in types]
    return f"Tuple[{', '.join(py_types)}]"

def get_expected_type_iterable(types):
    py_types = [RETURN_TYPE_MAP.get(t, "Any") for t in types]
    unique_types = sorted(set(py_types))
    if "Any" in unique_types:
        return "Tuple[Any, ...]"
    elif len(unique_types) == 1:
        return f"Tuple[{unique_types[0]}, ...]"
    else:
        return f"Tuple[Union[{', '.join(unique_types)}], ...]"

def main():
    all_literals = get_all_literals()
    print(f"Found {len(all_literals)} ABI type string literals (including fallback).")

    max_len = 3
    chunk_size = 10_000

    # Generate all argument combinations for lengths 1, 2, 3
    all_cases = []
    for L in range(1, max_len + 1):
        for combo in itertools.product(all_literals, repeat=L):
            all_cases.append(combo)

    print(f"Total argument combinations (lengths 1-3): {len(all_cases)}")

    # Generate and write tuple-based test cases
    for chunk_idx, start in enumerate(range(0, len(all_cases), chunk_size)):
        end = min(start + chunk_size, len(all_cases))
        fixed_path = Path(f"tests/typecheck/codec/decode/fixed/overload_test_data_{chunk_idx+1:04d}.py")
        fixed_path.parent.mkdir(parents=True, exist_ok=True)
        with open(fixed_path, "w") as f:
            f.write(HEADER)
            for idx, case in enumerate(all_cases[start:end], start=start):
                typestr = ", ".join(f'"{t}"' for t in case)
                # Always pass types as a tuple and data as the second argument
                typestr = f"({typestr},)" if len(case) == 1 else f"({typestr})"
                expected = get_expected_type_tuple(case)
                f.write(
                    f"assert_type(decoder.decode({typestr}, data), {expected})  # tuple case {idx}\n"
                )

    # Generate and write iterable-based test cases
    for chunk_idx, start in enumerate(range(0, len(all_cases), chunk_size)):
        end = min(start + chunk_size, len(all_cases))
        variable_path = Path(f"tests/typecheck/codec/decode/variable/overload_test_data_{chunk_idx+1:04d}.py")
        variable_path.parent.mkdir(parents=True, exist_ok=True)
        with open(variable_path, "w") as f:
            f.write(HEADER)
            for idx, case in enumerate(all_cases[start:end], start=start):
                typestr = "[" + ", ".join(f'"{t}"' for t in case) + "]"
                expected = get_expected_type_iterable(case)
                f.write(
                    f"assert_type(decoder.decode({typestr}, data), {expected})  # iterable case {idx}\n"
                )

    print("Test generation complete.")

if __name__ == "__main__":
    main()
