"""
Script to generate Python typecheck test files for all possible ABI type string argument combinations.

Usage:
    python scripts/generate_overload_tests.py

This will overwrite test files in:
- tests/typecheck/codec/decode/fixed/overload_test_data_*.py (tuple-based)
- tests/typecheck/codec/decode/variable/overload_test_data_*.py (iterable-based)

Test files are chunked in 10,000-case intervals.

Key features:
- Streams generation: cases are written chunk-by-chunk, not all held in memory.
- Progress bar (tqdm) measures chunk files, not individual cases.
- For TupleXXXIntTypeStr, only 10 representative values are sampled (ending with int8, int16, int64, int128, int256, and their uint variants).
- Each chunk's lines are collected and written in a single operation for efficiency.
- Covers: all int, uint, bytes, bool, string, arrays, and all possible combinations up to length 3, including fallback/unknown types in all permutations.
- If you add new ABI type strings, rerun this script to update the test files.
"""

MAX_LEN = 3
CHUNK_SIZE = 50_000

import re
import itertools
from pathlib import Path
import sys
from math import ceil
from typing import get_args, get_origin, Literal, Union, ForwardRef
from tqdm import tqdm


HEADER = """# AUTOGENERATED: Run scripts/generate_overload_tests.py to update.
# Requires mypy and Python 3.10+ (for typing.assert_type)
# To run: pip install mypy && mypy tests/typecheck

from typing import Any, Tuple, Union
from typing_extensions import assert_type
from eth_typing import HexAddress
from faster_eth_abi.codec import ABIDecoder
from faster_eth_abi.registry import ABIRegistry

decoder = ABIDecoder(ABIRegistry())
data = b"\\x00" * 32
"""

RETURN_TYPE_MAP = {
    "address": "HexAddress",
    "address[]": "Tuple[HexAddress, ...]",
    "bytes": "bytes",
    "bytes[]": "Tuple[bytes, ...]",
    "string": "str",
    "string[]": "Tuple[str, ...]",
    "int": "int",
    "bool": "bool",
    "bool[]": "Tuple[bool, ...]",
}
for i in range(8, 257, 8):
    RETURN_TYPE_MAP[f"int{i}"] = "int"
    RETURN_TYPE_MAP[f"uint{i}"] = "int"
    RETURN_TYPE_MAP[f"int{i}[]"] = "int"
    RETURN_TYPE_MAP[f"uint{i}[]"] = "int"
for i in range(1, 33):
    RETURN_TYPE_MAP[f"bytes{i}"] = "bytes"
    RETURN_TYPE_MAP[f"bytes{i}[]"] = "bytes"

def build_alias_map():
    sys.path.insert(0, str(Path(__file__).parent.parent))
    import faster_eth_abi.typing as fabi_typing
    alias_map = {}
    for name in dir(fabi_typing):
        if not name.startswith("_"):
            obj = getattr(fabi_typing, name)
            alias_map[name] = obj
    return alias_map

def all_integers_in_set(s: str, allowed: set[int]) -> bool:
    """
    Parses the input string for all integer values (including negative numbers)
    and returns True if all found integers are members of the allowed set.
    """
    found = set(int(x) for x in re.findall(r'-?\d+', s))
    return found.issubset(allowed)

def extract_all_literals(typ, alias_map, alias_path=None):
    if alias_path is None:
        alias_path = []
    if typ is str:
        raise ValueError(f"Encountered plain 'str' type in alias path: {' -> '.join(alias_path)}.")
    origin = get_origin(typ)
    if origin is Union:
        for arg in get_args(typ):
            yield from extract_all_literals(arg, alias_map, alias_path)
        return
    elif origin is Literal:
        if alias_path[-1].startswith("Tuple") and alias_path[-1].endswith("IntTypeStr"):
            for value in get_args(typ):
                if all_integers_in_set(value, {8, 16, 64, 128, 256}):
                    if value not in RETURN_TYPE_MAP:
                        parentheses_stripped = value[1:-1]
                        types = parentheses_stripped.split(",")
                        RETURN_TYPE_MAP[value] = f"Tuple[{', '.join(RETURN_TYPE_MAP[t] for t in types)}]"
                    yield value
            return
        else:
            yield from get_args(typ)
    elif isinstance(typ, ForwardRef):
        ref_name = typ.__forward_arg__
        if ref_name in alias_map:
            yield from extract_all_literals(alias_map[ref_name], alias_map, alias_path + [ref_name])
            return
        raise RuntimeError(f"ForwardRef {ref_name!r} not found in alias map (path: {' -> '.join(alias_path)})")
    else:
        raise RuntimeError(f"Type {typ!r} is not a Union, Literal, ForwardRef, or str (origin={origin!r}, path: {' -> '.join(alias_path)})")

def expand_literal_values():
    alias_map = build_alias_map()
    alias_names = [
        "AddressTypeStr",
        "BytesTypeStr",
        "StringTypeStr",
        "IntegerTypeStr",
        "BoolTypeStr",
        "ArrayTypeStr",
        "TupleTypeStr",
        "DecodesToIntTypeStr",
    ]
    for name in sorted(alias_names):
        if name == "DecodesToIntTypeStr":
            from faster_eth_abi.codec import DecodesToIntTypeStr
            typ = DecodesToIntTypeStr
        else:
            typ = alias_map[name]
        yield name, map(str, extract_all_literals(typ, alias_map, [name]))

def get_all_literals():
    all_literals = set()
    for name, literal_values in expand_literal_values():
        all_literals.update(literal_values)
    return sorted(all_literals) + ["someothertype"]

def get_expected_type_tuple(types):
    py_types = ["Any" if t == "someothertype" else RETURN_TYPE_MAP[t] for t in types]
    return f"Tuple[{', '.join(py_types)}]"

def get_expected_type_iterable(types):
    py_types = ["Any" if t == "someothertype" else RETURN_TYPE_MAP[t] for t in types]
    unique_types = sorted(set(py_types))
    if "Any" in unique_types:
        return "Tuple[Any, ...]"
    elif len(unique_types) == 1:
        return f"Tuple[{unique_types[0]}, ...]"
    else:
        return f"Tuple[Union[{', '.join(unique_types)}], ...]"

def compute_total_cases_sampled(all_literals):
    n = len(all_literals)
    return sum(n ** L for L in range(1, MAX_LEN + 1))

def compute_total_chunks(all_literals):
    total_cases = compute_total_cases_sampled(all_literals)
    return ceil(total_cases / CHUNK_SIZE)

def stream_cases_and_write_files(all_literals, mode):
    case_counter = 0
    chunk_idx = 1
    total_chunks = compute_total_chunks(all_literals)
    progress = tqdm(total=total_chunks, desc=f"Streaming {mode} chunks") if tqdm else None

    if mode == "tuple":
        out_path = lambda idx: Path(f"tests/typecheck/codec/decode/fixed/overload_test_data_{idx:04d}.py")
        def render(case, idx):
            quoted = [f'"{t}"' for t in case]
            if len(case) == 1:
                typestr = f"({quoted[0]},)"
            else:
                typestr = f"({', '.join(quoted)})"
            expected = get_expected_type_tuple(case)
            return "assert_type(decoder.decode({}, data), {})  # tuple case {}\n".format(typestr, expected, idx)
    else:
        out_path = lambda idx: Path(f"tests/typecheck/codec/decode/variable/overload_test_data_{idx:04d}.py")
        def render(case, idx):
            quoted = [f'"{t}"' for t in case]
            typestr = "[" + ", ".join(quoted) + "]"
            expected = get_expected_type_iterable(case)
            return "assert_type(decoder.decode({}, data), {})  # iterable case {}\n".format(typestr, expected, idx)

    f = None
    chunk_lines = []
    for L in range(1, MAX_LEN + 1):
        for combo in itertools.product(all_literals, repeat=L):
            if case_counter % CHUNK_SIZE == 0:
                if f:
                    f.writelines(chunk_lines)
                    f.close()
                    chunk_lines.clear()
                path = out_path(chunk_idx)
                path.parent.mkdir(parents=True, exist_ok=True)
                f = open(path, "w")
                f.write(HEADER)
                chunk_idx += 1
                if progress:
                    progress.update(1)
            chunk_lines.append(render(combo, case_counter))
            case_counter += 1
        print(f"finished generating cases for length {L}")
    if f:
        if chunk_lines:
            f.writelines(chunk_lines)
        f.close()
    if progress:
        progress.close()
    return case_counter

def main():
    all_literals = get_all_literals()
    print(f"Found {len(all_literals)} ABI type string literals (including fallback).")

    print("Streaming tuple-based test cases...")
    tuple_cases = stream_cases_and_write_files(all_literals, mode="tuple")
    print("Streaming iterable-based test cases...")
    iterable_cases = stream_cases_and_write_files(all_literals, mode="iterable")

    print(f"Total tuple-based cases: {tuple_cases}")
    print(f"Total iterable-based cases: {iterable_cases}")
    print("Test generation complete.")

if __name__ == "__main__":
    main()
