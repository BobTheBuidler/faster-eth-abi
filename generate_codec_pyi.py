import itertools
from typing import (
    Iterator,
)

BASIC_TYPES = {
    "AddressTypeStr": "HexAddress",
    "BoolTypeStr": "bool",
    "BytesTypeStr": "bytes",
    "StringTypeStr": "str",
    "IntegerTypeStr": "int",
    "TypeStr": "Any",
}
"""Dict of TypeStr -> return type pairs"""

DYN_ARRAY_TYPES = {
    "AddressArrayTypeStr": "Tuple[HexAddress, ...]",
    "BoolArrayTypeStr": "Tuple[bool, ...]",
    "BytesArrayTypeStr": "Tuple[bytes, ...]",
    "IntArrayTypeStr": "Tuple[int, ...]",
    "StringArrayTypeStr": "Tuple[str, ...]",
}

TUPLE_TYPES = {
    "TupleAddressAddressTypeStr": "Tuple[HexAddress, HexAddress]",
    "TupleAddressIntTypeStr": "Tuple[HexAddress, int]",
    "TupleBoolBoolTypeStr": "Tuple[bool, bool]",
    "TupleBoolIntTypeStr": "Tuple[bool, int]",
    "TupleBytesIntTypeStr": "Tuple[bytes, int]",
    "TupleBytesBytesTypeStr": "Tuple[bytes, bytes]",
    "TupleIntIntTypeStr": "Tuple[int, int]",
    "TupleStrIntTypeStr": "Tuple[str, int]",
    "TupleStrStrTypeStr": "Tuple[str, str]",
}

# TODO dynamically generate some more types and write them into typing.py
# for arg_type, return_type in TYPES.copy().items():
#    TYPES[f"{arg_type}"]

HEADER = """# This file is auto-generated by generate_codec_pyi.py
from typing import Any, Iterable, Tuple, Union, overload
from eth_typing import HexAddress
from eth_typing.abi import Decodable, TypeStr
from faster_eth_abi.typing import (
    AddressArrayTypeStr,
    AddressTypeStr,
    BoolArrayTypeStr,
    BoolTypeStr,
    BytesArrayTypeStr,
    BytesTypeStr,
    IntegerTypeStr,
    IntArrayTypeStr,
    StringArrayTypeStr,
    StringTypeStr,
    TupleAddressAddressTypeStr,
    TupleAddressIntTypeStr,
    TupleBoolBoolTypeStr,
    TupleBoolIntTypeStr,
    TupleBytesBytesTypeStr,
    TupleBytesIntTypeStr,
    TupleIntIntTypeStr,
    TupleStrIntTypeStr,
    TupleStrStrTypeStr,
)

# TODO TupleVarStringTypeStr = Union[]

class ABIDecoder:
"""

index = 0


def generate_overloads(length: int) -> Iterator[str]:
    # All combinations of TYPES for the given length
    global index
    if length == 1 or length == 3:
        types = BASIC_TYPES | DYN_ARRAY_TYPES
    elif length == 2:
        types = BASIC_TYPES | DYN_ARRAY_TYPES | TUPLE_TYPES
    else:
        types = BASIC_TYPES
    # make sure this is always last
    types["TypeStr"] = types.pop("TypeStr")
    for combo in itertools.product(types, repeat=length):
        index += 1
        yield f"@overload  # {index}"
        yield "def decode("
        yield "    self,"
        yield f"    types: Tuple[{', '.join(combo)}],"
        yield "    data: Decodable,"
        yield "    strict: bool = True,"
        yield f") -> Tuple[{', '.join(types[t] for t in combo)}]: ..."


def main():
    with open("faster_eth_abi/codec.pyi", "w") as f:
        f.write(HEADER)
        for length in [1, 2, 3]:
            if length == 1 or length == 3:
                extra = "basic and array types only"
            elif length == 2:
                extra = "all implemented TypeStr literals"
            else:
                extra = "basic types only"
            f.write(f"\n    # Tuple length {length} overloads - {extra}")
            f.write("\n")
            for line in generate_overloads(length):
                f.write(f"\n    {line}")
            f.write("\n")

        # Add the variadic fallback
        f.write("    @overload\n")
        f.write("    def decode(\n")
        f.write("        self,\n")
        f.write("        types: Tuple[TypeStr, ...],\n")
        f.write("        data: Decodable,\n")
        f.write("        strict: bool = True,\n")
        f.write("    ) -> Tuple[Any, ...]: ...\n")

        f.write("\n\n")
        f.write("\n# these should type check properly")
        f.write('\nab = ABIDecoder().decode(("uint256", "address", "string"), b"")')
        f.write('\ncd = ABIDecoder().decode(("int256", "bytes", "string"), b"")')
        f.write('\nef = ABIDecoder().decode(("uint256", "bool"), b"")')


if __name__ == "__main__":
    main()
