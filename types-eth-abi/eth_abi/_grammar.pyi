from _typeshed import Incomplete
from eth_typing.abi import TypeStr as TypeStr
from faster_eth_abi.exceptions import ABITypeError as ABITypeError
from parsimonious.nodes import Node as Node
from typing import Any, Final, Generic, Literal, NoReturn, Sequence, TypeVar
from typing_extensions import Self

TYPE_ALIASES: Final[Incomplete]
TYPE_ALIAS_RE: Final[Incomplete]
IntSubtype: Incomplete
FixedSubtype: Incomplete
Subtype = IntSubtype | FixedSubtype
TSub = TypeVar('TSub', IntSubtype, FixedSubtype, Literal[None])

class ABIType:
    arrlist: Incomplete
    node: Incomplete
    def __init__(self, arrlist: Sequence[str] | None = None, node: Node | None = None) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def to_type_str(self) -> TypeStr: ...
    @property
    def item_type(self) -> Self: ...
    def validate(self) -> None: ...
    def invalidate(self, error_msg: str) -> NoReturn: ...
    @property
    def is_array(self) -> bool: ...
    @property
    def is_dynamic(self) -> bool: ...
TComp = TypeVar('TComp', bound=ABIType)

class TupleType(ABIType):
    components: Incomplete
    def __init__(self, components: tuple[TComp, ...], arrlist: Sequence[str] | None = None, *, node: Node | None = None) -> None: ...
    def to_type_str(self) -> TypeStr: ...
    @property
    def item_type(self) -> Self: ...
    def validate(self) -> None: ...
    @property
    def is_dynamic(self) -> bool: ...

class BasicType(ABIType, Generic[TSub]):
    base: Incomplete
    sub: Incomplete
    def __init__(self, base: str, sub: TSub | None = None, arrlist: Sequence | None = None, *, node: Node | None = None) -> None: ...
    def to_type_str(self) -> TypeStr: ...
    @property
    def item_type(self) -> Self: ...
    @property
    def is_dynamic(self) -> bool: ...
    def validate(self) -> None: ...
BytesType = BasicType[IntSubtype]
FixedType = BasicType[FixedSubtype]

def normalize(type_str: TypeStr) -> TypeStr: ...
